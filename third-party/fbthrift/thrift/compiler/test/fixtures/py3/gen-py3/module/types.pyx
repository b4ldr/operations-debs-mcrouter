#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import (
    NOTSET as __NOTSET,
    NumberType as __NumberType,
    StructSpec as __StructSpec,
    ListSpec as __ListSpec,
    SetSpec as __SetSpec,
    MapSpec as __MapSpec,
    FieldSpec as __FieldSpec,
    StructType as __StructType,
    Qualifier as __Qualifier,
)
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
    default_inst,
)
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol as __Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import types as _py_types
import itertools
from collections.abc import Sequence, Set, Mapping, Iterable
import warnings
import weakref as __weakref
import builtins as _builtins

cdef object __AnEnumEnumInstances = None  # Set[AnEnum]
cdef object __AnEnumEnumMembers = {}      # Dict[str, AnEnum]
cdef object __AnEnumEnumUniqueValues = dict()    # Dict[int, AnEnum]

@__cython.internal
@__cython.auto_pickle(False)
cdef class __AnEnumMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls):
            return value
        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return AnEnum.NOTSET
            elif cvalue == 1:
                return AnEnum.ONE
            elif cvalue == 2:
                return AnEnum.TWO
            elif cvalue == 3:
                return AnEnum.THREE
            elif cvalue == 4:
                return AnEnum.FOUR

        raise ValueError(f'{value} is not a valid AnEnum')

    def __getitem__(cls, name):
        return __AnEnumEnumMembers[name]

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__',
        'NOTSET',
        'ONE',
        'TWO',
        'THREE',
        'FOUR',
        ]

    def __iter__(cls):
        return iter(__AnEnumEnumUniqueValues.values())

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __AnEnumEnumInstances

    def __len__(cls):
        return len(__AnEnumEnumInstances)


cdef __AnEnum_unique_instance(int value, str name):
    inst = __AnEnumEnumUniqueValues.get(value)
    if inst is None:
        inst = __AnEnumEnumUniqueValues[value] = AnEnum.__new__(AnEnum, value, name)
    __AnEnumEnumMembers[name] = inst
    return inst


@__cython.final
@__cython.auto_pickle(False)
cdef class AnEnum(thrift.py3.types.CompiledEnum):
    NOTSET = __AnEnum_unique_instance(0, "NOTSET")
    ONE = __AnEnum_unique_instance(1, "ONE")
    TWO = __AnEnum_unique_instance(2, "TWO")
    THREE = __AnEnum_unique_instance(3, "THREE")
    FOUR = __AnEnum_unique_instance(4, "FOUR")
    __members__ = thrift.py3.types.MappingProxyType(__AnEnumEnumMembers)

    def __cinit__(self, value, name):
        if __AnEnumEnumInstances is not None:
            raise TypeError('__new__ is disabled in the interest of type-safety')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"AnEnum.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, AnEnum):
            warnings.warn(f"comparison not supported between instances of { AnEnum } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return AnEnum, (self.value,)


__SetMetaClass(<PyTypeObject*> AnEnum, <PyTypeObject*> __AnEnumMeta)
__AnEnumEnumInstances = set(__AnEnumEnumUniqueValues.values())


cdef inline cAnEnum AnEnum_to_cpp(AnEnum value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return AnEnum__NOTSET
    elif cvalue == 1:
        return AnEnum__ONE
    elif cvalue == 2:
        return AnEnum__TWO
    elif cvalue == 3:
        return AnEnum__THREE
    elif cvalue == 4:
        return AnEnum__FOUR
cdef object __FlagsEnumInstances = None  # Set[Flags]
cdef object __FlagsEnumMembers = {}      # Dict[str, Flags]
cdef object __FlagsEnumUniqueValues = dict()    # Dict[int, Flags]
cdef object __FlagsEnumValueMapping = None  # WeakMapping[Int, Flags]

@__cython.internal
@__cython.auto_pickle(False)
cdef class __FlagsMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        cdef bint invert = False
        if isinstance(value, cls):
            return value
        if isinstance(value, int):
            if value < 0:
                invert = True
                value = ~value
            cvalue = value
            if cvalue == 1:
                return ~Flags.flag_A if invert else Flags.flag_A
            elif cvalue == 2:
                return ~Flags.flag_B if invert else Flags.flag_B
            elif cvalue == 4:
                return ~Flags.flag_C if invert else Flags.flag_C
            elif cvalue == 8:
                return ~Flags.flag_D if invert else Flags.flag_D
            item = __FlagsEnumValueMapping.get(value, None)
            if item is None:
                item = Flags.__new__(Flags, value, None)
            return ~item if invert else item

        raise ValueError(f'{value} is not a valid Flags')

    def __getitem__(cls, name):
        return __FlagsEnumMembers[name]

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__',
        'flag_A',
        'flag_B',
        'flag_C',
        'flag_D',
        ]

    def __iter__(cls):
        return iter(__FlagsEnumUniqueValues.values())

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __FlagsEnumInstances

    def __len__(cls):
        return len(__FlagsEnumInstances)


cdef __Flags_unique_instance(int value, str name):
    inst = __FlagsEnumUniqueValues.get(value)
    if inst is None:
        inst = __FlagsEnumUniqueValues[value] = Flags.__new__(Flags, value, name)
    __FlagsEnumMembers[name] = inst
    return inst


@__cython.final
@__cython.auto_pickle(False)
cdef class Flags(thrift.py3.types.Flag):
    flag_A = __Flags_unique_instance(1, "flag_A")
    flag_B = __Flags_unique_instance(2, "flag_B")
    flag_C = __Flags_unique_instance(4, "flag_C")
    flag_D = __Flags_unique_instance(8, "flag_D")
    __members__ = thrift.py3.types.MappingProxyType(__FlagsEnumMembers)

    def __cinit__(self, value, name):
        __ExistingValues = __FlagsEnumValueMapping
        cdef int temp
        if __ExistingValues is not None:
            if value < 0 or value in __ExistingValues:
                raise TypeError('__new__ is disabled in the interest of type-safety')
            elif value == 0:
                name = "0"
            else:
                combo = []
                temp = value
                while temp:
                    flag = thrift.py3.types.largest_flag(temp)
                    if flag not in __ExistingValues:
                        raise ValueError(f'{value} is not a valid Flags')
                    combo.append(__ExistingValues[flag].name)
                    temp ^= flag
                name = '|'.join(combo)
            __ExistingValues[value] = self
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"Flags.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, Flags):
            warnings.warn(f"comparison not supported between instances of { Flags } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return Flags, (self.value,)

    def __contains__(self, other):
        if not isinstance(other, Flags):
            return NotImplemented
        return other.value & self.value == other.value

    def __bool__(self):
        return bool(self.value)

    def __or__(self, other):
        if not isinstance(other, Flags):
            return NotImplemented
        return Flags(self.value | other.value)

    def __and__(self, other):
        if not isinstance(other, Flags):
            return NotImplemented
        return Flags(self.value & other.value)

    def __xor__(self, other):
        if not isinstance(other, Flags):
            return NotImplemented
        return Flags(self.value ^ other.value)

    def __invert__(self):
        inverted = Flags(0)
        for m in Flags:
            if not (m.value & self.value):
                inverted = inverted | m
        return Flags(inverted)


__SetMetaClass(<PyTypeObject*> Flags, <PyTypeObject*> __FlagsMeta)
__FlagsEnumInstances = set(__FlagsEnumUniqueValues.values())
__FlagsEnumValueMapping = __weakref.WeakValueDictionary(
    {f.value: f for f in tuple(Flags)}
)


cdef inline cFlags Flags_to_cpp(Flags value):
    return <cFlags>(<int>value.value)


cdef object __BinaryUnion_Union_TypeEnumMembers = None


@__cython.internal
@__cython.auto_pickle(False)
cdef class __BinaryUnion_Union_TypeMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __BinaryUnion_Union_TypeEnumMembers:
            return value

        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return __BinaryUnionType.EMPTY
            elif cvalue == 1:
                return __BinaryUnionType.iobuf_val

        raise ValueError(f'{value} is not a valid BinaryUnion.Type')

    def __getitem__(cls, name):
        if name == "EMPTY":
            return __BinaryUnionType.EMPTY
        elif name == "iobuf_val":
            return __BinaryUnionType.iobuf_val
        raise KeyError(name)

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__', 'EMPTY',
            'iobuf_val',
        ]

    @property
    def __members__(cls):
        return {m.name: m for m in cls}

    def __iter__(cls):
        yield __BinaryUnionType.EMPTY
        yield __BinaryUnionType.iobuf_val

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __BinaryUnion_Union_TypeEnumMembers

    def __len__(cls):
        return 1+1  # For Empty


@__cython.final
@__cython.auto_pickle(False)
cdef class __BinaryUnionType(thrift.py3.types.CompiledEnum):
    EMPTY = __BinaryUnionType.__new__(__BinaryUnionType, 0, "EMPTY")
    iobuf_val = __BinaryUnionType.__new__(__BinaryUnionType, 1, "iobuf_val")

    def __cinit__(self, value, name):
        if __BinaryUnion_Union_TypeEnumMembers is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"BinaryUnion.Type.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, __BinaryUnionType):
            warnings.warn(f"comparison not supported between instances of { __BinaryUnionType } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return __BinaryUnionType, (self.value,)

__SetMetaClass(<PyTypeObject*> __BinaryUnionType, <PyTypeObject*> __BinaryUnion_Union_TypeMeta)
__BinaryUnion_Union_TypeEnumMembers = set(__BinaryUnionType)


@__cython.auto_pickle(False)
cdef class SimpleException(thrift.py3.exceptions.Error):

    def __init__(
        SimpleException self,
        err_code=None
    ):
        if err_code is not None:
            if not isinstance(err_code, int):
                raise TypeError(f'err_code is not a { int !r}.')
            err_code = <cint16_t> err_code

        self._cpp_obj = move(SimpleException._make_instance(
          NULL,
          NULL,
          err_code,
        ))
        _builtins.Exception.__init__(self, self.err_code)


    @staticmethod
    cdef unique_ptr[cSimpleException] _make_instance(
        cSimpleException* base_instance,
        bint* __isNOTSET,
        object err_code 
    ) except *:
        cdef unique_ptr[cSimpleException] c_inst
        if base_instance:
            c_inst = make_unique[cSimpleException](deref(base_instance))
        else:
            c_inst = make_unique[cSimpleException]()

        if err_code is not None:
            deref(c_inst).err_code = err_code
            deref(c_inst).__isset.err_code = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'err_code', self.err_code

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSimpleException] cpp_obj):
        inst = <SimpleException>SimpleException.__new__(SimpleException, (<bytes>deref(cpp_obj).what()).decode('utf-8'))
        inst._cpp_obj = move_shared(cpp_obj)
        _builtins.Exception.__init__(inst, inst.err_code)
        return inst

    @property
    def err_code(self):

        return deref(self._cpp_obj).err_code


    def __hash__(SimpleException self):
        return super().__hash__()

    def __repr__(SimpleException self):
        return f'SimpleException(err_code={repr(self.err_code)})'
    def __copy__(SimpleException self):
        cdef shared_ptr[cSimpleException] cpp_obj = make_shared[cSimpleException](
            deref(self._cpp_obj)
        )
        return SimpleException.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, SimpleException) and
                isinstance(other, SimpleException)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cSimpleException* cself = (<SimpleException>self)._cpp_obj.get()
        cdef cSimpleException* cother = (<SimpleException>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = SimpleException.create(constant_shared_ptr[cSimpleException](default_inst[cSimpleException]()))
      return __StructSpec(
        name="SimpleException",
        kind=__StructType.EXCEPTION,
        fields=[
          __FieldSpec(
  name="err_code",
  type=int,
  kind=__NumberType.I16,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )


@__cython.auto_pickle(False)
cdef class OptionalRefStruct(thrift.py3.types.Struct):

    def __init__(
        OptionalRefStruct self, *,
        __iobuf.IOBuf optional_blob=None
    ):
        self._cpp_obj = move(OptionalRefStruct._make_instance(
          NULL,
          NULL,
          optional_blob,
        ))

    def __call__(
        OptionalRefStruct self,
        optional_blob=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        changes = False
        if optional_blob is ___NOTSET:
            __isNOTSET[0] = True
            optional_blob = None
        else:
            __isNOTSET[0] = False
            changes = True


        if not changes:
            return self

        if optional_blob is not None:
            if not isinstance(optional_blob, __iobuf.IOBuf):
                raise TypeError(f'optional_blob is not a { __iobuf.IOBuf !r}.')

        inst = <OptionalRefStruct>OptionalRefStruct.__new__(OptionalRefStruct)
        inst._cpp_obj = move(OptionalRefStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          optional_blob,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cOptionalRefStruct] _make_instance(
        cOptionalRefStruct* base_instance,
        bint* __isNOTSET,
        __iobuf.IOBuf optional_blob 
    ) except *:
        cdef unique_ptr[cOptionalRefStruct] c_inst
        if base_instance:
            c_inst = make_unique[cOptionalRefStruct](deref(base_instance))
        else:
            c_inst = make_unique[cOptionalRefStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and optional_blob is None:
                deref(c_inst).__isset.optional_blob = False
                deref(c_inst).optional_blob.reset()
                pass

        if optional_blob is not None:
            deref(c_inst).optional_blob = (<__iobuf.IOBuf?>optional_blob).c_clone()
            deref(c_inst).__isset.optional_blob = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'optional_blob', self.optional_blob

    def __bool__(self):
        return (deref(self._cpp_obj).__isset.optional_blob and <bint>(deref(self._cpp_obj).optional_blob))

    @staticmethod
    cdef create(shared_ptr[cOptionalRefStruct] cpp_obj):
        inst = <OptionalRefStruct>OptionalRefStruct.__new__(OptionalRefStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def optional_blob(self):
        if not deref(self._cpp_obj).__isset.optional_blob:
            return None

        if self.__field_optional_blob is None:
            if not deref(self._cpp_obj).optional_blob:
                return None
            self.__field_optional_blob = __iobuf.IOBuf.create(deref(self._cpp_obj).optional_blob.get(), self)
        return self.__field_optional_blob


    def __hash__(OptionalRefStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.optional_blob,
            ))
        return self.__hash

    def __repr__(OptionalRefStruct self):
        return f'OptionalRefStruct(optional_blob={repr(self.optional_blob)})'
    def __copy__(OptionalRefStruct self):
        cdef shared_ptr[cOptionalRefStruct] cpp_obj = make_shared[cOptionalRefStruct](
            deref(self._cpp_obj)
        )
        return OptionalRefStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, OptionalRefStruct) and
                isinstance(other, OptionalRefStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cOptionalRefStruct* cself = (<OptionalRefStruct>self)._cpp_obj.get()
        cdef cOptionalRefStruct* cother = (<OptionalRefStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = OptionalRefStruct.create(constant_shared_ptr[cOptionalRefStruct](default_inst[cOptionalRefStruct]()))
      return __StructSpec(
        name="OptionalRefStruct",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="optional_blob",
  type=__iobuf.IOBuf,
  kind=None,
  qualifier=__Qualifier.OPTIONAL,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(OptionalRefStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cOptionalRefStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cOptionalRefStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cOptionalRefStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cOptionalRefStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cOptionalRefStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(OptionalRefStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cOptionalRefStruct]()
        cdef cOptionalRefStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cOptionalRefStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cOptionalRefStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cOptionalRefStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cOptionalRefStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (OptionalRefStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class SimpleStruct(thrift.py3.types.Struct):

    def __init__(
        SimpleStruct self, *,
        pbool is_on=None,
        tiny_int=None,
        small_int=None,
        nice_sized_int=None,
        big_int=None,
        real=None,
        smaller_real=None
    ):
        if tiny_int is not None:
            if not isinstance(tiny_int, int):
                raise TypeError(f'tiny_int is not a { int !r}.')
            tiny_int = <cint8_t> tiny_int

        if small_int is not None:
            if not isinstance(small_int, int):
                raise TypeError(f'small_int is not a { int !r}.')
            small_int = <cint16_t> small_int

        if nice_sized_int is not None:
            if not isinstance(nice_sized_int, int):
                raise TypeError(f'nice_sized_int is not a { int !r}.')
            nice_sized_int = <cint32_t> nice_sized_int

        if big_int is not None:
            if not isinstance(big_int, int):
                raise TypeError(f'big_int is not a { int !r}.')
            big_int = <cint64_t> big_int

        if real is not None:
            if not isinstance(real, (float, int)):
                raise TypeError(f'real is not a { float !r}.')

        if smaller_real is not None:
            if not isinstance(smaller_real, (float, int)):
                raise TypeError(f'smaller_real is not a { float !r}.')

        self._cpp_obj = move(SimpleStruct._make_instance(
          NULL,
          NULL,
          is_on,
          tiny_int,
          small_int,
          nice_sized_int,
          big_int,
          real,
          smaller_real,
        ))

    def __call__(
        SimpleStruct self,
        is_on=__NOTSET,
        tiny_int=__NOTSET,
        small_int=__NOTSET,
        nice_sized_int=__NOTSET,
        big_int=__NOTSET,
        real=__NOTSET,
        smaller_real=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[7] __isNOTSET  # so make_instance is typed

        changes = False
        if is_on is ___NOTSET:
            __isNOTSET[0] = True
            is_on = None
        else:
            __isNOTSET[0] = False
            changes = True

        if tiny_int is ___NOTSET:
            __isNOTSET[1] = True
            tiny_int = None
        else:
            __isNOTSET[1] = False
            changes = True

        if small_int is ___NOTSET:
            __isNOTSET[2] = True
            small_int = None
        else:
            __isNOTSET[2] = False
            changes = True

        if nice_sized_int is ___NOTSET:
            __isNOTSET[3] = True
            nice_sized_int = None
        else:
            __isNOTSET[3] = False
            changes = True

        if big_int is ___NOTSET:
            __isNOTSET[4] = True
            big_int = None
        else:
            __isNOTSET[4] = False
            changes = True

        if real is ___NOTSET:
            __isNOTSET[5] = True
            real = None
        else:
            __isNOTSET[5] = False
            changes = True

        if smaller_real is ___NOTSET:
            __isNOTSET[6] = True
            smaller_real = None
        else:
            __isNOTSET[6] = False
            changes = True


        if not changes:
            return self

        if is_on is not None:
            if not isinstance(is_on, bool):
                raise TypeError(f'is_on is not a { bool !r}.')

        if tiny_int is not None:
            if not isinstance(tiny_int, int):
                raise TypeError(f'tiny_int is not a { int !r}.')
            tiny_int = <cint8_t> tiny_int

        if small_int is not None:
            if not isinstance(small_int, int):
                raise TypeError(f'small_int is not a { int !r}.')
            small_int = <cint16_t> small_int

        if nice_sized_int is not None:
            if not isinstance(nice_sized_int, int):
                raise TypeError(f'nice_sized_int is not a { int !r}.')
            nice_sized_int = <cint32_t> nice_sized_int

        if big_int is not None:
            if not isinstance(big_int, int):
                raise TypeError(f'big_int is not a { int !r}.')
            big_int = <cint64_t> big_int

        if real is not None:
            if not isinstance(real, (float, int)):
                raise TypeError(f'real is not a { float !r}.')

        if smaller_real is not None:
            if not isinstance(smaller_real, (float, int)):
                raise TypeError(f'smaller_real is not a { float !r}.')

        inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        inst._cpp_obj = move(SimpleStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          is_on,
          tiny_int,
          small_int,
          nice_sized_int,
          big_int,
          real,
          smaller_real,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cSimpleStruct] _make_instance(
        cSimpleStruct* base_instance,
        bint* __isNOTSET,
        pbool is_on ,
        object tiny_int ,
        object small_int ,
        object nice_sized_int ,
        object big_int ,
        object real ,
        object smaller_real 
    ) except *:
        cdef unique_ptr[cSimpleStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSimpleStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSimpleStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and is_on is None:
                deref(c_inst).is_on = default_inst[cSimpleStruct]().is_on
                deref(c_inst).__isset.is_on = False
                pass

            if not __isNOTSET[1] and tiny_int is None:
                deref(c_inst).tiny_int = default_inst[cSimpleStruct]().tiny_int
                deref(c_inst).__isset.tiny_int = False
                pass

            if not __isNOTSET[2] and small_int is None:
                deref(c_inst).small_int = default_inst[cSimpleStruct]().small_int
                deref(c_inst).__isset.small_int = False
                pass

            if not __isNOTSET[3] and nice_sized_int is None:
                deref(c_inst).nice_sized_int = default_inst[cSimpleStruct]().nice_sized_int
                deref(c_inst).__isset.nice_sized_int = False
                pass

            if not __isNOTSET[4] and big_int is None:
                deref(c_inst).big_int = default_inst[cSimpleStruct]().big_int
                deref(c_inst).__isset.big_int = False
                pass

            if not __isNOTSET[5] and real is None:
                deref(c_inst).real = default_inst[cSimpleStruct]().real
                deref(c_inst).__isset.real = False
                pass

            if not __isNOTSET[6] and smaller_real is None:
                deref(c_inst).smaller_real = default_inst[cSimpleStruct]().smaller_real
                deref(c_inst).__isset.smaller_real = False
                pass

        if is_on is not None:
            deref(c_inst).is_on = is_on
            deref(c_inst).__isset.is_on = True
        if tiny_int is not None:
            deref(c_inst).tiny_int = tiny_int
            deref(c_inst).__isset.tiny_int = True
        if small_int is not None:
            deref(c_inst).small_int = small_int
            deref(c_inst).__isset.small_int = True
        if nice_sized_int is not None:
            deref(c_inst).nice_sized_int = nice_sized_int
            deref(c_inst).__isset.nice_sized_int = True
        if big_int is not None:
            deref(c_inst).big_int = big_int
            deref(c_inst).__isset.big_int = True
        if real is not None:
            deref(c_inst).real = real
            deref(c_inst).__isset.real = True
        if smaller_real is not None:
            deref(c_inst).smaller_real = smaller_real
            deref(c_inst).__isset.smaller_real = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'is_on', self.is_on
        yield 'tiny_int', self.tiny_int
        yield 'small_int', self.small_int
        yield 'nice_sized_int', self.nice_sized_int
        yield 'big_int', self.big_int
        yield 'real', self.real
        yield 'smaller_real', self.smaller_real

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSimpleStruct] cpp_obj):
        inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def is_on(self):

        return <pbool> deref(self._cpp_obj).is_on

    @property
    def tiny_int(self):

        return deref(self._cpp_obj).tiny_int

    @property
    def small_int(self):

        return deref(self._cpp_obj).small_int

    @property
    def nice_sized_int(self):

        return deref(self._cpp_obj).nice_sized_int

    @property
    def big_int(self):

        return deref(self._cpp_obj).big_int

    @property
    def real(self):

        return deref(self._cpp_obj).real

    @property
    def smaller_real(self):

        return deref(self._cpp_obj).smaller_real


    def __hash__(SimpleStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.is_on,
            self.tiny_int,
            self.small_int,
            self.nice_sized_int,
            self.big_int,
            self.real,
            self.smaller_real,
            ))
        return self.__hash

    def __repr__(SimpleStruct self):
        return f'SimpleStruct(is_on={repr(self.is_on)}, tiny_int={repr(self.tiny_int)}, small_int={repr(self.small_int)}, nice_sized_int={repr(self.nice_sized_int)}, big_int={repr(self.big_int)}, real={repr(self.real)}, smaller_real={repr(self.smaller_real)})'
    def __copy__(SimpleStruct self):
        cdef shared_ptr[cSimpleStruct] cpp_obj = make_shared[cSimpleStruct](
            deref(self._cpp_obj)
        )
        return SimpleStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, SimpleStruct) and
                isinstance(other, SimpleStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cSimpleStruct* cself = (<SimpleStruct>self)._cpp_obj.get()
        cdef cSimpleStruct* cother = (<SimpleStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = SimpleStruct.create(constant_shared_ptr[cSimpleStruct](default_inst[cSimpleStruct]()))
      return __StructSpec(
        name="SimpleStruct",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="is_on",
  type=bool,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="tiny_int",
  type=int,
  kind=__NumberType.BYTE,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="small_int",
  type=int,
  kind=__NumberType.I16,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="nice_sized_int",
  type=int,
  kind=__NumberType.I32,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="big_int",
  type=int,
  kind=__NumberType.I64,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="real",
  type=float,
  kind=__NumberType.DOUBLE,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="smaller_real",
  type=float,
  kind=__NumberType.FLOAT,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(SimpleStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cSimpleStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cSimpleStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cSimpleStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cSimpleStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cSimpleStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(SimpleStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cSimpleStruct]()
        cdef cSimpleStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cSimpleStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cSimpleStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cSimpleStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cSimpleStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (SimpleStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class ComplexStruct(thrift.py3.types.Struct):

    def __init__(
        ComplexStruct self, *,
        SimpleStruct structOne=None,
        SimpleStruct structTwo=None,
        an_integer=None,
        str name=None,
        AnEnum an_enum=None,
        bytes some_bytes=None,
        str sender=None,
        str cdef_=None,
        bytes bytes_with_cpp_type=None
    ):
        if an_integer is not None:
            if not isinstance(an_integer, int):
                raise TypeError(f'an_integer is not a { int !r}.')
            an_integer = <cint32_t> an_integer

        self._cpp_obj = move(ComplexStruct._make_instance(
          NULL,
          NULL,
          structOne,
          structTwo,
          an_integer,
          name,
          an_enum,
          some_bytes,
          sender,
          cdef_,
          bytes_with_cpp_type,
        ))

    def __call__(
        ComplexStruct self,
        structOne=__NOTSET,
        structTwo=__NOTSET,
        an_integer=__NOTSET,
        name=__NOTSET,
        an_enum=__NOTSET,
        some_bytes=__NOTSET,
        sender=__NOTSET,
        cdef_=__NOTSET,
        bytes_with_cpp_type=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[9] __isNOTSET  # so make_instance is typed

        changes = False
        if structOne is ___NOTSET:
            __isNOTSET[0] = True
            structOne = None
        else:
            __isNOTSET[0] = False
            changes = True

        if structTwo is ___NOTSET:
            __isNOTSET[1] = True
            structTwo = None
        else:
            __isNOTSET[1] = False
            changes = True

        if an_integer is ___NOTSET:
            __isNOTSET[2] = True
            an_integer = None
        else:
            __isNOTSET[2] = False
            changes = True

        if name is ___NOTSET:
            __isNOTSET[3] = True
            name = None
        else:
            __isNOTSET[3] = False
            changes = True

        if an_enum is ___NOTSET:
            __isNOTSET[4] = True
            an_enum = None
        else:
            __isNOTSET[4] = False
            changes = True

        if some_bytes is ___NOTSET:
            __isNOTSET[5] = True
            some_bytes = None
        else:
            __isNOTSET[5] = False
            changes = True

        if sender is ___NOTSET:
            __isNOTSET[6] = True
            sender = None
        else:
            __isNOTSET[6] = False
            changes = True

        if cdef_ is ___NOTSET:
            __isNOTSET[7] = True
            cdef_ = None
        else:
            __isNOTSET[7] = False
            changes = True

        if bytes_with_cpp_type is ___NOTSET:
            __isNOTSET[8] = True
            bytes_with_cpp_type = None
        else:
            __isNOTSET[8] = False
            changes = True


        if not changes:
            return self

        if structOne is not None:
            if not isinstance(structOne, SimpleStruct):
                raise TypeError(f'structOne is not a { SimpleStruct !r}.')

        if structTwo is not None:
            if not isinstance(structTwo, SimpleStruct):
                raise TypeError(f'structTwo is not a { SimpleStruct !r}.')

        if an_integer is not None:
            if not isinstance(an_integer, int):
                raise TypeError(f'an_integer is not a { int !r}.')
            an_integer = <cint32_t> an_integer

        if name is not None:
            if not isinstance(name, str):
                raise TypeError(f'name is not a { str !r}.')

        if an_enum is not None:
            if not isinstance(an_enum, AnEnum):
                raise TypeError(f'field an_enum value: { an_enum !r} is not of the enum type { AnEnum }.')

        if some_bytes is not None:
            if not isinstance(some_bytes, bytes):
                raise TypeError(f'some_bytes is not a { bytes !r}.')

        if sender is not None:
            if not isinstance(sender, str):
                raise TypeError(f'sender is not a { str !r}.')

        if cdef_ is not None:
            if not isinstance(cdef_, str):
                raise TypeError(f'cdef_ is not a { str !r}.')

        if bytes_with_cpp_type is not None:
            if not isinstance(bytes_with_cpp_type, bytes):
                raise TypeError(f'bytes_with_cpp_type is not a { bytes !r}.')

        inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        inst._cpp_obj = move(ComplexStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          structOne,
          structTwo,
          an_integer,
          name,
          an_enum,
          some_bytes,
          sender,
          cdef_,
          bytes_with_cpp_type,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cComplexStruct] _make_instance(
        cComplexStruct* base_instance,
        bint* __isNOTSET,
        SimpleStruct structOne ,
        SimpleStruct structTwo ,
        object an_integer ,
        str name ,
        AnEnum an_enum ,
        bytes some_bytes ,
        str sender ,
        str cdef_ ,
        bytes bytes_with_cpp_type 
    ) except *:
        cdef unique_ptr[cComplexStruct] c_inst
        if base_instance:
            c_inst = make_unique[cComplexStruct](deref(base_instance))
        else:
            c_inst = make_unique[cComplexStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and structOne is None:
                deref(c_inst).structOne = default_inst[cComplexStruct]().structOne
                deref(c_inst).__isset.structOne = False
                pass

            if not __isNOTSET[1] and structTwo is None:
                deref(c_inst).structTwo = default_inst[cComplexStruct]().structTwo
                deref(c_inst).__isset.structTwo = False
                pass

            if not __isNOTSET[2] and an_integer is None:
                deref(c_inst).an_integer = default_inst[cComplexStruct]().an_integer
                deref(c_inst).__isset.an_integer = False
                pass

            if not __isNOTSET[3] and name is None:
                deref(c_inst).name = default_inst[cComplexStruct]().name
                deref(c_inst).__isset.name = False
                pass

            if not __isNOTSET[4] and an_enum is None:
                deref(c_inst).an_enum = default_inst[cComplexStruct]().an_enum
                deref(c_inst).__isset.an_enum = False
                pass

            if not __isNOTSET[5] and some_bytes is None:
                deref(c_inst).some_bytes = default_inst[cComplexStruct]().some_bytes
                deref(c_inst).__isset.some_bytes = False
                pass

            if not __isNOTSET[6] and sender is None:
                deref(c_inst).sender = default_inst[cComplexStruct]().sender
                deref(c_inst).__isset.sender = False
                pass

            if not __isNOTSET[7] and cdef_ is None:
                deref(c_inst).cdef_ = default_inst[cComplexStruct]().cdef_
                deref(c_inst).__isset.cdef_ = False
                pass

            if not __isNOTSET[8] and bytes_with_cpp_type is None:
                deref(c_inst).bytes_with_cpp_type = default_inst[cComplexStruct]().bytes_with_cpp_type
                deref(c_inst).__isset.bytes_with_cpp_type = False
                pass

        if structOne is not None:
            deref(c_inst).structOne = deref((<SimpleStruct?> structOne)._cpp_obj)
            deref(c_inst).__isset.structOne = True
        if structTwo is not None:
            deref(c_inst).structTwo = deref((<SimpleStruct?> structTwo)._cpp_obj)
            deref(c_inst).__isset.structTwo = True
        if an_integer is not None:
            deref(c_inst).an_integer = an_integer
            deref(c_inst).__isset.an_integer = True
        if name is not None:
            deref(c_inst).name = thrift.py3.types.move(thrift.py3.types.bytes_to_string(name.encode('utf-8')))
            deref(c_inst).__isset.name = True
        if an_enum is not None:
            deref(c_inst).an_enum = AnEnum_to_cpp(an_enum)
            deref(c_inst).__isset.an_enum = True
        if some_bytes is not None:
            deref(c_inst).some_bytes = thrift.py3.types.move(thrift.py3.types.bytes_to_string(some_bytes))
            deref(c_inst).__isset.some_bytes = True
        if sender is not None:
            deref(c_inst).sender = thrift.py3.types.move(thrift.py3.types.bytes_to_string(sender.encode('utf-8')))
            deref(c_inst).__isset.sender = True
        if cdef_ is not None:
            deref(c_inst).cdef_ = thrift.py3.types.move(thrift.py3.types.bytes_to_string(cdef_.encode('utf-8')))
            deref(c_inst).__isset.cdef_ = True
        if bytes_with_cpp_type is not None:
            deref(c_inst).bytes_with_cpp_type = foo_Bar(move(<string>bytes_with_cpp_type))
            deref(c_inst).__isset.bytes_with_cpp_type = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'structOne', self.structOne
        yield 'structTwo', self.structTwo
        yield 'an_integer', self.an_integer
        yield 'name', self.name
        yield 'an_enum', self.an_enum
        yield 'some_bytes', self.some_bytes
        yield 'sender', self.sender
        yield 'cdef_', self.cdef_
        yield 'bytes_with_cpp_type', self.bytes_with_cpp_type

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cComplexStruct] cpp_obj):
        inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def structOne(self):

        if self.__field_structOne is None:
            self.__field_structOne = SimpleStruct.create(reference_shared_ptr_structOne(self._cpp_obj, deref(self._cpp_obj).structOne))
        return self.__field_structOne

    @property
    def structTwo(self):

        if self.__field_structTwo is None:
            self.__field_structTwo = SimpleStruct.create(reference_shared_ptr_structTwo(self._cpp_obj, deref(self._cpp_obj).structTwo))
        return self.__field_structTwo

    @property
    def an_integer(self):

        return deref(self._cpp_obj).an_integer

    @property
    def name(self):

        return (<bytes>deref(self._cpp_obj).name).decode('UTF-8')

    @property
    def an_enum(self):

        return translate_cpp_enum_to_python(AnEnum, <int>(deref(self._cpp_obj).an_enum))

    @property
    def some_bytes(self):

        return deref(self._cpp_obj).some_bytes

    @property
    def sender(self):

        return (<bytes>deref(self._cpp_obj).sender).decode('UTF-8')

    @property
    def cdef_(self):

        return (<bytes>deref(self._cpp_obj).cdef_).decode('UTF-8')

    @property
    def bytes_with_cpp_type(self):

        return (<const char*>deref(self._cpp_obj).bytes_with_cpp_type.data())[:deref(self._cpp_obj).bytes_with_cpp_type.size()]


    def __hash__(ComplexStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.structOne,
            self.structTwo,
            self.an_integer,
            self.name,
            self.an_enum,
            self.some_bytes,
            self.sender,
            self.cdef_,
            self.bytes_with_cpp_type,
            ))
        return self.__hash

    def __repr__(ComplexStruct self):
        return f'ComplexStruct(structOne={repr(self.structOne)}, structTwo={repr(self.structTwo)}, an_integer={repr(self.an_integer)}, name={repr(self.name)}, an_enum={repr(self.an_enum)}, some_bytes={repr(self.some_bytes)}, sender={repr(self.sender)}, cdef_={repr(self.cdef_)}, bytes_with_cpp_type={repr(self.bytes_with_cpp_type)})'
    def __copy__(ComplexStruct self):
        cdef shared_ptr[cComplexStruct] cpp_obj = make_shared[cComplexStruct](
            deref(self._cpp_obj)
        )
        return ComplexStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ComplexStruct) and
                isinstance(other, ComplexStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cComplexStruct* cself = (<ComplexStruct>self)._cpp_obj.get()
        cdef cComplexStruct* cother = (<ComplexStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = ComplexStruct.create(constant_shared_ptr[cComplexStruct](default_inst[cComplexStruct]()))
      return __StructSpec(
        name="ComplexStruct",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="structOne",
  type=SimpleStruct,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="structTwo",
  type=SimpleStruct,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="an_integer",
  type=int,
  kind=__NumberType.I32,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="name",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="an_enum",
  type=AnEnum,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="some_bytes",
  type=bytes,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="from",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
    """py3.name""": """sender""",  }),
),
                __FieldSpec(
  name="cdef",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="bytes_with_cpp_type",
  type=bytes,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(ComplexStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cComplexStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cComplexStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cComplexStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cComplexStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cComplexStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(ComplexStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cComplexStruct]()
        cdef cComplexStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cComplexStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cComplexStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cComplexStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cComplexStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (ComplexStruct, serialize(self)))




@__cython.auto_pickle(False)
cdef class BinaryUnion(thrift.py3.types.Union):
    Type = __BinaryUnionType

    def __init__(
        self, *,
        __iobuf.IOBuf iobuf_val=None
    ):
        self._cpp_obj = move(BinaryUnion._make_instance(
          NULL,
          iobuf_val,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return BinaryUnion()
        if isinstance(value, __iobuf.IOBuf):
            return BinaryUnion(iobuf_val=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cBinaryUnion] _make_instance(
        cBinaryUnion* base_instance,
        __iobuf.IOBuf iobuf_val
    ) except *:
        cdef unique_ptr[cBinaryUnion] c_inst = make_unique[cBinaryUnion]()
        cdef bint any_set = False
        if iobuf_val is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_iobuf_val(deref((<__iobuf.IOBuf?>iobuf_val).c_clone().release())) 
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type is not __BinaryUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cBinaryUnion] cpp_obj):
        inst = <BinaryUnion>BinaryUnion.__new__(BinaryUnion)
        inst._cpp_obj = move_shared(cpp_obj)
        inst._load_cache()
        return inst

    @property
    def iobuf_val(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not iobuf_val')
        return self.value


    def __hash__(BinaryUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    cdef __BinaryUnion_eq(BinaryUnion self, BinaryUnion other):
        return self.type == other.type and self.value == other.value

    def __repr__(BinaryUnion self):
        return f'BinaryUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(BinaryUnion self):
        self.type = BinaryUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value =  __iobuf.from_unique_ptr(deref(self._cpp_obj).get_iobuf_val().clone())

    def get_type(BinaryUnion self):
        return self.type

    def __copy__(BinaryUnion self):
        cdef shared_ptr[cBinaryUnion] cpp_obj = make_shared[cBinaryUnion](
            deref(self._cpp_obj)
        )
        return BinaryUnion.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, BinaryUnion) and
                isinstance(other, BinaryUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        if cop == Py_EQ:
            return self.__BinaryUnion_eq(other)
        elif cop == Py_NE:
            return not self.__BinaryUnion_eq(other)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      return __StructSpec(
        name="BinaryUnion",
        kind=__StructType.UNION,
        fields=[
          __FieldSpec(
  name="iobuf_val",
  type=__iobuf.IOBuf,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
          """cpp2.noncomparable""": """1""",    }),
      )
    cdef __iobuf.IOBuf _serialize(BinaryUnion self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cBinaryUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cBinaryUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cBinaryUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cBinaryUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cBinaryUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(BinaryUnion self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cBinaryUnion]()
        cdef cBinaryUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cBinaryUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cBinaryUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cBinaryUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cBinaryUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (BinaryUnion, serialize(self)))


@__cython.auto_pickle(False)
cdef class BinaryUnionStruct(thrift.py3.types.Struct):

    def __init__(
        BinaryUnionStruct self, *,
        BinaryUnion u=None
    ):
        self._cpp_obj = move(BinaryUnionStruct._make_instance(
          NULL,
          NULL,
          u,
        ))

    def __call__(
        BinaryUnionStruct self,
        u=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        changes = False
        if u is ___NOTSET:
            __isNOTSET[0] = True
            u = None
        else:
            __isNOTSET[0] = False
            changes = True


        if not changes:
            return self

        if u is not None:
            if not isinstance(u, BinaryUnion):
                raise TypeError(f'u is not a { BinaryUnion !r}.')

        inst = <BinaryUnionStruct>BinaryUnionStruct.__new__(BinaryUnionStruct)
        inst._cpp_obj = move(BinaryUnionStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          u,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cBinaryUnionStruct] _make_instance(
        cBinaryUnionStruct* base_instance,
        bint* __isNOTSET,
        BinaryUnion u 
    ) except *:
        cdef unique_ptr[cBinaryUnionStruct] c_inst
        if base_instance:
            c_inst = make_unique[cBinaryUnionStruct](deref(base_instance))
        else:
            c_inst = make_unique[cBinaryUnionStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and u is None:
                deref(c_inst).u = default_inst[cBinaryUnionStruct]().u
                deref(c_inst).__isset.u = False
                pass

        if u is not None:
            deref(c_inst).u = deref((<BinaryUnion?> u)._cpp_obj)
            deref(c_inst).__isset.u = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'u', self.u

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cBinaryUnionStruct] cpp_obj):
        inst = <BinaryUnionStruct>BinaryUnionStruct.__new__(BinaryUnionStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def u(self):

        if self.__field_u is None:
            self.__field_u = BinaryUnion.create(reference_shared_ptr_u(self._cpp_obj, deref(self._cpp_obj).u))
        return self.__field_u


    def __hash__(BinaryUnionStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.u,
            ))
        return self.__hash

    cdef __BinaryUnionStruct_eq(BinaryUnionStruct self, BinaryUnionStruct other):
        if self.u != other.u:
            return False
        return True

    def __repr__(BinaryUnionStruct self):
        return f'BinaryUnionStruct(u={repr(self.u)})'
    def __copy__(BinaryUnionStruct self):
        cdef shared_ptr[cBinaryUnionStruct] cpp_obj = make_shared[cBinaryUnionStruct](
            deref(self._cpp_obj)
        )
        return BinaryUnionStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, BinaryUnionStruct) and
                isinstance(other, BinaryUnionStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        if cop == Py_EQ:
            return self.__BinaryUnionStruct_eq(other)
        elif cop == Py_NE:
            return not self.__BinaryUnionStruct_eq(other)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = BinaryUnionStruct.create(constant_shared_ptr[cBinaryUnionStruct](default_inst[cBinaryUnionStruct]()))
      return __StructSpec(
        name="BinaryUnionStruct",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="u",
  type=BinaryUnion,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
          """cpp2.noncomparable""": """1""",    }),
      )
    cdef __iobuf.IOBuf _serialize(BinaryUnionStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cBinaryUnionStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cBinaryUnionStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cBinaryUnionStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cBinaryUnionStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cBinaryUnionStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(BinaryUnionStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cBinaryUnionStruct]()
        cdef cBinaryUnionStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cBinaryUnionStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cBinaryUnionStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cBinaryUnionStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cBinaryUnionStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (BinaryUnionStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class List__i16(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__i16):
            self._cpp_obj = (<List__i16> items)._cpp_obj
        else:
            self._cpp_obj = List__i16._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint16_t]] c_items):
        inst = <List__i16>List__i16.__new__(List__i16)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__i16 self):
        cdef shared_ptr[vector[cint16_t]] cpp_obj = make_shared[vector[cint16_t]](
            deref(self._cpp_obj)
        )
        return List__i16.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cint16_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint16_t]] c_inst = make_shared[vector[cint16_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint16_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint16_t]] c_inst
        cdef cint16_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint16_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i16.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint16_t].iterator, cint16_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint16_t citem
        cdef vector[cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef cint16_t citem
        cdef vector[cint16_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint16_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint16_t].iterator loc = std_libcpp.find[vector[cint16_t].iterator, cint16_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint16_t].iterator, cint16_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__i16, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=int, kind=__NumberType.I16)


Sequence.register(List__i16)

@__cython.auto_pickle(False)
cdef class List__i32(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[cint32_t]] cpp_obj = make_shared[vector[cint32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint32_t]] c_inst = make_shared[vector[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint32_t]] c_inst
        cdef cint32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint32_t].iterator, cint32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint32_t].iterator loc = std_libcpp.find[vector[cint32_t].iterator, cint32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint32_t].iterator, cint32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__i32, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=int, kind=__NumberType.I32)


Sequence.register(List__i32)

@__cython.auto_pickle(False)
cdef class List__i64(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint64_t]] c_items):
        inst = <List__i64>List__i64.__new__(List__i64)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__i64 self):
        cdef shared_ptr[vector[cint64_t]] cpp_obj = make_shared[vector[cint64_t]](
            deref(self._cpp_obj)
        )
        return List__i64.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cint64_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint64_t]] c_inst = make_shared[vector[cint64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint64_t]] c_inst
        cdef cint64_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint64_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i64.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint64_t].iterator, cint64_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint64_t citem
        cdef vector[cint64_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef cint64_t citem
        cdef vector[cint64_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint64_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint64_t].iterator loc = std_libcpp.find[vector[cint64_t].iterator, cint64_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint64_t].iterator, cint64_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__i64, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=int, kind=__NumberType.I64)


Sequence.register(List__i64)

@__cython.auto_pickle(False)
cdef class List__string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = List__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__string self):
        cdef shared_ptr[vector[string]] cpp_obj = make_shared[vector[string]](
            deref(self._cpp_obj)
        )
        return List__string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[string]] _make_instance(object items) except *:
        cdef shared_ptr[vector[string]] c_inst = make_shared[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__string.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return std_libcpp.find[vector[string].iterator, string](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item.encode('UTF-8')) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, str):
            raise err
        cdef vector[string].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find[vector[string].iterator, string](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item.encode('UTF-8')        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, str):
            return 0
        return <cint64_t> std_libcpp.count[vector[string].iterator, string](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item.encode('UTF-8'))

    def __reduce__(self):
        return (List__string, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=str, kind=None)


Sequence.register(List__string)

@__cython.auto_pickle(False)
cdef class List__SimpleStruct(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__SimpleStruct):
            self._cpp_obj = (<List__SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = List__SimpleStruct._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cSimpleStruct]] c_items):
        inst = <List__SimpleStruct>List__SimpleStruct.__new__(List__SimpleStruct)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__SimpleStruct self):
        cdef shared_ptr[vector[cSimpleStruct]] cpp_obj = make_shared[vector[cSimpleStruct]](
            deref(self._cpp_obj)
        )
        return List__SimpleStruct.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cSimpleStruct]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cSimpleStruct]] c_inst = make_shared[vector[cSimpleStruct]]()
        if items is not None:
            for item in items:
                if not isinstance(item, SimpleStruct):
                    raise TypeError(f"{item!r} is not of type 'SimpleStruct'")
                deref(c_inst).push_back(deref((<SimpleStruct>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cSimpleStruct]] c_inst
        cdef shared_ptr[cSimpleStruct] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cSimpleStruct]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__SimpleStruct.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__SimpleStruct(self._cpp_obj, deref(self._cpp_obj)[index])
            return SimpleStruct.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, SimpleStruct):
            return False
        return std_libcpp.find[vector[cSimpleStruct].iterator, cSimpleStruct](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<SimpleStruct>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cSimpleStruct] citem
        cdef vector[cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__SimpleStruct(self._cpp_obj, deref(loc))
            yield SimpleStruct.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cSimpleStruct] citem
        cdef vector[cSimpleStruct].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__SimpleStruct(self._cpp_obj, deref(loc))
            yield SimpleStruct.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, SimpleStruct):
            raise err
        cdef vector[cSimpleStruct].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cSimpleStruct].iterator loc = std_libcpp.find[vector[cSimpleStruct].iterator, cSimpleStruct](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<SimpleStruct>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, SimpleStruct):
            return 0
        return <cint64_t> std_libcpp.count[vector[cSimpleStruct].iterator, cSimpleStruct](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<SimpleStruct>item)._cpp_obj))

    def __reduce__(self):
        return (List__SimpleStruct, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=SimpleStruct, kind=None)


Sequence.register(List__SimpleStruct)

@__cython.auto_pickle(False)
cdef class Set__i32(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cint32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[cint32_t]] cpp_obj = make_shared[cset[cint32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cint32_t]] c_inst = make_shared[cset[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cset[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cint32_t]] cself, cother
        cdef cset[cint32_t].iterator loc
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = (<Set__i32> self)._cpp_obj
            cother = (<Set__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__i32, (set(self), ))

    @staticmethod
    def __get_reflection__():
        return __SetSpec(value=int, kind=__NumberType.I32)



Set.register(Set__i32)

@__cython.auto_pickle(False)
cdef class Set__string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__string self):
        cdef shared_ptr[cset[string]] cpp_obj = make_shared[cset[string]](
            deref(self._cpp_obj)
        )
        return Set__string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[string]] _make_instance(object items) except *:
        cdef shared_ptr[cset[string]] c_inst = make_shared[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cset[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[string]] cself, cother
        cdef cset[string].iterator loc
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = (<Set__string> self)._cpp_obj
            cother = (<Set__string> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__string, (set(self), ))

    @staticmethod
    def __get_reflection__():
        return __SetSpec(value=str, kind=None)



Set.register(Set__string)

@__cython.auto_pickle(False)
cdef class Map__string_string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_string self):
        cdef shared_ptr[cmap[string,string]] cpp_obj = make_shared[cmap[string,string]](
            deref(self._cpp_obj)
        )
        return Map__string_string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,string]] c_inst = make_shared[cmap[string,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[key.encode('UTF-8')] = item.encode('UTF-8')
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,string].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef string citem
        cdef cmap[string,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), bytes(citem).decode('UTF-8'))
            inc(loc)

    def __reduce__(self):
        return (Map__string_string, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=str, key_kind=None, value=str, value_kind=None)


Mapping.register(Map__string_string)

@__cython.auto_pickle(False)
cdef class Map__string_SimpleStruct(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__string_SimpleStruct):
            self._cpp_obj = (<Map__string_SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_SimpleStruct._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cSimpleStruct]] c_items):
        inst = <Map__string_SimpleStruct>Map__string_SimpleStruct.__new__(Map__string_SimpleStruct)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_SimpleStruct self):
        cdef shared_ptr[cmap[string,cSimpleStruct]] cpp_obj = make_shared[cmap[string,cSimpleStruct]](
            deref(self._cpp_obj)
        )
        return Map__string_SimpleStruct.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,cSimpleStruct]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cSimpleStruct]] c_inst = make_shared[cmap[string,cSimpleStruct]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, SimpleStruct):
                    raise TypeError(f"{item!r} is not of type 'SimpleStruct'")

                deref(c_inst)[key.encode('UTF-8')] = deref((<SimpleStruct>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cSimpleStruct].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cSimpleStruct] citem = reference_shared_ptr_Map__string_SimpleStruct(self._cpp_obj, deref(iter).second)
        return SimpleStruct.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef shared_ptr[cSimpleStruct] citem
        cdef cmap[string,cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_SimpleStruct(self._cpp_obj, deref(loc).second)
            yield SimpleStruct.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[cSimpleStruct] citem
        cdef cmap[string,cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_SimpleStruct(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), SimpleStruct.create(citem))
            inc(loc)

    def __reduce__(self):
        return (Map__string_SimpleStruct, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=str, key_kind=None, value=SimpleStruct, value_kind=None)


Mapping.register(Map__string_SimpleStruct)

@__cython.auto_pickle(False)
cdef class Map__string_i16(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__string_i16):
            self._cpp_obj = (<Map__string_i16> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i16._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cint16_t]] c_items):
        inst = <Map__string_i16>Map__string_i16.__new__(Map__string_i16)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_i16 self):
        cdef shared_ptr[cmap[string,cint16_t]] cpp_obj = make_shared[cmap[string,cint16_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i16.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,cint16_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cint16_t]] c_inst = make_shared[cmap[string,cint16_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint16_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cint16_t].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cint16_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef cint16_t citem
        cdef cmap[string,cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef cint16_t citem
        cdef cmap[string,cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), citem)
            inc(loc)

    def __reduce__(self):
        return (Map__string_i16, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=str, key_kind=None, value=int, value_kind=__NumberType.I16)


Mapping.register(Map__string_i16)

@__cython.auto_pickle(False)
cdef class List__List__i32(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._cpp_obj = (<List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[cint32_t]]] c_items):
        inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__List__i32 self):
        cdef shared_ptr[vector[vector[cint32_t]]] cpp_obj = make_shared[vector[vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[cint32_t]]] c_inst = make_shared[vector[vector[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).push_back(deref((<List__i32>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[cint32_t]]] c_inst
        cdef shared_ptr[vector[cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        return std_libcpp.find[vector[vector[cint32_t]].iterator, vector[cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef vector[vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef vector[vector[cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__i32):
            raise err
        cdef vector[vector[cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[cint32_t]].iterator loc = std_libcpp.find[vector[vector[cint32_t]].iterator, vector[cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[cint32_t]].iterator, vector[cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj))

    def __reduce__(self):
        return (List__List__i32, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=List__i32, kind=None)


Sequence.register(List__List__i32)

@__cython.auto_pickle(False)
cdef class Map__string_i32(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cint32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_i32 self):
        cdef shared_ptr[cmap[string,cint32_t]] cpp_obj = make_shared[cmap[string,cint32_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cint32_t]] c_inst = make_shared[cmap[string,cint32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cint32_t].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cint32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef cint32_t citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), citem)
            inc(loc)

    def __reduce__(self):
        return (Map__string_i32, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=str, key_kind=None, value=int, value_kind=__NumberType.I32)


Mapping.register(Map__string_i32)

@__cython.auto_pickle(False)
cdef class Map__string_Map__string_i32(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cint32_t]]] c_items):
        inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] cpp_obj = make_shared[cmap[string,cmap[string,cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] c_inst = make_shared[cmap[string,cmap[string,cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cmap[string,cint32_t]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[string,cint32_t]] citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(iter).second)
        return Map__string_i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,cint32_t]] citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield Map__string_i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[cmap[string,cint32_t]] citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), Map__string_i32.create(citem))
            inc(loc)

    def __reduce__(self):
        return (Map__string_Map__string_i32, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=str, key_kind=None, value=Map__string_i32, value_kind=None)


Mapping.register(Map__string_Map__string_i32)

@__cython.auto_pickle(False)
cdef class List__Set__string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._cpp_obj = (<List__Set__string> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[string]]] c_items):
        inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Set__string self):
        cdef shared_ptr[vector[cset[string]]] cpp_obj = make_shared[vector[cset[string]]](
            deref(self._cpp_obj)
        )
        return List__Set__string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cset[string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[string]]] c_inst = make_shared[vector[cset[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[str]")
                if not isinstance(item, Set__string):
                    item = Set__string(item)
                deref(c_inst).push_back(deref((<Set__string>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[string]]] c_inst
        cdef shared_ptr[cset[string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__string.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__string.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return False
        if not isinstance(item, Set__string):
            return False
        return std_libcpp.find[vector[cset[string]].iterator, cset[string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__string):
            raise err
        cdef vector[cset[string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cset[string]].iterator loc = std_libcpp.find[vector[cset[string]].iterator, cset[string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Set__string>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return 0
        if not isinstance(item, Set__string):
            return 0
        return <cint64_t> std_libcpp.count[vector[cset[string]].iterator, cset[string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj))

    def __reduce__(self):
        return (List__Set__string, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=Set__string, kind=None)


Sequence.register(List__Set__string)

@__cython.auto_pickle(False)
cdef class Map__string_List__SimpleStruct(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__SimpleStruct):
            self._cpp_obj = (<Map__string_List__SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_List__SimpleStruct._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[cSimpleStruct]]] c_items):
        inst = <Map__string_List__SimpleStruct>Map__string_List__SimpleStruct.__new__(Map__string_List__SimpleStruct)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_List__SimpleStruct self):
        cdef shared_ptr[cmap[string,vector[cSimpleStruct]]] cpp_obj = make_shared[cmap[string,vector[cSimpleStruct]]](
            deref(self._cpp_obj)
        )
        return Map__string_List__SimpleStruct.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,vector[cSimpleStruct]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,vector[cSimpleStruct]]] c_inst = make_shared[cmap[string,vector[cSimpleStruct]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence['SimpleStruct']")
                if not isinstance(item, List__SimpleStruct):
                    item = List__SimpleStruct(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<List__SimpleStruct>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,vector[cSimpleStruct]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[vector[cSimpleStruct]] citem = reference_shared_ptr_Map__string_List__SimpleStruct(self._cpp_obj, deref(iter).second)
        return List__SimpleStruct.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,vector[cSimpleStruct]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef shared_ptr[vector[cSimpleStruct]] citem
        cdef cmap[string,vector[cSimpleStruct]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_List__SimpleStruct(self._cpp_obj, deref(loc).second)
            yield List__SimpleStruct.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[vector[cSimpleStruct]] citem
        cdef cmap[string,vector[cSimpleStruct]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_List__SimpleStruct(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), List__SimpleStruct.create(citem))
            inc(loc)

    def __reduce__(self):
        return (Map__string_List__SimpleStruct, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=str, key_kind=None, value=List__SimpleStruct, value_kind=None)


Mapping.register(Map__string_List__SimpleStruct)

@__cython.auto_pickle(False)
cdef class List__List__string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__List__string):
            self._cpp_obj = (<List__List__string> items)._cpp_obj
        else:
            self._cpp_obj = List__List__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[string]]] c_items):
        inst = <List__List__string>List__List__string.__new__(List__List__string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__List__string self):
        cdef shared_ptr[vector[vector[string]]] cpp_obj = make_shared[vector[vector[string]]](
            deref(self._cpp_obj)
        )
        return List__List__string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[vector[string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[string]]] c_inst = make_shared[vector[vector[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[str]")
                if not isinstance(item, List__string):
                    item = List__string(item)
                deref(c_inst).push_back(deref((<List__string>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[string]]] c_inst
        cdef shared_ptr[vector[string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__string.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__string(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__string.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            return False
        if not isinstance(item, List__string):
            return False
        return std_libcpp.find[vector[vector[string]].iterator, vector[string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[string]] citem
        cdef vector[vector[string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__string(self._cpp_obj, deref(loc))
            yield List__string.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[string]] citem
        cdef vector[vector[string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__string(self._cpp_obj, deref(loc))
            yield List__string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__string):
            raise err
        cdef vector[vector[string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[string]].iterator loc = std_libcpp.find[vector[vector[string]].iterator, vector[string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__string>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            return 0
        if not isinstance(item, List__string):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[string]].iterator, vector[string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__string>item)._cpp_obj))

    def __reduce__(self):
        return (List__List__string, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=List__string, kind=None)


Sequence.register(List__List__string)

@__cython.auto_pickle(False)
cdef class List__Set__i32(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[cint32_t]]] c_items):
        inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Set__i32 self):
        cdef shared_ptr[vector[cset[cint32_t]]] cpp_obj = make_shared[vector[cset[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__Set__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cset[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst = make_shared[vector[cset[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(deref((<Set__i32>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst
        cdef shared_ptr[cset[cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Set__i32):
            return False
        return std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__i32):
            raise err
        cdef vector[cset[cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cset[cint32_t]].iterator loc = std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Set__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Set__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj))

    def __reduce__(self):
        return (List__Set__i32, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=Set__i32, kind=None)


Sequence.register(List__Set__i32)

@__cython.auto_pickle(False)
cdef class List__Map__string_string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_string):
            self._cpp_obj = (<List__Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = List__Map__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cmap[string,string]]] c_items):
        inst = <List__Map__string_string>List__Map__string_string.__new__(List__Map__string_string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Map__string_string self):
        cdef shared_ptr[vector[cmap[string,string]]] cpp_obj = make_shared[vector[cmap[string,string]]](
            deref(self._cpp_obj)
        )
        return List__Map__string_string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cmap[string,string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cmap[string,string]]] c_inst = make_shared[vector[cmap[string,string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[str, str]")
                if not isinstance(item, Map__string_string):
                    item = Map__string_string(item)
                deref(c_inst).push_back(deref((<Map__string_string>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[string,string]]] c_inst
        cdef shared_ptr[cmap[string,string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[string,string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Map__string_string.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Map__string_string(self._cpp_obj, deref(self._cpp_obj)[index])
            return Map__string_string.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            return False
        if not isinstance(item, Map__string_string):
            return False
        return std_libcpp.find[vector[cmap[string,string]].iterator, cmap[string,string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__string_string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,string]] citem
        cdef vector[cmap[string,string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Map__string_string(self._cpp_obj, deref(loc))
            yield Map__string_string.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,string]] citem
        cdef vector[cmap[string,string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Map__string_string(self._cpp_obj, deref(loc))
            yield Map__string_string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__string_string):
            raise err
        cdef vector[cmap[string,string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cmap[string,string]].iterator loc = std_libcpp.find[vector[cmap[string,string]].iterator, cmap[string,string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Map__string_string>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            return 0
        if not isinstance(item, Map__string_string):
            return 0
        return <cint64_t> std_libcpp.count[vector[cmap[string,string]].iterator, cmap[string,string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__string_string>item)._cpp_obj))

    def __reduce__(self):
        return (List__Map__string_string, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=Map__string_string, kind=None)


Sequence.register(List__Map__string_string)

@__cython.auto_pickle(False)
cdef class List__binary(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__binary):
            self._cpp_obj = (<List__binary> items)._cpp_obj
        else:
            self._cpp_obj = List__binary._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__binary>List__binary.__new__(List__binary)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__binary self):
        cdef shared_ptr[vector[string]] cpp_obj = make_shared[vector[string]](
            deref(self._cpp_obj)
        )
        return List__binary.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[string]] _make_instance(object items) except *:
        cdef shared_ptr[vector[string]] c_inst = make_shared[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bytes):
                    raise TypeError(f"{item!r} is not of type bytes")
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__binary.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return bytes(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bytes):
            return False
        return std_libcpp.find[vector[string].iterator, string](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, bytes):
            raise err
        cdef vector[string].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find[vector[string].iterator, string](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, bytes):
            return 0
        return <cint64_t> std_libcpp.count[vector[string].iterator, string](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__binary, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=bytes, kind=None)


Sequence.register(List__binary)

@__cython.auto_pickle(False)
cdef class Set__binary(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Set__binary):
            self._cpp_obj = (<Set__binary> items)._cpp_obj
        else:
            self._cpp_obj = Set__binary._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__binary>Set__binary.__new__(Set__binary)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__binary self):
        cdef shared_ptr[cset[string]] cpp_obj = make_shared[cset[string]](
            deref(self._cpp_obj)
        )
        return Set__binary.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[string]] _make_instance(object items) except *:
        cdef shared_ptr[cset[string]] c_inst = make_shared[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bytes):
                    raise TypeError(f"{item!r} is not of type bytes")
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bytes):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cset[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[string]] cself, cother
        cdef cset[string].iterator loc
        if (isinstance(self, Set__binary) and
                isinstance(other, Set__binary)):
            cself = (<Set__binary> self)._cpp_obj
            cother = (<Set__binary> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__binary, (set(self), ))

    @staticmethod
    def __get_reflection__():
        return __SetSpec(value=bytes, kind=None)



Set.register(Set__binary)

@__cython.auto_pickle(False)
cdef class List__AnEnum(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__AnEnum):
            self._cpp_obj = (<List__AnEnum> items)._cpp_obj
        else:
            self._cpp_obj = List__AnEnum._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cAnEnum]] c_items):
        inst = <List__AnEnum>List__AnEnum.__new__(List__AnEnum)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__AnEnum self):
        cdef shared_ptr[vector[cAnEnum]] cpp_obj = make_shared[vector[cAnEnum]](
            deref(self._cpp_obj)
        )
        return List__AnEnum.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cAnEnum]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cAnEnum]] c_inst = make_shared[vector[cAnEnum]]()
        if items is not None:
            for item in items:
                if not isinstance(item, AnEnum):
                    raise TypeError(f"{item!r} is not of type AnEnum")
                deref(c_inst).push_back(AnEnum_to_cpp(item))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cAnEnum]] c_inst
        cdef cAnEnum citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cAnEnum]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__AnEnum.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return translate_cpp_enum_to_python(AnEnum, <int> citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, AnEnum):
            return False
        return std_libcpp.find[vector[cAnEnum].iterator, cAnEnum](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), AnEnum_to_cpp(item)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cAnEnum citem
        cdef vector[cAnEnum].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield translate_cpp_enum_to_python(AnEnum, <int> citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef cAnEnum citem
        cdef vector[cAnEnum].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield translate_cpp_enum_to_python(AnEnum, <int> citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, AnEnum):
            raise err
        cdef vector[cAnEnum].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cAnEnum].iterator loc = std_libcpp.find[vector[cAnEnum].iterator, cAnEnum](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            AnEnum_to_cpp(item)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, AnEnum):
            return 0
        return <cint64_t> std_libcpp.count[vector[cAnEnum].iterator, cAnEnum](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), AnEnum_to_cpp(item))

    def __reduce__(self):
        return (List__AnEnum, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=AnEnum, kind=None)


Sequence.register(List__AnEnum)

@__cython.auto_pickle(False)
cdef class Map__i32_double(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_double):
            self._cpp_obj = (<Map__i32_double> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint32_t,double]] c_items):
        inst = <Map__i32_double>Map__i32_double.__new__(Map__i32_double)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i32_double self):
        cdef shared_ptr[cmap[cint32_t,double]] cpp_obj = make_shared[cmap[cint32_t,double]](
            deref(self._cpp_obj)
        )
        return Map__i32_double.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,double]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,double]] c_inst = make_shared[cmap[cint32_t,double]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst)[key] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[cint32_t,double].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[cint32_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef cint32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef double citem
        cdef cmap[cint32_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef cint32_t ckey
        cdef double citem
        cdef cmap[cint32_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, citem)
            inc(loc)

    def __reduce__(self):
        return (Map__i32_double, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=int, key_kind=__NumberType.I32, value=float, value_kind=__NumberType.DOUBLE)


Mapping.register(Map__i32_double)

@__cython.auto_pickle(False)
cdef class List__Map__i32_double(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_double):
            self._cpp_obj = (<List__Map__i32_double> items)._cpp_obj
        else:
            self._cpp_obj = List__Map__i32_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cmap[cint32_t,double]]] c_items):
        inst = <List__Map__i32_double>List__Map__i32_double.__new__(List__Map__i32_double)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Map__i32_double self):
        cdef shared_ptr[vector[cmap[cint32_t,double]]] cpp_obj = make_shared[vector[cmap[cint32_t,double]]](
            deref(self._cpp_obj)
        )
        return List__Map__i32_double.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cmap[cint32_t,double]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cmap[cint32_t,double]]] c_inst = make_shared[vector[cmap[cint32_t,double]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i32_double):
                    item = Map__i32_double(item)
                deref(c_inst).push_back(deref((<Map__i32_double>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[cint32_t,double]]] c_inst
        cdef shared_ptr[cmap[cint32_t,double]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[cint32_t,double]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Map__i32_double.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Map__i32_double(self._cpp_obj, deref(self._cpp_obj)[index])
            return Map__i32_double.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            return False
        if not isinstance(item, Map__i32_double):
            return False
        return std_libcpp.find[vector[cmap[cint32_t,double]].iterator, cmap[cint32_t,double]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_double>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,double]] citem
        cdef vector[cmap[cint32_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Map__i32_double(self._cpp_obj, deref(loc))
            yield Map__i32_double.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,double]] citem
        cdef vector[cmap[cint32_t,double]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Map__i32_double(self._cpp_obj, deref(loc))
            yield Map__i32_double.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i32_double):
            raise err
        cdef vector[cmap[cint32_t,double]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cmap[cint32_t,double]].iterator loc = std_libcpp.find[vector[cmap[cint32_t,double]].iterator, cmap[cint32_t,double]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Map__i32_double>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i32_double):
            return 0
        return <cint64_t> std_libcpp.count[vector[cmap[cint32_t,double]].iterator, cmap[cint32_t,double]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_double>item)._cpp_obj))

    def __reduce__(self):
        return (List__Map__i32_double, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=Map__i32_double, kind=None)


Sequence.register(List__Map__i32_double)

A_BOOL = True
A_BYTE = 8
THE_ANSWER = 42
A_NUMBER = 84
A_BIG_NUMBER = 102
A_REAL_NUMBER = 3.14
A_FAKE_NUMBER = 3.0
A_WORD = cA_WORD().decode('UTF-8')
SOME_BYTES = <bytes> cSOME_BYTES()
A_STRUCT = SimpleStruct.create(constant_shared_ptr(cA_STRUCT()))
WORD_LIST = List__string.create(constant_shared_ptr(cWORD_LIST()))
SOME_MAP = List__Map__i32_double.create(constant_shared_ptr(cSOME_MAP()))
DIGITS = Set__i32.create(constant_shared_ptr(cDIGITS()))
A_CONST_MAP = Map__string_SimpleStruct.create(constant_shared_ptr(cA_CONST_MAP()))
IOBufPtr = __iobuf.IOBuf
IOBuf = __iobuf.IOBuf
foo_bar = bytes
