<?hh // strict
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/**
 * Original thrift enum:-
 * has_bitwise_ops
 */
enum has_bitwise_ops: int {
  none = 0;
  zero = 1;
  one = 2;
  two = 4;
  three = 8;
}

/**
 * Original thrift enum:-
 * is_unscoped
 */
enum is_unscoped: int {
  hello = 0;
  world = 1;
}

/**
 * Original thrift enum:-
 * MyForwardRefEnum
 */
enum MyForwardRefEnum: int {
  ZERO = 0;
  NONZERO = 12;
}

/**
 * Original thrift enum:-
 * MyEnumA
 */
enum MyEnumA: int {
  fieldA = 1;
  fieldB = 2;
  fieldC = 4;
}

/**
 * Original thrift struct:-
 * decorated_struct
 */
class decorated_struct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'field',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'field' => 1,
  ];
  const int STRUCTURAL_ID = 6158382972310209096;
  /**
   * Original thrift field:-
   * 1: string field
   */
  public string $field;

  <<__Rx>>
  public function __construct(?string $field = null  ) {
    if ($field === null) {
      $this->field = '';
    } else {
      $this->field = $field;
    }
  }

  public function getName(): string {
    return 'decorated_struct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.declare_equal_to' => "1",
      'cpp.declare_hash' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'field') !== null) {
      $this->field = /* HH_FIXME[4110] */ $parsed['field'];
    }    
  }

}

/**
 * Original thrift struct:-
 * ContainerStruct
 */
class ContainerStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    12 => shape(
      'var' => 'fieldA',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    2 => shape(
      'var' => 'fieldB',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'fieldC',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'fieldD',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    5 => shape(
      'var' => 'fieldE',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    6 => shape(
      'var' => 'fieldF',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    7 => shape(
      'var' => 'fieldG',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    8 => shape(
      'var' => 'fieldH',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'fieldA' => 12,
    'fieldB' => 2,
    'fieldC' => 3,
    'fieldD' => 4,
    'fieldE' => 5,
    'fieldF' => 6,
    'fieldG' => 7,
    'fieldH' => 8,
  ];
  const int STRUCTURAL_ID = 2901459969892394021;
  /**
   * Original thrift field:-
   * 12: list<i32> fieldA
   */
  public Vector<int> $fieldA;
  /**
   * Original thrift field:-
   * 2: list<i32> fieldB
   */
  public Vector<int> $fieldB;
  /**
   * Original thrift field:-
   * 3: list<i32> fieldC
   */
  public Vector<int> $fieldC;
  /**
   * Original thrift field:-
   * 4: list<i32> fieldD
   */
  public Vector<int> $fieldD;
  /**
   * Original thrift field:-
   * 5: list<i32> fieldE
   */
  public Vector<int> $fieldE;
  /**
   * Original thrift field:-
   * 6: set<i32> fieldF
   */
  public Set<int> $fieldF;
  /**
   * Original thrift field:-
   * 7: map<i32, string> fieldG
   */
  public Map<int, string> $fieldG;
  /**
   * Original thrift field:-
   * 8: map<i32, string> fieldH
   */
  public Map<int, string> $fieldH;

  <<__Rx>>
  public function __construct(?Vector<int> $fieldA = null, ?Vector<int> $fieldB = null, ?Vector<int> $fieldC = null, ?Vector<int> $fieldD = null, ?Vector<int> $fieldE = null, ?Set<int> $fieldF = null, ?Map<int, string> $fieldG = null, ?Map<int, string> $fieldH = null  ) {
    if ($fieldA === null) {
      $this->fieldA = Vector {};
    } else {
      $this->fieldA = $fieldA;
    }
    if ($fieldB === null) {
      $this->fieldB = Vector {};
    } else {
      $this->fieldB = $fieldB;
    }
    if ($fieldC === null) {
      $this->fieldC = Vector {};
    } else {
      $this->fieldC = $fieldC;
    }
    if ($fieldD === null) {
      $this->fieldD = Vector {};
    } else {
      $this->fieldD = $fieldD;
    }
    if ($fieldE === null) {
      $this->fieldE = Vector {};
    } else {
      $this->fieldE = $fieldE;
    }
    if ($fieldF === null) {
      $this->fieldF = Set {};
    } else {
      $this->fieldF = $fieldF;
    }
    if ($fieldG === null) {
      $this->fieldG = Map {};
    } else {
      $this->fieldG = $fieldG;
    }
    if ($fieldH === null) {
      $this->fieldH = Map {};
    } else {
      $this->fieldH = $fieldH;
    }
  }

  public function getName(): string {
    return 'ContainerStruct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'fieldA') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['fieldA'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->fieldA = $_container4;
    }    
    if (idx($parsed, 'fieldB') !== null) {
      $_json10 = /* HH_FIXME[4110] */ $parsed['fieldB'];
      $_container11 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json10 as $_key8 => $_value9) {
        $_elem12 = 0;
        $_tmp13 = (int)$_value9;
        if ($_tmp13 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem12 = (int)$_tmp13;
        }
        $_container11 []= $_elem12;
      }
      $this->fieldB = $_container11;
    }    
    if (idx($parsed, 'fieldC') !== null) {
      $_json17 = /* HH_FIXME[4110] */ $parsed['fieldC'];
      $_container18 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json17 as $_key15 => $_value16) {
        $_elem19 = 0;
        $_tmp20 = (int)$_value16;
        if ($_tmp20 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem19 = (int)$_tmp20;
        }
        $_container18 []= $_elem19;
      }
      $this->fieldC = $_container18;
    }    
    if (idx($parsed, 'fieldD') !== null) {
      $_json24 = /* HH_FIXME[4110] */ $parsed['fieldD'];
      $_container25 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json24 as $_key22 => $_value23) {
        $_elem26 = 0;
        $_tmp27 = (int)$_value23;
        if ($_tmp27 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem26 = (int)$_tmp27;
        }
        $_container25 []= $_elem26;
      }
      $this->fieldD = $_container25;
    }    
    if (idx($parsed, 'fieldE') !== null) {
      $_json31 = /* HH_FIXME[4110] */ $parsed['fieldE'];
      $_container32 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json31 as $_key29 => $_value30) {
        $_elem33 = 0;
        $_tmp34 = (int)$_value30;
        if ($_tmp34 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem33 = (int)$_tmp34;
        }
        $_container32 []= $_elem33;
      }
      $this->fieldE = $_container32;
    }    
    if (idx($parsed, 'fieldF') !== null) {
      $_json38 = /* HH_FIXME[4110] */ $parsed['fieldF'];
      $_container39 = Set {};
      foreach(/* HH_FIXME[4110] */ $_json38 as $_key36 => $_value37) {
        $_elem40 = 0;
        $_tmp41 = (int)$_value37;
        if ($_tmp41 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem40 = (int)$_tmp41;
        }
        $_container39->add($_elem40);
      }
      $this->fieldF = $_container39;
    }    
    if (idx($parsed, 'fieldG') !== null) {
      $_json45 = /* HH_FIXME[4110] */ $parsed['fieldG'];
      $_container46 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json45 as $_key43 => $_value44) {
        $_value47 = '';
        $_value47 = $_value44;
        $_container46[$_key43] = $_value47;
      }
      $this->fieldG = $_container46;
    }    
    if (idx($parsed, 'fieldH') !== null) {
      $_json51 = /* HH_FIXME[4110] */ $parsed['fieldH'];
      $_container52 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json51 as $_key49 => $_value50) {
        $_value53 = '';
        $_value53 = $_value50;
        $_container52[$_key49] = $_value53;
      }
      $this->fieldH = $_container52;
    }    
  }

}

/**
 * Original thrift struct:-
 * CppTypeStruct
 */
class CppTypeStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'fieldA',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'fieldA' => 1,
  ];
  const int STRUCTURAL_ID = 9369458949141941;
  /**
   * Original thrift field:-
   * 1: list<i32> fieldA
   */
  public Vector<int> $fieldA;

  <<__Rx>>
  public function __construct(?Vector<int> $fieldA = null  ) {
    if ($fieldA === null) {
      $this->fieldA = Vector {};
    } else {
      $this->fieldA = $fieldA;
    }
  }

  public function getName(): string {
    return 'CppTypeStruct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'fieldA') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['fieldA'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->fieldA = $_container4;
    }    
  }

}

/**
 * Original thrift struct:-
 * VirtualStruct
 */
class VirtualStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyIntField' => 1,
  ];
  const int STRUCTURAL_ID = 7014352813131039231;
  /**
   * Original thrift field:-
   * 1: i64 MyIntField
   */
  public int $MyIntField;

  <<__Rx>>
  public function __construct(?int $MyIntField = null  ) {
    if ($MyIntField === null) {
      $this->MyIntField = 0;
    } else {
      $this->MyIntField = $MyIntField;
    }
  }

  public function getName(): string {
    return 'VirtualStruct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.virtual' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = /* HH_FIXME[4110] */ $parsed['MyIntField'];
    }    
  }

}

/**
 * Original thrift struct:-
 * MyStructWithForwardRefEnum
 */
class MyStructWithForwardRefEnum implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::I32,
      'enum' => MyForwardRefEnum::class,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::I32,
      'enum' => MyForwardRefEnum::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];
  const int STRUCTURAL_ID = 6098225215594902198;
  /**
   * Original thrift field:-
   * 1: enum module.MyForwardRefEnum a
   */
  public ?MyForwardRefEnum $a;
  /**
   * Original thrift field:-
   * 2: enum module.MyForwardRefEnum b
   */
  public ?MyForwardRefEnum $b;

  <<__Rx>>
  public function __construct(?MyForwardRefEnum $a = null, ?MyForwardRefEnum $b = null  ) {
    if ($a === null) {
      $this->a = MyForwardRefEnum::NONZERO;
    } else {
      $this->a = $a;
    }
    if ($b === null) {
      $this->b = MyForwardRefEnum::NONZERO;
    } else {
      $this->b = $b;
    }
  }

  public function getName(): string {
    return 'MyStructWithForwardRefEnum';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $this->a = MyForwardRefEnum::coerce(/* HH_FIXME[4110] */ $parsed['a']);    }    
    if (idx($parsed, 'b') !== null) {
      $this->b = MyForwardRefEnum::coerce(/* HH_FIXME[4110] */ $parsed['b']);    }    
  }

}

/**
 * Original thrift struct:-
 * TrivialNumeric
 */
class TrivialNumeric implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::BOOL,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];
  const int STRUCTURAL_ID = 3920068475021763685;
  /**
   * Original thrift field:-
   * 1: i32 a
   */
  public int $a;
  /**
   * Original thrift field:-
   * 2: bool b
   */
  public bool $b;

  <<__Rx>>
  public function __construct(?int $a = null, ?bool $b = null  ) {
    if ($a === null) {
      $this->a = 0;
    } else {
      $this->a = $a;
    }
    if ($b === null) {
      $this->b = false;
    } else {
      $this->b = $b;
    }
  }

  public function getName(): string {
    return 'TrivialNumeric';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['a'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->a = (int)$_tmp0;
      }
    }    
    if (idx($parsed, 'b') !== null) {
      $this->b = /* HH_FIXME[4110] */ $parsed['b'];
    }    
  }

}

/**
 * Original thrift struct:-
 * TrivialNestedWithDefault
 */
class TrivialNestedWithDefault implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'z',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'n',
      'type' => \TType::STRUCT,
      'class' => TrivialNumeric::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'z' => 1,
    'n' => 2,
  ];
  const int STRUCTURAL_ID = 5012136746274172257;
  /**
   * Original thrift field:-
   * 1: i32 z
   */
  public int $z;
  /**
   * Original thrift field:-
   * 2: struct module.TrivialNumeric n
   */
  public ?TrivialNumeric $n;

  <<__Rx>>
  public function __construct(?int $z = null, ?TrivialNumeric $n = null  ) {
    if ($z === null) {
      $this->z = 4;
    } else {
      $this->z = $z;
    }
    $this->n = $n;
  }

  public function getName(): string {
    return 'TrivialNestedWithDefault';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'z') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['z'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->z = (int)$_tmp0;
      }
    }    
    if (idx($parsed, 'n') !== null) {
      $_tmp1 = json_encode(/* HH_FIXME[4110] */ $parsed['n']);
      $_tmp2 = new TrivialNumeric();
      $_tmp2->readFromJson($_tmp1);
      $this->n = $_tmp2;
    }    
  }

}

/**
 * Original thrift struct:-
 * ComplexString
 */
class ComplexString implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];
  const int STRUCTURAL_ID = 5460740530481786095;
  /**
   * Original thrift field:-
   * 1: string a
   */
  public string $a;
  /**
   * Original thrift field:-
   * 2: map<string, i32> b
   */
  public Map<string, int> $b;

  <<__Rx>>
  public function __construct(?string $a = null, ?Map<string, int> $b = null  ) {
    if ($a === null) {
      $this->a = '';
    } else {
      $this->a = $a;
    }
    if ($b === null) {
      $this->b = Map {};
    } else {
      $this->b = $b;
    }
  }

  public function getName(): string {
    return 'ComplexString';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $this->a = /* HH_FIXME[4110] */ $parsed['a'];
    }    
    if (idx($parsed, 'b') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['b'];
      $_container4 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_value5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_value5 = (int)$_tmp6;
        }
        $_container4[$_key1] = $_value5;
      }
      $this->b = $_container4;
    }    
  }

}

/**
 * Original thrift struct:-
 * ComplexNestedWithDefault
 */
class ComplexNestedWithDefault implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'z',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'n',
      'type' => \TType::STRUCT,
      'class' => ComplexString::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'z' => 1,
    'n' => 2,
  ];
  const int STRUCTURAL_ID = 2913723608362321564;
  /**
   * Original thrift field:-
   * 1: string z
   */
  public string $z;
  /**
   * Original thrift field:-
   * 2: struct module.ComplexString n
   */
  public ?ComplexString $n;

  <<__Rx>>
  public function __construct(?string $z = null, ?ComplexString $n = null  ) {
    if ($z === null) {
      $this->z = "4";
    } else {
      $this->z = $z;
    }
    $this->n = $n;
  }

  public function getName(): string {
    return 'ComplexNestedWithDefault';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'z') !== null) {
      $this->z = /* HH_FIXME[4110] */ $parsed['z'];
    }    
    if (idx($parsed, 'n') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['n']);
      $_tmp1 = new ComplexString();
      $_tmp1->readFromJson($_tmp0);
      $this->n = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * MinPadding
 */
class MinPadding implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'small',
      'type' => \TType::BYTE,
    ),
    2 => shape(
      'var' => 'big',
      'type' => \TType::I64,
    ),
    3 => shape(
      'var' => 'medium',
      'type' => \TType::I16,
    ),
    4 => shape(
      'var' => 'biggish',
      'type' => \TType::I32,
    ),
    5 => shape(
      'var' => 'tiny',
      'type' => \TType::BYTE,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'small' => 1,
    'big' => 2,
    'medium' => 3,
    'biggish' => 4,
    'tiny' => 5,
  ];
  const int STRUCTURAL_ID = 723753448680843528;
  /**
   * Original thrift field:-
   * 1: byte small
   */
  public int $small;
  /**
   * Original thrift field:-
   * 2: i64 big
   */
  public int $big;
  /**
   * Original thrift field:-
   * 3: i16 medium
   */
  public int $medium;
  /**
   * Original thrift field:-
   * 4: i32 biggish
   */
  public int $biggish;
  /**
   * Original thrift field:-
   * 5: byte tiny
   */
  public int $tiny;

  <<__Rx>>
  public function __construct(?int $small = null, ?int $big = null, ?int $medium = null, ?int $biggish = null, ?int $tiny = null  ) {
    if ($small === null) {
      $this->small = 0;
    } else {
      $this->small = $small;
    }
    if ($big === null) {
      $this->big = 0;
    } else {
      $this->big = $big;
    }
    if ($medium === null) {
      $this->medium = 0;
    } else {
      $this->medium = $medium;
    }
    if ($biggish === null) {
      $this->biggish = 0;
    } else {
      $this->biggish = $biggish;
    }
    if ($tiny === null) {
      $this->tiny = 0;
    } else {
      $this->tiny = $tiny;
    }
  }

  public function getName(): string {
    return 'MinPadding';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.minimize_padding' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'small') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['small'];
      if ($_tmp0 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->small = (int)$_tmp0;
      }
    } else {
      throw new \TProtocolException("Required field small cannot be found.");
    }    
    if (idx($parsed, 'big') !== null) {
      $this->big = /* HH_FIXME[4110] */ $parsed['big'];
    } else {
      throw new \TProtocolException("Required field big cannot be found.");
    }    
    if (idx($parsed, 'medium') !== null) {
      $_tmp1 = (int)/* HH_FIXME[4110] */ $parsed['medium'];
      if ($_tmp1 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->medium = (int)$_tmp1;
      }
    } else {
      throw new \TProtocolException("Required field medium cannot be found.");
    }    
    if (idx($parsed, 'biggish') !== null) {
      $_tmp2 = (int)/* HH_FIXME[4110] */ $parsed['biggish'];
      if ($_tmp2 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->biggish = (int)$_tmp2;
      }
    } else {
      throw new \TProtocolException("Required field biggish cannot be found.");
    }    
    if (idx($parsed, 'tiny') !== null) {
      $_tmp3 = (int)/* HH_FIXME[4110] */ $parsed['tiny'];
      if ($_tmp3 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->tiny = (int)$_tmp3;
      }
    } else {
      throw new \TProtocolException("Required field tiny cannot be found.");
    }    
  }

}

/**
 * Original thrift struct:-
 * MyStruct
 */
class MyStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
    2 => shape(
      'var' => 'MyStringField',
      'type' => \TType::STRING,
    ),
    3 => shape(
      'var' => 'majorVer',
      'type' => \TType::I64,
    ),
    4 => shape(
      'var' => 'data',
      'type' => \TType::STRUCT,
      'class' => MyDataItem::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyIntField' => 1,
    'MyStringField' => 2,
    'majorVer' => 3,
    'data' => 4,
  ];
  const int STRUCTURAL_ID = 2472338421128341558;
  /**
   * Original thrift field:-
   * 1: i64 MyIntField
   */
  public int $MyIntField;
  /**
   * Original thrift field:-
   * 2: string MyStringField
   */
  public string $MyStringField;
  /**
   * Original thrift field:-
   * 3: i64 majorVer
   */
  public int $majorVer;
  /**
   * Original thrift field:-
   * 4: struct module.MyDataItem data
   */
  public ?MyDataItem $data;

  <<__Rx>>
  public function __construct(?int $MyIntField = null, ?string $MyStringField = null, ?int $majorVer = null, ?MyDataItem $data = null  ) {
    if ($MyIntField === null) {
      $this->MyIntField = 0;
    } else {
      $this->MyIntField = $MyIntField;
    }
    if ($MyStringField === null) {
      $this->MyStringField = '';
    } else {
      $this->MyStringField = $MyStringField;
    }
    if ($majorVer === null) {
      $this->majorVer = 0;
    } else {
      $this->majorVer = $majorVer;
    }
    $this->data = $data;
  }

  public function getName(): string {
    return 'MyStruct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp2.noncomparable' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = /* HH_FIXME[4110] */ $parsed['MyIntField'];
    }    
    if (idx($parsed, 'MyStringField') !== null) {
      $this->MyStringField = /* HH_FIXME[4110] */ $parsed['MyStringField'];
    }    
    if (idx($parsed, 'majorVer') !== null) {
      $this->majorVer = /* HH_FIXME[4110] */ $parsed['majorVer'];
    }    
    if (idx($parsed, 'data') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['data']);
      $_tmp1 = new MyDataItem();
      $_tmp1->readFromJson($_tmp0);
      $this->data = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * MyDataItem
 */
class MyDataItem implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];
  const int STRUCTURAL_ID = 957977401221134810;

  <<__Rx>>
  public function __construct(  ) {
  }

  public function getName(): string {
    return 'MyDataItem';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp2.noncomparable' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * Renaming
 */
class Renaming implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];
  const int STRUCTURAL_ID = 2811793053530639830;
  /**
   * Original thrift field:-
   * 1: i64 foo
   */
  public int $foo;

  <<__Rx>>
  public function __construct(?int $foo = null  ) {
    if ($foo === null) {
      $this->foo = 0;
    } else {
      $this->foo = $foo;
    }
  }

  public function getName(): string {
    return 'Renaming';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $this->foo = /* HH_FIXME[4110] */ $parsed['foo'];
    }    
  }

}

/**
 * Original thrift struct:-
 * AnnotatedTypes
 */
class AnnotatedTypes implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'binary_field',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'list_field',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::I32,
        'vtype' => \TType::STRING,
        'key' => shape(
          'type' => \TType::I32,
        ),
        'val' => shape(
          'type' => \TType::STRING,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'binary_field' => 1,
    'list_field' => 2,
  ];
  const int STRUCTURAL_ID = 7799859984459418183;
  /**
   * Original thrift field:-
   * 1: binary binary_field
   */
  public string $binary_field;
  /**
   * Original thrift field:-
   * 2: list<map<i32, string>> list_field
   */
  public Vector<Map<int, string>> $list_field;

  <<__Rx>>
  public function __construct(?string $binary_field = null, ?Vector<Map<int, string>> $list_field = null  ) {
    if ($binary_field === null) {
      $this->binary_field = '';
    } else {
      $this->binary_field = $binary_field;
    }
    if ($list_field === null) {
      $this->list_field = Vector {};
    } else {
      $this->list_field = $list_field;
    }
  }

  public function getName(): string {
    return 'AnnotatedTypes';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'binary_field') !== null) {
      $this->binary_field = /* HH_FIXME[4110] */ $parsed['binary_field'];
    }    
    if (idx($parsed, 'list_field') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['list_field'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = Map {};
        $_json9 = $_value2;
        $_container10 = Map {};
        foreach(/* HH_FIXME[4110] */ $_json9 as $_key7 => $_value8) {
          $_value11 = '';
          $_value11 = $_value8;
          $_container10[$_key7] = $_value11;
        }
        $_elem5 = $_container10;
        $_container4 []= $_elem5;
      }
      $this->list_field = $_container4;
    }    
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageRoot
 */
class ForwardUsageRoot implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'ForwardUsageStruct',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageStruct::class,
    ),
    2 => shape(
      'var' => 'ForwardUsageByRef',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageByRef::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'ForwardUsageStruct' => 1,
    'ForwardUsageByRef' => 2,
  ];
  const int STRUCTURAL_ID = 839155360071855827;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageStruct ForwardUsageStruct
   */
  public ?ForwardUsageStruct $ForwardUsageStruct;
  /**
   * Original thrift field:-
   * 2: struct module.ForwardUsageByRef ForwardUsageByRef
   */
  public ?ForwardUsageByRef $ForwardUsageByRef;

  <<__Rx>>
  public function __construct(?ForwardUsageStruct $ForwardUsageStruct = null, ?ForwardUsageByRef $ForwardUsageByRef = null  ) {
    $this->ForwardUsageStruct = $ForwardUsageStruct;
    $this->ForwardUsageByRef = $ForwardUsageByRef;
  }

  public function getName(): string {
    return 'ForwardUsageRoot';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'ForwardUsageStruct') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['ForwardUsageStruct']);
      $_tmp1 = new ForwardUsageStruct();
      $_tmp1->readFromJson($_tmp0);
      $this->ForwardUsageStruct = $_tmp1;
    }    
    if (idx($parsed, 'ForwardUsageByRef') !== null) {
      $_tmp2 = json_encode(/* HH_FIXME[4110] */ $parsed['ForwardUsageByRef']);
      $_tmp3 = new ForwardUsageByRef();
      $_tmp3->readFromJson($_tmp2);
      $this->ForwardUsageByRef = $_tmp3;
    }    
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageStruct
 */
class ForwardUsageStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageRoot::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];
  const int STRUCTURAL_ID = 7148256645166217470;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageRoot foo
   */
  public ?ForwardUsageRoot $foo;

  <<__Rx>>
  public function __construct(?ForwardUsageRoot $foo = null  ) {
    $this->foo = $foo;
  }

  public function getName(): string {
    return 'ForwardUsageStruct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['foo']);
      $_tmp1 = new ForwardUsageRoot();
      $_tmp1->readFromJson($_tmp0);
      $this->foo = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageByRef
 */
class ForwardUsageByRef implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageRoot::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];
  const int STRUCTURAL_ID = 7148256645166217470;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageRoot foo
   */
  public ?ForwardUsageRoot $foo;

  <<__Rx>>
  public function __construct(?ForwardUsageRoot $foo = null  ) {
    $this->foo = $foo;
  }

  public function getName(): string {
    return 'ForwardUsageByRef';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['foo']);
      $_tmp1 = new ForwardUsageRoot();
      $_tmp1->readFromJson($_tmp0);
      $this->foo = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveEmpty
 */
class NoexceptMoveEmpty implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];
  const int STRUCTURAL_ID = 957977401221134810;

  <<__Rx>>
  public function __construct(  ) {
  }

  public function getName(): string {
    return 'NoexceptMoveEmpty';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveSimpleStruct
 */
class NoexceptMoveSimpleStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'boolField',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'boolField' => 1,
  ];
  const int STRUCTURAL_ID = 7058232826271171943;
  /**
   * Original thrift field:-
   * 1: i64 boolField
   */
  public int $boolField;

  <<__Rx>>
  public function __construct(?int $boolField = null  ) {
    if ($boolField === null) {
      $this->boolField = 0;
    } else {
      $this->boolField = $boolField;
    }
  }

  public function getName(): string {
    return 'NoexceptMoveSimpleStruct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'boolField') !== null) {
      $this->boolField = /* HH_FIXME[4110] */ $parsed['boolField'];
    }    
  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveComplexStruct
 */
class NoexceptMoveComplexStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyBoolField',
      'type' => \TType::BOOL,
    ),
    2 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
    3 => shape(
      'var' => 'MyStringField',
      'type' => \TType::STRING,
    ),
    4 => shape(
      'var' => 'MyStringField2',
      'type' => \TType::STRING,
    ),
    5 => shape(
      'var' => 'MyBinaryField',
      'type' => \TType::STRING,
    ),
    6 => shape(
      'var' => 'MyBinaryField2',
      'type' => \TType::STRING,
    ),
    7 => shape(
      'var' => 'MyBinaryField3',
      'type' => \TType::STRING,
    ),
    8 => shape(
      'var' => 'MyBinaryListField4',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    9 => shape(
      'var' => 'MyMapEnumAndInt',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
        'enum' => MyEnumA::class,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyBoolField' => 1,
    'MyIntField' => 2,
    'MyStringField' => 3,
    'MyStringField2' => 4,
    'MyBinaryField' => 5,
    'MyBinaryField2' => 6,
    'MyBinaryField3' => 7,
    'MyBinaryListField4' => 8,
    'MyMapEnumAndInt' => 9,
  ];
  const int STRUCTURAL_ID = 8958221528844030164;
  /**
   * Original thrift field:-
   * 1: bool MyBoolField
   */
  public bool $MyBoolField;
  /**
   * Original thrift field:-
   * 2: i64 MyIntField
   */
  public int $MyIntField;
  /**
   * Original thrift field:-
   * 3: string MyStringField
   */
  public string $MyStringField;
  /**
   * Original thrift field:-
   * 4: string MyStringField2
   */
  public string $MyStringField2;
  /**
   * Original thrift field:-
   * 5: binary MyBinaryField
   */
  public string $MyBinaryField;
  /**
   * Original thrift field:-
   * 6: binary MyBinaryField2
   */
  public ?string $MyBinaryField2;
  /**
   * Original thrift field:-
   * 7: binary MyBinaryField3
   */
  public string $MyBinaryField3;
  /**
   * Original thrift field:-
   * 8: list<binary> MyBinaryListField4
   */
  public Vector<string> $MyBinaryListField4;
  /**
   * Original thrift field:-
   * 9: map<enum module.MyEnumA, string> MyMapEnumAndInt
   */
  public Map<MyEnumA, string> $MyMapEnumAndInt;

  <<__Rx>>
  public function __construct(?bool $MyBoolField = null, ?int $MyIntField = null, ?string $MyStringField = null, ?string $MyStringField2 = null, ?string $MyBinaryField = null, ?string $MyBinaryField2 = null, ?string $MyBinaryField3 = null, ?Vector<string> $MyBinaryListField4 = null, ?Map<MyEnumA, string> $MyMapEnumAndInt = null  ) {
    if ($MyBoolField === null) {
      $this->MyBoolField = false;
    } else {
      $this->MyBoolField = $MyBoolField;
    }
    if ($MyIntField === null) {
      $this->MyIntField = 12;
    } else {
      $this->MyIntField = $MyIntField;
    }
    if ($MyStringField === null) {
      $this->MyStringField = "test";
    } else {
      $this->MyStringField = $MyStringField;
    }
    if ($MyStringField2 === null) {
      $this->MyStringField2 = '';
    } else {
      $this->MyStringField2 = $MyStringField2;
    }
    if ($MyBinaryField === null) {
      $this->MyBinaryField = '';
    } else {
      $this->MyBinaryField = $MyBinaryField;
    }
    $this->MyBinaryField2 = $MyBinaryField2;
    if ($MyBinaryField3 === null) {
      $this->MyBinaryField3 = '';
    } else {
      $this->MyBinaryField3 = $MyBinaryField3;
    }
    if ($MyBinaryListField4 === null) {
      $this->MyBinaryListField4 = Vector {};
    } else {
      $this->MyBinaryListField4 = $MyBinaryListField4;
    }
    if ($MyMapEnumAndInt === null) {
      $this->MyMapEnumAndInt = Map {
      MyEnumA::fieldA => "fieldA",
      MyEnumA::fieldC => "fieldC",
    };
    } else {
      $this->MyMapEnumAndInt = $MyMapEnumAndInt;
    }
  }

  public function getName(): string {
    return 'NoexceptMoveComplexStruct';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyBoolField') !== null) {
      $this->MyBoolField = /* HH_FIXME[4110] */ $parsed['MyBoolField'];
    }    
    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = /* HH_FIXME[4110] */ $parsed['MyIntField'];
    }    
    if (idx($parsed, 'MyStringField') !== null) {
      $this->MyStringField = /* HH_FIXME[4110] */ $parsed['MyStringField'];
    }    
    if (idx($parsed, 'MyStringField2') !== null) {
      $this->MyStringField2 = /* HH_FIXME[4110] */ $parsed['MyStringField2'];
    }    
    if (idx($parsed, 'MyBinaryField') !== null) {
      $this->MyBinaryField = /* HH_FIXME[4110] */ $parsed['MyBinaryField'];
    }    
    if (idx($parsed, 'MyBinaryField2') !== null) {
      $this->MyBinaryField2 = /* HH_FIXME[4110] */ $parsed['MyBinaryField2'];
    }    
    if (idx($parsed, 'MyBinaryField3') !== null) {
      $this->MyBinaryField3 = /* HH_FIXME[4110] */ $parsed['MyBinaryField3'];
    } else {
      throw new \TProtocolException("Required field MyBinaryField3 cannot be found.");
    }    
    if (idx($parsed, 'MyBinaryListField4') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['MyBinaryListField4'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = '';
        $_elem5 = $_value2;
        $_container4 []= $_elem5;
      }
      $this->MyBinaryListField4 = $_container4;
    }    
    if (idx($parsed, 'MyMapEnumAndInt') !== null) {
      $_json9 = /* HH_FIXME[4110] */ $parsed['MyMapEnumAndInt'];
      $_container10 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json9 as $_key7 => $_value8) {
        $_value11 = '';
        $_value11 = $_value8;
        $_container10[$_key7] = $_value11;
      }
      $this->MyMapEnumAndInt = $_container10;
    }    
  }

}

enum NoExceptMoveUnionEnum: int {
  _EMPTY_ = 0;
  string_field = 1;
  i32_field = 2;
}

/**
 * Original thrift struct:-
 * NoExceptMoveUnion
 */
class NoExceptMoveUnion implements \IThriftStruct, \IThriftUnion<NoExceptMoveUnionEnum> {
  use \ThriftUnionSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'string_field',
      'union' => true,
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'i32_field',
      'union' => true,
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'string_field' => 1,
    'i32_field' => 2,
  ];
  const int STRUCTURAL_ID = 5659539827624892912;
  /**
   * Original thrift field:-
   * 1: string string_field
   */
  public ?string $string_field;
  /**
   * Original thrift field:-
   * 2: i32 i32_field
   */
  public ?int $i32_field;
  protected NoExceptMoveUnionEnum $_type = NoExceptMoveUnionEnum::_EMPTY_;

  <<__Rx>>
  public function __construct(?string $string_field = null, ?int $i32_field = null  ) {
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
    if ($string_field !== null) {
      $this->string_field = $string_field;
      $this->_type = NoExceptMoveUnionEnum::string_field;
    }
    if ($i32_field !== null) {
      $this->i32_field = $i32_field;
      $this->_type = NoExceptMoveUnionEnum::i32_field;
    }
  }

  public function getName(): string {
    return 'NoExceptMoveUnion';
  }

  public function getType(): NoExceptMoveUnionEnum {
    return $this->_type;
  }

  public function set_string_field(string $string_field): this {
    $this->_type = NoExceptMoveUnionEnum::string_field;
    $this->string_field = $string_field;
    return $this;
  }

  public function get_string_field(): string {
    invariant(
      $this->_type === NoExceptMoveUnionEnum::string_field,
      'get_string_field called on an instance of NoExceptMoveUnion whose current type is %s',
      (string)$this->_type,
    );
    return \nullthrows($this->string_field);
  }

  public function set_i32_field(int $i32_field): this {
    $this->_type = NoExceptMoveUnionEnum::i32_field;
    $this->i32_field = $i32_field;
    return $this;
  }

  public function get_i32_field(): int {
    invariant(
      $this->_type === NoExceptMoveUnionEnum::i32_field,
      'get_i32_field called on an instance of NoExceptMoveUnion whose current type is %s',
      (string)$this->_type,
    );
    return \nullthrows($this->i32_field);
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }
  public function readFromJson(string $jsonText): void {
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !is_array($parsed)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'string_field') !== null) {
      $this->string_field = /* HH_FIXME[4110] */ $parsed['string_field'];
      $this->_type = NoExceptMoveUnionEnum::string_field;
    }    
    if (idx($parsed, 'i32_field') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['i32_field'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->i32_field = (int)$_tmp0;
      }
      $this->_type = NoExceptMoveUnionEnum::i32_field;
    }    
  }

}

