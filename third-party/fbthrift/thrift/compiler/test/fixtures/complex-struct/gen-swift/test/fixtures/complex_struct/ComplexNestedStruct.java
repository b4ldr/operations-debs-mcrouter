/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

package test.fixtures.complex_struct;

import com.facebook.swift.codec.*;
import com.facebook.swift.codec.ThriftField.Requiredness;
import com.facebook.swift.codec.ThriftField.Recursiveness;
import com.google.common.collect.*;
import java.util.*;
import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.server.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;
import org.apache.thrift.meta_data.FieldMetaData;
import org.apache.thrift.meta_data.FieldValueMetaData;
import static com.google.common.base.MoreObjects.toStringHelper;
import static com.google.common.base.MoreObjects.ToStringHelper;

@SwiftGenerated
@ThriftStruct(value="ComplexNestedStruct", builder=ComplexNestedStruct.Builder.class)
public final class ComplexNestedStruct {
    @ThriftConstructor
    public ComplexNestedStruct(
        @ThriftField(value=1, name="setOfSetOfInt", requiredness=Requiredness.NONE) final Set<Set<Integer>> setOfSetOfInt,
        @ThriftField(value=2, name="listofListOfListOfListOfEnum", requiredness=Requiredness.NONE) final List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> listofListOfListOfListOfEnum,
        @ThriftField(value=3, name="listOfListOfMyStruct", requiredness=Requiredness.NONE) final List<List<test.fixtures.complex_struct.MyStruct>> listOfListOfMyStruct,
        @ThriftField(value=4, name="setOfListOfListOfLong", requiredness=Requiredness.NONE) final Set<List<List<Long>>> setOfListOfListOfLong,
        @ThriftField(value=5, name="setOfSetOfsetOfLong", requiredness=Requiredness.NONE) final Set<Set<Set<Long>>> setOfSetOfsetOfLong,
        @ThriftField(value=6, name="mapStructListOfListOfLong", requiredness=Requiredness.NONE) final Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> mapStructListOfListOfLong,
        @ThriftField(value=7, name="mKeyStructValInt", requiredness=Requiredness.NONE) final Map<test.fixtures.complex_struct.MyStruct, Integer> mKeyStructValInt,
        @ThriftField(value=8, name="listOfMapKeyIntValInt", requiredness=Requiredness.NONE) final List<Map<Integer, Integer>> listOfMapKeyIntValInt,
        @ThriftField(value=9, name="listOfMapKeyStrValList", requiredness=Requiredness.NONE) final List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> listOfMapKeyStrValList,
        @ThriftField(value=10, name="mapKeySetValLong", requiredness=Requiredness.NONE) final Map<Set<Integer>, Long> mapKeySetValLong,
        @ThriftField(value=11, name="mapKeyListValLong", requiredness=Requiredness.NONE) final Map<List<String>, Integer> mapKeyListValLong,
        @ThriftField(value=12, name="mapKeyMapValMap", requiredness=Requiredness.NONE) final Map<Map<Integer, String>, Map<Integer, String>> mapKeyMapValMap,
        @ThriftField(value=13, name="mapKeySetValMap", requiredness=Requiredness.NONE) final Map<Set<List<Integer>>, Map<List<Set<String>>, String>> mapKeySetValMap,
        @ThriftField(value=14, name="NestedMaps", requiredness=Requiredness.NONE) final Map<Map<Map<Integer, String>, String>, Map<Integer, String>> nestedMaps,
        @ThriftField(value=15, name="mapKeyIntValList", requiredness=Requiredness.NONE) final Map<Integer, List<test.fixtures.complex_struct.MyStruct>> mapKeyIntValList,
        @ThriftField(value=16, name="mapKeyIntValSet", requiredness=Requiredness.NONE) final Map<Integer, Set<Boolean>> mapKeyIntValSet,
        @ThriftField(value=17, name="mapKeySetValInt", requiredness=Requiredness.NONE) final Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> mapKeySetValInt,
        @ThriftField(value=18, name="mapKeyListValSet", requiredness=Requiredness.NONE) final Map<List<Integer>, Set<Map<Double, String>>> mapKeyListValSet
    ) {
        this.setOfSetOfInt = setOfSetOfInt;
        this.listofListOfListOfListOfEnum = listofListOfListOfListOfEnum;
        this.listOfListOfMyStruct = listOfListOfMyStruct;
        this.setOfListOfListOfLong = setOfListOfListOfLong;
        this.setOfSetOfsetOfLong = setOfSetOfsetOfLong;
        this.mapStructListOfListOfLong = mapStructListOfListOfLong;
        this.mKeyStructValInt = mKeyStructValInt;
        this.listOfMapKeyIntValInt = listOfMapKeyIntValInt;
        this.listOfMapKeyStrValList = listOfMapKeyStrValList;
        this.mapKeySetValLong = mapKeySetValLong;
        this.mapKeyListValLong = mapKeyListValLong;
        this.mapKeyMapValMap = mapKeyMapValMap;
        this.mapKeySetValMap = mapKeySetValMap;
        this.nestedMaps = nestedMaps;
        this.mapKeyIntValList = mapKeyIntValList;
        this.mapKeyIntValSet = mapKeyIntValSet;
        this.mapKeySetValInt = mapKeySetValInt;
        this.mapKeyListValSet = mapKeyListValSet;
    }
    
    @ThriftConstructor
    protected ComplexNestedStruct() {
      this.setOfSetOfInt = null;
      this.listofListOfListOfListOfEnum = null;
      this.listOfListOfMyStruct = null;
      this.setOfListOfListOfLong = null;
      this.setOfSetOfsetOfLong = null;
      this.mapStructListOfListOfLong = null;
      this.mKeyStructValInt = null;
      this.listOfMapKeyIntValInt = null;
      this.listOfMapKeyStrValList = null;
      this.mapKeySetValLong = null;
      this.mapKeyListValLong = null;
      this.mapKeyMapValMap = null;
      this.mapKeySetValMap = null;
      this.nestedMaps = null;
      this.mapKeyIntValList = null;
      this.mapKeyIntValSet = null;
      this.mapKeySetValInt = null;
      this.mapKeyListValSet = null;
    }
    
    public static class Builder {
        private Set<Set<Integer>> setOfSetOfInt = null;
        private List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> listofListOfListOfListOfEnum = null;
        private List<List<test.fixtures.complex_struct.MyStruct>> listOfListOfMyStruct = null;
        private Set<List<List<Long>>> setOfListOfListOfLong = null;
        private Set<Set<Set<Long>>> setOfSetOfsetOfLong = null;
        private Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> mapStructListOfListOfLong = null;
        private Map<test.fixtures.complex_struct.MyStruct, Integer> mKeyStructValInt = null;
        private List<Map<Integer, Integer>> listOfMapKeyIntValInt = null;
        private List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> listOfMapKeyStrValList = null;
        private Map<Set<Integer>, Long> mapKeySetValLong = null;
        private Map<List<String>, Integer> mapKeyListValLong = null;
        private Map<Map<Integer, String>, Map<Integer, String>> mapKeyMapValMap = null;
        private Map<Set<List<Integer>>, Map<List<Set<String>>, String>> mapKeySetValMap = null;
        private Map<Map<Map<Integer, String>, String>, Map<Integer, String>> nestedMaps = null;
        private Map<Integer, List<test.fixtures.complex_struct.MyStruct>> mapKeyIntValList = null;
        private Map<Integer, Set<Boolean>> mapKeyIntValSet = null;
        private Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> mapKeySetValInt = null;
        private Map<List<Integer>, Set<Map<Double, String>>> mapKeyListValSet = null;
    
        @ThriftField(value=1, name="setOfSetOfInt", requiredness=Requiredness.NONE)
        public Builder setSetOfSetOfInt(Set<Set<Integer>> setOfSetOfInt) {
            this.setOfSetOfInt = setOfSetOfInt;
            return this;
        }
        
        public Set<Set<Integer>> getSetOfSetOfInt() { return setOfSetOfInt; }
    
            @ThriftField(value=2, name="listofListOfListOfListOfEnum", requiredness=Requiredness.NONE)
        public Builder setListofListOfListOfListOfEnum(List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> listofListOfListOfListOfEnum) {
            this.listofListOfListOfListOfEnum = listofListOfListOfListOfEnum;
            return this;
        }
        
        public List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> getListofListOfListOfListOfEnum() { return listofListOfListOfListOfEnum; }
    
            @ThriftField(value=3, name="listOfListOfMyStruct", requiredness=Requiredness.NONE)
        public Builder setListOfListOfMyStruct(List<List<test.fixtures.complex_struct.MyStruct>> listOfListOfMyStruct) {
            this.listOfListOfMyStruct = listOfListOfMyStruct;
            return this;
        }
        
        public List<List<test.fixtures.complex_struct.MyStruct>> getListOfListOfMyStruct() { return listOfListOfMyStruct; }
    
            @ThriftField(value=4, name="setOfListOfListOfLong", requiredness=Requiredness.NONE)
        public Builder setSetOfListOfListOfLong(Set<List<List<Long>>> setOfListOfListOfLong) {
            this.setOfListOfListOfLong = setOfListOfListOfLong;
            return this;
        }
        
        public Set<List<List<Long>>> getSetOfListOfListOfLong() { return setOfListOfListOfLong; }
    
            @ThriftField(value=5, name="setOfSetOfsetOfLong", requiredness=Requiredness.NONE)
        public Builder setSetOfSetOfsetOfLong(Set<Set<Set<Long>>> setOfSetOfsetOfLong) {
            this.setOfSetOfsetOfLong = setOfSetOfsetOfLong;
            return this;
        }
        
        public Set<Set<Set<Long>>> getSetOfSetOfsetOfLong() { return setOfSetOfsetOfLong; }
    
            @ThriftField(value=6, name="mapStructListOfListOfLong", requiredness=Requiredness.NONE)
        public Builder setMapStructListOfListOfLong(Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> mapStructListOfListOfLong) {
            this.mapStructListOfListOfLong = mapStructListOfListOfLong;
            return this;
        }
        
        public Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> getMapStructListOfListOfLong() { return mapStructListOfListOfLong; }
    
            @ThriftField(value=7, name="mKeyStructValInt", requiredness=Requiredness.NONE)
        public Builder setMKeyStructValInt(Map<test.fixtures.complex_struct.MyStruct, Integer> mKeyStructValInt) {
            this.mKeyStructValInt = mKeyStructValInt;
            return this;
        }
        
        public Map<test.fixtures.complex_struct.MyStruct, Integer> getMKeyStructValInt() { return mKeyStructValInt; }
    
            @ThriftField(value=8, name="listOfMapKeyIntValInt", requiredness=Requiredness.NONE)
        public Builder setListOfMapKeyIntValInt(List<Map<Integer, Integer>> listOfMapKeyIntValInt) {
            this.listOfMapKeyIntValInt = listOfMapKeyIntValInt;
            return this;
        }
        
        public List<Map<Integer, Integer>> getListOfMapKeyIntValInt() { return listOfMapKeyIntValInt; }
    
            @ThriftField(value=9, name="listOfMapKeyStrValList", requiredness=Requiredness.NONE)
        public Builder setListOfMapKeyStrValList(List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> listOfMapKeyStrValList) {
            this.listOfMapKeyStrValList = listOfMapKeyStrValList;
            return this;
        }
        
        public List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> getListOfMapKeyStrValList() { return listOfMapKeyStrValList; }
    
            @ThriftField(value=10, name="mapKeySetValLong", requiredness=Requiredness.NONE)
        public Builder setMapKeySetValLong(Map<Set<Integer>, Long> mapKeySetValLong) {
            this.mapKeySetValLong = mapKeySetValLong;
            return this;
        }
        
        public Map<Set<Integer>, Long> getMapKeySetValLong() { return mapKeySetValLong; }
    
            @ThriftField(value=11, name="mapKeyListValLong", requiredness=Requiredness.NONE)
        public Builder setMapKeyListValLong(Map<List<String>, Integer> mapKeyListValLong) {
            this.mapKeyListValLong = mapKeyListValLong;
            return this;
        }
        
        public Map<List<String>, Integer> getMapKeyListValLong() { return mapKeyListValLong; }
    
            @ThriftField(value=12, name="mapKeyMapValMap", requiredness=Requiredness.NONE)
        public Builder setMapKeyMapValMap(Map<Map<Integer, String>, Map<Integer, String>> mapKeyMapValMap) {
            this.mapKeyMapValMap = mapKeyMapValMap;
            return this;
        }
        
        public Map<Map<Integer, String>, Map<Integer, String>> getMapKeyMapValMap() { return mapKeyMapValMap; }
    
            @ThriftField(value=13, name="mapKeySetValMap", requiredness=Requiredness.NONE)
        public Builder setMapKeySetValMap(Map<Set<List<Integer>>, Map<List<Set<String>>, String>> mapKeySetValMap) {
            this.mapKeySetValMap = mapKeySetValMap;
            return this;
        }
        
        public Map<Set<List<Integer>>, Map<List<Set<String>>, String>> getMapKeySetValMap() { return mapKeySetValMap; }
    
            @ThriftField(value=14, name="NestedMaps", requiredness=Requiredness.NONE)
        public Builder setNestedMaps(Map<Map<Map<Integer, String>, String>, Map<Integer, String>> nestedMaps) {
            this.nestedMaps = nestedMaps;
            return this;
        }
        
        public Map<Map<Map<Integer, String>, String>, Map<Integer, String>> getNestedMaps() { return nestedMaps; }
    
            @ThriftField(value=15, name="mapKeyIntValList", requiredness=Requiredness.NONE)
        public Builder setMapKeyIntValList(Map<Integer, List<test.fixtures.complex_struct.MyStruct>> mapKeyIntValList) {
            this.mapKeyIntValList = mapKeyIntValList;
            return this;
        }
        
        public Map<Integer, List<test.fixtures.complex_struct.MyStruct>> getMapKeyIntValList() { return mapKeyIntValList; }
    
            @ThriftField(value=16, name="mapKeyIntValSet", requiredness=Requiredness.NONE)
        public Builder setMapKeyIntValSet(Map<Integer, Set<Boolean>> mapKeyIntValSet) {
            this.mapKeyIntValSet = mapKeyIntValSet;
            return this;
        }
        
        public Map<Integer, Set<Boolean>> getMapKeyIntValSet() { return mapKeyIntValSet; }
    
            @ThriftField(value=17, name="mapKeySetValInt", requiredness=Requiredness.NONE)
        public Builder setMapKeySetValInt(Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> mapKeySetValInt) {
            this.mapKeySetValInt = mapKeySetValInt;
            return this;
        }
        
        public Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> getMapKeySetValInt() { return mapKeySetValInt; }
    
            @ThriftField(value=18, name="mapKeyListValSet", requiredness=Requiredness.NONE)
        public Builder setMapKeyListValSet(Map<List<Integer>, Set<Map<Double, String>>> mapKeyListValSet) {
            this.mapKeyListValSet = mapKeyListValSet;
            return this;
        }
        
        public Map<List<Integer>, Set<Map<Double, String>>> getMapKeyListValSet() { return mapKeyListValSet; }
    
        public Builder() { }
        public Builder(ComplexNestedStruct other) {
            this.setOfSetOfInt = other.setOfSetOfInt;
            this.listofListOfListOfListOfEnum = other.listofListOfListOfListOfEnum;
            this.listOfListOfMyStruct = other.listOfListOfMyStruct;
            this.setOfListOfListOfLong = other.setOfListOfListOfLong;
            this.setOfSetOfsetOfLong = other.setOfSetOfsetOfLong;
            this.mapStructListOfListOfLong = other.mapStructListOfListOfLong;
            this.mKeyStructValInt = other.mKeyStructValInt;
            this.listOfMapKeyIntValInt = other.listOfMapKeyIntValInt;
            this.listOfMapKeyStrValList = other.listOfMapKeyStrValList;
            this.mapKeySetValLong = other.mapKeySetValLong;
            this.mapKeyListValLong = other.mapKeyListValLong;
            this.mapKeyMapValMap = other.mapKeyMapValMap;
            this.mapKeySetValMap = other.mapKeySetValMap;
            this.nestedMaps = other.nestedMaps;
            this.mapKeyIntValList = other.mapKeyIntValList;
            this.mapKeyIntValSet = other.mapKeyIntValSet;
            this.mapKeySetValInt = other.mapKeySetValInt;
            this.mapKeyListValSet = other.mapKeyListValSet;
        }
    
        @ThriftConstructor
        public ComplexNestedStruct build() {
            return new ComplexNestedStruct (
                this.setOfSetOfInt,
                this.listofListOfListOfListOfEnum,
                this.listOfListOfMyStruct,
                this.setOfListOfListOfLong,
                this.setOfSetOfsetOfLong,
                this.mapStructListOfListOfLong,
                this.mKeyStructValInt,
                this.listOfMapKeyIntValInt,
                this.listOfMapKeyStrValList,
                this.mapKeySetValLong,
                this.mapKeyListValLong,
                this.mapKeyMapValMap,
                this.mapKeySetValMap,
                this.nestedMaps,
                this.mapKeyIntValList,
                this.mapKeyIntValSet,
                this.mapKeySetValInt,
                this.mapKeyListValSet
            );
        }
    }
    
    private static final TStruct STRUCT_DESC = new TStruct("ComplexNestedStruct");
    private final Set<Set<Integer>> setOfSetOfInt;
    public static final int _SETOFSETOFINT = 1;
    private static final TField SET_OF_SET_OF_INT_FIELD_DESC = new TField("setOfSetOfInt", TType.SET, (short)1);
    private final List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> listofListOfListOfListOfEnum;
    public static final int _LISTOFLISTOFLISTOFLISTOFENUM = 2;
    private static final TField LISTOF_LIST_OF_LIST_OF_LIST_OF_ENUM_FIELD_DESC = new TField("listofListOfListOfListOfEnum", TType.LIST, (short)2);
    private final List<List<test.fixtures.complex_struct.MyStruct>> listOfListOfMyStruct;
    public static final int _LISTOFLISTOFMYSTRUCT = 3;
    private static final TField LIST_OF_LIST_OF_MY_STRUCT_FIELD_DESC = new TField("listOfListOfMyStruct", TType.LIST, (short)3);
    private final Set<List<List<Long>>> setOfListOfListOfLong;
    public static final int _SETOFLISTOFLISTOFLONG = 4;
    private static final TField SET_OF_LIST_OF_LIST_OF_LONG_FIELD_DESC = new TField("setOfListOfListOfLong", TType.SET, (short)4);
    private final Set<Set<Set<Long>>> setOfSetOfsetOfLong;
    public static final int _SETOFSETOFSETOFLONG = 5;
    private static final TField SET_OF_SET_OFSET_OF_LONG_FIELD_DESC = new TField("setOfSetOfsetOfLong", TType.SET, (short)5);
    private final Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> mapStructListOfListOfLong;
    public static final int _MAPSTRUCTLISTOFLISTOFLONG = 6;
    private static final TField MAP_STRUCT_LIST_OF_LIST_OF_LONG_FIELD_DESC = new TField("mapStructListOfListOfLong", TType.MAP, (short)6);
    private final Map<test.fixtures.complex_struct.MyStruct, Integer> mKeyStructValInt;
    public static final int _MKEYSTRUCTVALINT = 7;
    private static final TField M_KEY_STRUCT_VAL_INT_FIELD_DESC = new TField("mKeyStructValInt", TType.MAP, (short)7);
    private final List<Map<Integer, Integer>> listOfMapKeyIntValInt;
    public static final int _LISTOFMAPKEYINTVALINT = 8;
    private static final TField LIST_OF_MAP_KEY_INT_VAL_INT_FIELD_DESC = new TField("listOfMapKeyIntValInt", TType.LIST, (short)8);
    private final List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> listOfMapKeyStrValList;
    public static final int _LISTOFMAPKEYSTRVALLIST = 9;
    private static final TField LIST_OF_MAP_KEY_STR_VAL_LIST_FIELD_DESC = new TField("listOfMapKeyStrValList", TType.LIST, (short)9);
    private final Map<Set<Integer>, Long> mapKeySetValLong;
    public static final int _MAPKEYSETVALLONG = 10;
    private static final TField MAP_KEY_SET_VAL_LONG_FIELD_DESC = new TField("mapKeySetValLong", TType.MAP, (short)10);
    private final Map<List<String>, Integer> mapKeyListValLong;
    public static final int _MAPKEYLISTVALLONG = 11;
    private static final TField MAP_KEY_LIST_VAL_LONG_FIELD_DESC = new TField("mapKeyListValLong", TType.MAP, (short)11);
    private final Map<Map<Integer, String>, Map<Integer, String>> mapKeyMapValMap;
    public static final int _MAPKEYMAPVALMAP = 12;
    private static final TField MAP_KEY_MAP_VAL_MAP_FIELD_DESC = new TField("mapKeyMapValMap", TType.MAP, (short)12);
    private final Map<Set<List<Integer>>, Map<List<Set<String>>, String>> mapKeySetValMap;
    public static final int _MAPKEYSETVALMAP = 13;
    private static final TField MAP_KEY_SET_VAL_MAP_FIELD_DESC = new TField("mapKeySetValMap", TType.MAP, (short)13);
    private final Map<Map<Map<Integer, String>, String>, Map<Integer, String>> nestedMaps;
    public static final int _NESTEDMAPS = 14;
    private static final TField NESTED_MAPS_FIELD_DESC = new TField("nestedMaps", TType.MAP, (short)14);
    private final Map<Integer, List<test.fixtures.complex_struct.MyStruct>> mapKeyIntValList;
    public static final int _MAPKEYINTVALLIST = 15;
    private static final TField MAP_KEY_INT_VAL_LIST_FIELD_DESC = new TField("mapKeyIntValList", TType.MAP, (short)15);
    private final Map<Integer, Set<Boolean>> mapKeyIntValSet;
    public static final int _MAPKEYINTVALSET = 16;
    private static final TField MAP_KEY_INT_VAL_SET_FIELD_DESC = new TField("mapKeyIntValSet", TType.MAP, (short)16);
    private final Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> mapKeySetValInt;
    public static final int _MAPKEYSETVALINT = 17;
    private static final TField MAP_KEY_SET_VAL_INT_FIELD_DESC = new TField("mapKeySetValInt", TType.MAP, (short)17);
    private final Map<List<Integer>, Set<Map<Double, String>>> mapKeyListValSet;
    public static final int _MAPKEYLISTVALSET = 18;
    private static final TField MAP_KEY_LIST_VAL_SET_FIELD_DESC = new TField("mapKeyListValSet", TType.MAP, (short)18);

    
    @ThriftField(value=1, name="setOfSetOfInt", requiredness=Requiredness.NONE)
    public Set<Set<Integer>> getSetOfSetOfInt() { return setOfSetOfInt; }
        
    @ThriftField(value=2, name="listofListOfListOfListOfEnum", requiredness=Requiredness.NONE)
    public List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> getListofListOfListOfListOfEnum() { return listofListOfListOfListOfEnum; }
        
    @ThriftField(value=3, name="listOfListOfMyStruct", requiredness=Requiredness.NONE)
    public List<List<test.fixtures.complex_struct.MyStruct>> getListOfListOfMyStruct() { return listOfListOfMyStruct; }
        
    @ThriftField(value=4, name="setOfListOfListOfLong", requiredness=Requiredness.NONE)
    public Set<List<List<Long>>> getSetOfListOfListOfLong() { return setOfListOfListOfLong; }
        
    @ThriftField(value=5, name="setOfSetOfsetOfLong", requiredness=Requiredness.NONE)
    public Set<Set<Set<Long>>> getSetOfSetOfsetOfLong() { return setOfSetOfsetOfLong; }
        
    @ThriftField(value=6, name="mapStructListOfListOfLong", requiredness=Requiredness.NONE)
    public Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> getMapStructListOfListOfLong() { return mapStructListOfListOfLong; }
        
    @ThriftField(value=7, name="mKeyStructValInt", requiredness=Requiredness.NONE)
    public Map<test.fixtures.complex_struct.MyStruct, Integer> getMKeyStructValInt() { return mKeyStructValInt; }
        
    @ThriftField(value=8, name="listOfMapKeyIntValInt", requiredness=Requiredness.NONE)
    public List<Map<Integer, Integer>> getListOfMapKeyIntValInt() { return listOfMapKeyIntValInt; }
        
    @ThriftField(value=9, name="listOfMapKeyStrValList", requiredness=Requiredness.NONE)
    public List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> getListOfMapKeyStrValList() { return listOfMapKeyStrValList; }
        
    @ThriftField(value=10, name="mapKeySetValLong", requiredness=Requiredness.NONE)
    public Map<Set<Integer>, Long> getMapKeySetValLong() { return mapKeySetValLong; }
        
    @ThriftField(value=11, name="mapKeyListValLong", requiredness=Requiredness.NONE)
    public Map<List<String>, Integer> getMapKeyListValLong() { return mapKeyListValLong; }
        
    @ThriftField(value=12, name="mapKeyMapValMap", requiredness=Requiredness.NONE)
    public Map<Map<Integer, String>, Map<Integer, String>> getMapKeyMapValMap() { return mapKeyMapValMap; }
        
    @ThriftField(value=13, name="mapKeySetValMap", requiredness=Requiredness.NONE)
    public Map<Set<List<Integer>>, Map<List<Set<String>>, String>> getMapKeySetValMap() { return mapKeySetValMap; }
        
    @ThriftField(value=14, name="NestedMaps", requiredness=Requiredness.NONE)
    public Map<Map<Map<Integer, String>, String>, Map<Integer, String>> getNestedMaps() { return nestedMaps; }
        
    @ThriftField(value=15, name="mapKeyIntValList", requiredness=Requiredness.NONE)
    public Map<Integer, List<test.fixtures.complex_struct.MyStruct>> getMapKeyIntValList() { return mapKeyIntValList; }
        
    @ThriftField(value=16, name="mapKeyIntValSet", requiredness=Requiredness.NONE)
    public Map<Integer, Set<Boolean>> getMapKeyIntValSet() { return mapKeyIntValSet; }
        
    @ThriftField(value=17, name="mapKeySetValInt", requiredness=Requiredness.NONE)
    public Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> getMapKeySetValInt() { return mapKeySetValInt; }
        
    @ThriftField(value=18, name="mapKeyListValSet", requiredness=Requiredness.NONE)
    public Map<List<Integer>, Set<Map<Double, String>>> getMapKeyListValSet() { return mapKeyListValSet; }
    
    @Override
    public String toString() {
        ToStringHelper helper = toStringHelper(this);
        helper.add("setOfSetOfInt", setOfSetOfInt);
        helper.add("listofListOfListOfListOfEnum", listofListOfListOfListOfEnum);
        helper.add("listOfListOfMyStruct", listOfListOfMyStruct);
        helper.add("setOfListOfListOfLong", setOfListOfListOfLong);
        helper.add("setOfSetOfsetOfLong", setOfSetOfsetOfLong);
        helper.add("mapStructListOfListOfLong", mapStructListOfListOfLong);
        helper.add("mKeyStructValInt", mKeyStructValInt);
        helper.add("listOfMapKeyIntValInt", listOfMapKeyIntValInt);
        helper.add("listOfMapKeyStrValList", listOfMapKeyStrValList);
        helper.add("mapKeySetValLong", mapKeySetValLong);
        helper.add("mapKeyListValLong", mapKeyListValLong);
        helper.add("mapKeyMapValMap", mapKeyMapValMap);
        helper.add("mapKeySetValMap", mapKeySetValMap);
        helper.add("nestedMaps", nestedMaps);
        helper.add("mapKeyIntValList", mapKeyIntValList);
        helper.add("mapKeyIntValSet", mapKeyIntValSet);
        helper.add("mapKeySetValInt", mapKeySetValInt);
        helper.add("mapKeyListValSet", mapKeyListValSet);
        return helper.toString();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
    
        ComplexNestedStruct other = (ComplexNestedStruct)o;
    
        return
            Objects.equals(setOfSetOfInt, other.setOfSetOfInt) &&
            Objects.equals(listofListOfListOfListOfEnum, other.listofListOfListOfListOfEnum) &&
            Objects.equals(listOfListOfMyStruct, other.listOfListOfMyStruct) &&
            Objects.equals(setOfListOfListOfLong, other.setOfListOfListOfLong) &&
            Objects.equals(setOfSetOfsetOfLong, other.setOfSetOfsetOfLong) &&
            Objects.equals(mapStructListOfListOfLong, other.mapStructListOfListOfLong) &&
            Objects.equals(mKeyStructValInt, other.mKeyStructValInt) &&
            Objects.equals(listOfMapKeyIntValInt, other.listOfMapKeyIntValInt) &&
            Objects.equals(listOfMapKeyStrValList, other.listOfMapKeyStrValList) &&
            Objects.equals(mapKeySetValLong, other.mapKeySetValLong) &&
            Objects.equals(mapKeyListValLong, other.mapKeyListValLong) &&
            Objects.equals(mapKeyMapValMap, other.mapKeyMapValMap) &&
            Objects.equals(mapKeySetValMap, other.mapKeySetValMap) &&
            Objects.equals(nestedMaps, other.nestedMaps) &&
            Objects.equals(mapKeyIntValList, other.mapKeyIntValList) &&
            Objects.equals(mapKeyIntValSet, other.mapKeyIntValSet) &&
            Objects.equals(mapKeySetValInt, other.mapKeySetValInt) &&
            Objects.equals(mapKeyListValSet, other.mapKeyListValSet) &&
            true;
    }
    
    @Override
    public int hashCode() {
        return Arrays.deepHashCode(new Object[] {
            setOfSetOfInt,
            listofListOfListOfListOfEnum,
            listOfListOfMyStruct,
            setOfListOfListOfLong,
            setOfSetOfsetOfLong,
            mapStructListOfListOfLong,
            mKeyStructValInt,
            listOfMapKeyIntValInt,
            listOfMapKeyStrValList,
            mapKeySetValLong,
            mapKeyListValLong,
            mapKeyMapValMap,
            mapKeySetValMap,
            nestedMaps,
            mapKeyIntValList,
            mapKeyIntValSet,
            mapKeySetValInt,
            mapKeyListValSet
        });
    }
    
    
      // Currently, the read0 method cannot read metadatamap for JSON styled serialization.
      // Perhaps, it will be implemented in the future!
    public static ComplexNestedStruct read0(TProtocol oprot) throws TException {
      TField __field;
      oprot.readStructBegin();
      ComplexNestedStruct.Builder builder = new ComplexNestedStruct.Builder();
      while (true) {
        __field = oprot.readFieldBegin();
        if (__field.type == TType.STOP) { break; }
        switch (__field.id) {
        case _SETOFSETOFINT:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<Set<Integer>> _iter1 = new HashSet<Set<Integer>>(Math.max(0, 2*_set1.size));
            Set<Set<Integer>> setOfSetOfInt = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                TSet _set2 = oprot.readSetBegin();
            Set<Integer> _iter2 = new HashSet<Integer>(Math.max(0, 2*_set2.size));
            if (_set2.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i2 = 0; _i2 < _set2.size; ++_i2) {
                _iter2.add(oprot.readI32());
            }
            _iter1.add(_iter2);
            oprot.readSetEnd();
            }
            oprot.readSetEnd();
            builder.setSetOfSetOfInt(setOfSetOfInt);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LISTOFLISTOFLISTOFLISTOFENUM:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> _iter1 = new ArrayList<List<List<List<test.fixtures.complex_struct.MyEnum>>>>(Math.max(0, 2*_list1.size));
            List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> listofListOfListOfListOfEnum = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                TList _list2 = oprot.readListBegin();
            List<List<List<test.fixtures.complex_struct.MyEnum>>> _iter2 = new ArrayList<List<List<test.fixtures.complex_struct.MyEnum>>>(Math.max(0, 2*_list2.size));
            if (_list2.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i2 = 0; _i2 < _list2.size; ++_i2) {
                TList _list3 = oprot.readListBegin();
            List<List<test.fixtures.complex_struct.MyEnum>> _iter3 = new ArrayList<List<test.fixtures.complex_struct.MyEnum>>(Math.max(0, 2*_list3.size));
            if (_list3.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i3 = 0; _i3 < _list3.size; ++_i3) {
                TList _list4 = oprot.readListBegin();
            List<test.fixtures.complex_struct.MyEnum> _iter4 = new ArrayList<test.fixtures.complex_struct.MyEnum>(Math.max(0, 2*_list4.size));
            if (_list4.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i4 = 0; _i4 < _list4.size; ++_i4) {
                _iter4.add(test.fixtures.complex_struct.MyEnum.fromInteger(oprot.readI32()));
            }
            _iter3.add(_iter4);
            oprot.readListEnd();
            }
            _iter2.add(_iter3);
            oprot.readListEnd();
            }
            _iter1.add(_iter2);
            oprot.readListEnd();
            }
            oprot.readListEnd();
            builder.setListofListOfListOfListOfEnum(listofListOfListOfListOfEnum);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LISTOFLISTOFMYSTRUCT:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<List<test.fixtures.complex_struct.MyStruct>> _iter1 = new ArrayList<List<test.fixtures.complex_struct.MyStruct>>(Math.max(0, 2*_list1.size));
            List<List<test.fixtures.complex_struct.MyStruct>> listOfListOfMyStruct = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                TList _list2 = oprot.readListBegin();
            List<test.fixtures.complex_struct.MyStruct> _iter2 = new ArrayList<test.fixtures.complex_struct.MyStruct>(Math.max(0, 2*_list2.size));
            if (_list2.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i2 = 0; _i2 < _list2.size; ++_i2) {
                _iter2.add(test.fixtures.complex_struct.MyStruct.read0(oprot));
            }
            _iter1.add(_iter2);
            oprot.readListEnd();
            }
            oprot.readListEnd();
            builder.setListOfListOfMyStruct(listOfListOfMyStruct);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _SETOFLISTOFLISTOFLONG:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<List<List<Long>>> _iter1 = new HashSet<List<List<Long>>>(Math.max(0, 2*_set1.size));
            Set<List<List<Long>>> setOfListOfListOfLong = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                TList _list2 = oprot.readListBegin();
            List<List<Long>> _iter2 = new ArrayList<List<Long>>(Math.max(0, 2*_list2.size));
            if (_list2.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i2 = 0; _i2 < _list2.size; ++_i2) {
                TList _list3 = oprot.readListBegin();
            List<Long> _iter3 = new ArrayList<Long>(Math.max(0, 2*_list3.size));
            if (_list3.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i3 = 0; _i3 < _list3.size; ++_i3) {
                _iter3.add(oprot.readI64());
            }
            _iter2.add(_iter3);
            oprot.readListEnd();
            }
            _iter1.add(_iter2);
            oprot.readListEnd();
            }
            oprot.readSetEnd();
            builder.setSetOfListOfListOfLong(setOfListOfListOfLong);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _SETOFSETOFSETOFLONG:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<Set<Set<Long>>> _iter1 = new HashSet<Set<Set<Long>>>(Math.max(0, 2*_set1.size));
            Set<Set<Set<Long>>> setOfSetOfsetOfLong = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                TSet _set2 = oprot.readSetBegin();
            Set<Set<Long>> _iter2 = new HashSet<Set<Long>>(Math.max(0, 2*_set2.size));
            if (_set2.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i2 = 0; _i2 < _set2.size; ++_i2) {
                TSet _set3 = oprot.readSetBegin();
            Set<Long> _iter3 = new HashSet<Long>(Math.max(0, 2*_set3.size));
            if (_set3.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i3 = 0; _i3 < _set3.size; ++_i3) {
                _iter3.add(oprot.readI64());
            }
            _iter2.add(_iter3);
            oprot.readSetEnd();
            }
            _iter1.add(_iter2);
            oprot.readSetEnd();
            }
            oprot.readSetEnd();
            builder.setSetOfSetOfsetOfLong(setOfSetOfsetOfLong);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPSTRUCTLISTOFLISTOFLONG:
          if (__field.type == TType.MAP) {
            Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> mapStructListOfListOfLong;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> _iter1 = new HashMap<Integer, List<List<test.fixtures.complex_struct.MyStruct>>>(Math.max(0, 2*_map1.size));
            mapStructListOfListOfLong = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                int _key1 = oprot.readI32();
                List<List<test.fixtures.complex_struct.MyStruct>> _val1;
                TList _list2 = oprot.readListBegin();
            List<List<test.fixtures.complex_struct.MyStruct>> _iter2 = new ArrayList<List<test.fixtures.complex_struct.MyStruct>>(Math.max(0, 2*_list2.size));
            if (_list2.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i2 = 0; _i2 < _list2.size; ++_i2) {
                TList _list3 = oprot.readListBegin();
            List<test.fixtures.complex_struct.MyStruct> _iter3 = new ArrayList<test.fixtures.complex_struct.MyStruct>(Math.max(0, 2*_list3.size));
            if (_list3.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i3 = 0; _i3 < _list3.size; ++_i3) {
                _iter3.add(test.fixtures.complex_struct.MyStruct.read0(oprot));
            }
            _iter2.add(_iter3);
            oprot.readListEnd();
            }
            _val1 = _iter2;
            oprot.readListEnd();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapStructListOfListOfLong(mapStructListOfListOfLong);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MKEYSTRUCTVALINT:
          if (__field.type == TType.MAP) {
            Map<test.fixtures.complex_struct.MyStruct, Integer> mKeyStructValInt;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<test.fixtures.complex_struct.MyStruct, Integer> _iter1 = new HashMap<test.fixtures.complex_struct.MyStruct, Integer>(Math.max(0, 2*_map1.size));
            mKeyStructValInt = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                test.fixtures.complex_struct.MyStruct _key1 = test.fixtures.complex_struct.MyStruct.read0(oprot);
                int _val1 = oprot.readI32();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMKeyStructValInt(mKeyStructValInt);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LISTOFMAPKEYINTVALINT:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Map<Integer, Integer>> _iter1 = new ArrayList<Map<Integer, Integer>>(Math.max(0, 2*_list1.size));
            List<Map<Integer, Integer>> listOfMapKeyIntValInt = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                            {
            TMap _map2 = oprot.readMapBegin();
            Map<Integer, Integer> _iter2 = new HashMap<Integer, Integer>(Math.max(0, 2*_map2.size));
            if (_map2.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i2 = 0; _i2 < _map2.size; ++_i2) {
                int _key2 = oprot.readI32();
                int _val2 = oprot.readI32();
                _iter2.put(_key2, _val2);
            }
            _iter1.add(_iter2);
            }
            oprot.readMapEnd();
            }
            oprot.readListEnd();
            builder.setListOfMapKeyIntValInt(listOfMapKeyIntValInt);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LISTOFMAPKEYSTRVALLIST:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> _iter1 = new ArrayList<Map<String, List<test.fixtures.complex_struct.MyStruct>>>(Math.max(0, 2*_list1.size));
            List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> listOfMapKeyStrValList = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                            {
            TMap _map2 = oprot.readMapBegin();
            Map<String, List<test.fixtures.complex_struct.MyStruct>> _iter2 = new HashMap<String, List<test.fixtures.complex_struct.MyStruct>>(Math.max(0, 2*_map2.size));
            if (_map2.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i2 = 0; _i2 < _map2.size; ++_i2) {
                String _key2 = oprot.readString();
                List<test.fixtures.complex_struct.MyStruct> _val2;
                TList _list3 = oprot.readListBegin();
            List<test.fixtures.complex_struct.MyStruct> _iter3 = new ArrayList<test.fixtures.complex_struct.MyStruct>(Math.max(0, 2*_list3.size));
            if (_list3.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i3 = 0; _i3 < _list3.size; ++_i3) {
                _iter3.add(test.fixtures.complex_struct.MyStruct.read0(oprot));
            }
            _val2 = _iter3;
            oprot.readListEnd();
                _iter2.put(_key2, _val2);
            }
            _iter1.add(_iter2);
            }
            oprot.readMapEnd();
            }
            oprot.readListEnd();
            builder.setListOfMapKeyStrValList(listOfMapKeyStrValList);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYSETVALLONG:
          if (__field.type == TType.MAP) {
            Map<Set<Integer>, Long> mapKeySetValLong;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Set<Integer>, Long> _iter1 = new HashMap<Set<Integer>, Long>(Math.max(0, 2*_map1.size));
            mapKeySetValLong = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                Set<Integer> _key1;
                TSet _set2 = oprot.readSetBegin();
            Set<Integer> _iter2 = new HashSet<Integer>(Math.max(0, 2*_set2.size));
            if (_set2.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i2 = 0; _i2 < _set2.size; ++_i2) {
                _iter2.add(oprot.readI32());
            }
            _key1 = _iter2;
            oprot.readSetEnd();
                                long _val1 = oprot.readI64();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeySetValLong(mapKeySetValLong);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYLISTVALLONG:
          if (__field.type == TType.MAP) {
            Map<List<String>, Integer> mapKeyListValLong;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<List<String>, Integer> _iter1 = new HashMap<List<String>, Integer>(Math.max(0, 2*_map1.size));
            mapKeyListValLong = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                List<String> _key1;
                TList _list2 = oprot.readListBegin();
            List<String> _iter2 = new ArrayList<String>(Math.max(0, 2*_list2.size));
            if (_list2.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i2 = 0; _i2 < _list2.size; ++_i2) {
                _iter2.add(oprot.readString());
            }
            _key1 = _iter2;
            oprot.readListEnd();
                                int _val1 = oprot.readI32();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeyListValLong(mapKeyListValLong);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYMAPVALMAP:
          if (__field.type == TType.MAP) {
            Map<Map<Integer, String>, Map<Integer, String>> mapKeyMapValMap;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Map<Integer, String>, Map<Integer, String>> _iter1 = new HashMap<Map<Integer, String>, Map<Integer, String>>(Math.max(0, 2*_map1.size));
            mapKeyMapValMap = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                Map<Integer, String> _key1;
                            {
            TMap _map2 = oprot.readMapBegin();
            Map<Integer, String> _iter2 = new HashMap<Integer, String>(Math.max(0, 2*_map2.size));
            if (_map2.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i2 = 0; _i2 < _map2.size; ++_i2) {
                int _key2 = oprot.readI32();
                String _val2 = oprot.readString();
                _iter2.put(_key2, _val2);
            }
            _key1 = _iter2;
            }
            oprot.readMapEnd();
                                Map<Integer, String> _val1;
                            {
            TMap _map2 = oprot.readMapBegin();
            Map<Integer, String> _iter2 = new HashMap<Integer, String>(Math.max(0, 2*_map2.size));
            if (_map2.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i2 = 0; _i2 < _map2.size; ++_i2) {
                int _key2 = oprot.readI32();
                String _val2 = oprot.readString();
                _iter2.put(_key2, _val2);
            }
            _val1 = _iter2;
            }
            oprot.readMapEnd();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeyMapValMap(mapKeyMapValMap);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYSETVALMAP:
          if (__field.type == TType.MAP) {
            Map<Set<List<Integer>>, Map<List<Set<String>>, String>> mapKeySetValMap;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Set<List<Integer>>, Map<List<Set<String>>, String>> _iter1 = new HashMap<Set<List<Integer>>, Map<List<Set<String>>, String>>(Math.max(0, 2*_map1.size));
            mapKeySetValMap = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                Set<List<Integer>> _key1;
                TSet _set2 = oprot.readSetBegin();
            Set<List<Integer>> _iter2 = new HashSet<List<Integer>>(Math.max(0, 2*_set2.size));
            if (_set2.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i2 = 0; _i2 < _set2.size; ++_i2) {
                TList _list3 = oprot.readListBegin();
            List<Integer> _iter3 = new ArrayList<Integer>(Math.max(0, 2*_list3.size));
            if (_list3.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i3 = 0; _i3 < _list3.size; ++_i3) {
                _iter3.add(oprot.readI32());
            }
            _iter2.add(_iter3);
            oprot.readListEnd();
            }
            _key1 = _iter2;
            oprot.readSetEnd();
                                Map<List<Set<String>>, String> _val1;
                            {
            TMap _map2 = oprot.readMapBegin();
            Map<List<Set<String>>, String> _iter2 = new HashMap<List<Set<String>>, String>(Math.max(0, 2*_map2.size));
            if (_map2.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i2 = 0; _i2 < _map2.size; ++_i2) {
                List<Set<String>> _key2;
                TList _list3 = oprot.readListBegin();
            List<Set<String>> _iter3 = new ArrayList<Set<String>>(Math.max(0, 2*_list3.size));
            if (_list3.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i3 = 0; _i3 < _list3.size; ++_i3) {
                TSet _set4 = oprot.readSetBegin();
            Set<String> _iter4 = new HashSet<String>(Math.max(0, 2*_set4.size));
            if (_set4.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i4 = 0; _i4 < _set4.size; ++_i4) {
                _iter4.add(oprot.readString());
            }
            _iter3.add(_iter4);
            oprot.readSetEnd();
            }
            _key2 = _iter3;
            oprot.readListEnd();
                                String _val2 = oprot.readString();
                _iter2.put(_key2, _val2);
            }
            _val1 = _iter2;
            }
            oprot.readMapEnd();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeySetValMap(mapKeySetValMap);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _NESTEDMAPS:
          if (__field.type == TType.MAP) {
            Map<Map<Map<Integer, String>, String>, Map<Integer, String>> nestedMaps;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Map<Map<Integer, String>, String>, Map<Integer, String>> _iter1 = new HashMap<Map<Map<Integer, String>, String>, Map<Integer, String>>(Math.max(0, 2*_map1.size));
            nestedMaps = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                Map<Map<Integer, String>, String> _key1;
                            {
            TMap _map2 = oprot.readMapBegin();
            Map<Map<Integer, String>, String> _iter2 = new HashMap<Map<Integer, String>, String>(Math.max(0, 2*_map2.size));
            if (_map2.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i2 = 0; _i2 < _map2.size; ++_i2) {
                Map<Integer, String> _key2;
                            {
            TMap _map3 = oprot.readMapBegin();
            Map<Integer, String> _iter3 = new HashMap<Integer, String>(Math.max(0, 2*_map3.size));
            if (_map3.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i3 = 0; _i3 < _map3.size; ++_i3) {
                int _key3 = oprot.readI32();
                String _val3 = oprot.readString();
                _iter3.put(_key3, _val3);
            }
            _key2 = _iter3;
            }
            oprot.readMapEnd();
                                String _val2 = oprot.readString();
                _iter2.put(_key2, _val2);
            }
            _key1 = _iter2;
            }
            oprot.readMapEnd();
                                Map<Integer, String> _val1;
                            {
            TMap _map2 = oprot.readMapBegin();
            Map<Integer, String> _iter2 = new HashMap<Integer, String>(Math.max(0, 2*_map2.size));
            if (_map2.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i2 = 0; _i2 < _map2.size; ++_i2) {
                int _key2 = oprot.readI32();
                String _val2 = oprot.readString();
                _iter2.put(_key2, _val2);
            }
            _val1 = _iter2;
            }
            oprot.readMapEnd();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setNestedMaps(nestedMaps);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYINTVALLIST:
          if (__field.type == TType.MAP) {
            Map<Integer, List<test.fixtures.complex_struct.MyStruct>> mapKeyIntValList;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Integer, List<test.fixtures.complex_struct.MyStruct>> _iter1 = new HashMap<Integer, List<test.fixtures.complex_struct.MyStruct>>(Math.max(0, 2*_map1.size));
            mapKeyIntValList = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                int _key1 = oprot.readI32();
                List<test.fixtures.complex_struct.MyStruct> _val1;
                TList _list2 = oprot.readListBegin();
            List<test.fixtures.complex_struct.MyStruct> _iter2 = new ArrayList<test.fixtures.complex_struct.MyStruct>(Math.max(0, 2*_list2.size));
            if (_list2.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i2 = 0; _i2 < _list2.size; ++_i2) {
                _iter2.add(test.fixtures.complex_struct.MyStruct.read0(oprot));
            }
            _val1 = _iter2;
            oprot.readListEnd();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeyIntValList(mapKeyIntValList);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYINTVALSET:
          if (__field.type == TType.MAP) {
            Map<Integer, Set<Boolean>> mapKeyIntValSet;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Integer, Set<Boolean>> _iter1 = new HashMap<Integer, Set<Boolean>>(Math.max(0, 2*_map1.size));
            mapKeyIntValSet = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                int _key1 = oprot.readI32();
                Set<Boolean> _val1;
                TSet _set2 = oprot.readSetBegin();
            Set<Boolean> _iter2 = new HashSet<Boolean>(Math.max(0, 2*_set2.size));
            if (_set2.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i2 = 0; _i2 < _set2.size; ++_i2) {
                _iter2.add(oprot.readBool());
            }
            _val1 = _iter2;
            oprot.readSetEnd();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeyIntValSet(mapKeyIntValSet);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYSETVALINT:
          if (__field.type == TType.MAP) {
            Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> mapKeySetValInt;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> _iter1 = new HashMap<Set<Boolean>, test.fixtures.complex_struct.MyEnum>(Math.max(0, 2*_map1.size));
            mapKeySetValInt = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                Set<Boolean> _key1;
                TSet _set2 = oprot.readSetBegin();
            Set<Boolean> _iter2 = new HashSet<Boolean>(Math.max(0, 2*_set2.size));
            if (_set2.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i2 = 0; _i2 < _set2.size; ++_i2) {
                _iter2.add(oprot.readBool());
            }
            _key1 = _iter2;
            oprot.readSetEnd();
                                test.fixtures.complex_struct.MyEnum _val1 = test.fixtures.complex_struct.MyEnum.fromInteger(oprot.readI32());
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeySetValInt(mapKeySetValInt);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MAPKEYLISTVALSET:
          if (__field.type == TType.MAP) {
            Map<List<Integer>, Set<Map<Double, String>>> mapKeyListValSet;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<List<Integer>, Set<Map<Double, String>>> _iter1 = new HashMap<List<Integer>, Set<Map<Double, String>>>(Math.max(0, 2*_map1.size));
            mapKeyListValSet = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                List<Integer> _key1;
                TList _list2 = oprot.readListBegin();
            List<Integer> _iter2 = new ArrayList<Integer>(Math.max(0, 2*_list2.size));
            if (_list2.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i2 = 0; _i2 < _list2.size; ++_i2) {
                _iter2.add(oprot.readI32());
            }
            _key1 = _iter2;
            oprot.readListEnd();
                                Set<Map<Double, String>> _val1;
                TSet _set2 = oprot.readSetBegin();
            Set<Map<Double, String>> _iter2 = new HashSet<Map<Double, String>>(Math.max(0, 2*_set2.size));
            if (_set2.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i2 = 0; _i2 < _set2.size; ++_i2) {
                            {
            TMap _map3 = oprot.readMapBegin();
            Map<Double, String> _iter3 = new HashMap<Double, String>(Math.max(0, 2*_map3.size));
            if (_map3.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i3 = 0; _i3 < _map3.size; ++_i3) {
                double _key3 = oprot.readDouble();
                String _val3 = oprot.readString();
                _iter3.put(_key3, _val3);
            }
            _iter2.add(_iter3);
            }
            oprot.readMapEnd();
            }
            _val1 = _iter2;
            oprot.readSetEnd();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMapKeyListValSet(mapKeyListValSet);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        default:
          TProtocolUtil.skip(oprot, __field.type);
          break;
        }
        oprot.readFieldEnd();
      }
      oprot.readStructEnd();
      return builder.build();
    }
    
    public void write0(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);
      if (this.setOfSetOfInt != null) {
        oprot.writeFieldBegin(SET_OF_SET_OF_INT_FIELD_DESC);
        Set<Set<Integer>> _iter0 = this.setOfSetOfInt;
        oprot.writeSetBegin(new TSet(TType.SET, _iter0.size()));
        for (Set<Integer> _iter1 : _iter0) {
          oprot.writeSetBegin(new TSet(TType.I32, _iter1.size()));
        for (int _iter2 : _iter1) {
          oprot.writeI32(_iter2);
        }
        oprot.writeSetEnd();
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      if (this.listofListOfListOfListOfEnum != null) {
        oprot.writeFieldBegin(LISTOF_LIST_OF_LIST_OF_LIST_OF_ENUM_FIELD_DESC);
        List<List<List<List<test.fixtures.complex_struct.MyEnum>>>> _iter0 = this.listofListOfListOfListOfEnum;
        oprot.writeListBegin(new TList(TType.LIST, _iter0.size()));
        for (List<List<List<test.fixtures.complex_struct.MyEnum>>> _iter1 : _iter0) {
          oprot.writeListBegin(new TList(TType.LIST, _iter1.size()));
        for (List<List<test.fixtures.complex_struct.MyEnum>> _iter2 : _iter1) {
          oprot.writeListBegin(new TList(TType.LIST, _iter2.size()));
        for (List<test.fixtures.complex_struct.MyEnum> _iter3 : _iter2) {
          oprot.writeListBegin(new TList(TType.I32, _iter3.size()));
        for (test.fixtures.complex_struct.MyEnum _iter4 : _iter3) {
          oprot.writeI32(_iter4 == null ? 0 : _iter4.getValue());
        }
        oprot.writeListEnd();
        }
        oprot.writeListEnd();
        }
        oprot.writeListEnd();
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.listOfListOfMyStruct != null) {
        oprot.writeFieldBegin(LIST_OF_LIST_OF_MY_STRUCT_FIELD_DESC);
        List<List<test.fixtures.complex_struct.MyStruct>> _iter0 = this.listOfListOfMyStruct;
        oprot.writeListBegin(new TList(TType.LIST, _iter0.size()));
        for (List<test.fixtures.complex_struct.MyStruct> _iter1 : _iter0) {
          oprot.writeListBegin(new TList(TType.STRUCT, _iter1.size()));
        for (test.fixtures.complex_struct.MyStruct _iter2 : _iter1) {
          _iter2.write0(oprot);
        }
        oprot.writeListEnd();
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.setOfListOfListOfLong != null) {
        oprot.writeFieldBegin(SET_OF_LIST_OF_LIST_OF_LONG_FIELD_DESC);
        Set<List<List<Long>>> _iter0 = this.setOfListOfListOfLong;
        oprot.writeSetBegin(new TSet(TType.LIST, _iter0.size()));
        for (List<List<Long>> _iter1 : _iter0) {
          oprot.writeListBegin(new TList(TType.LIST, _iter1.size()));
        for (List<Long> _iter2 : _iter1) {
          oprot.writeListBegin(new TList(TType.I64, _iter2.size()));
        for (long _iter3 : _iter2) {
          oprot.writeI64(_iter3);
        }
        oprot.writeListEnd();
        }
        oprot.writeListEnd();
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      if (this.setOfSetOfsetOfLong != null) {
        oprot.writeFieldBegin(SET_OF_SET_OFSET_OF_LONG_FIELD_DESC);
        Set<Set<Set<Long>>> _iter0 = this.setOfSetOfsetOfLong;
        oprot.writeSetBegin(new TSet(TType.SET, _iter0.size()));
        for (Set<Set<Long>> _iter1 : _iter0) {
          oprot.writeSetBegin(new TSet(TType.SET, _iter1.size()));
        for (Set<Long> _iter2 : _iter1) {
          oprot.writeSetBegin(new TSet(TType.I64, _iter2.size()));
        for (long _iter3 : _iter2) {
          oprot.writeI64(_iter3);
        }
        oprot.writeSetEnd();
        }
        oprot.writeSetEnd();
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapStructListOfListOfLong != null) {
        oprot.writeFieldBegin(MAP_STRUCT_LIST_OF_LIST_OF_LONG_FIELD_DESC);
        Map<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> _iter0 = this.mapStructListOfListOfLong;
        oprot.writeMapBegin(new TMap(TType.I32, TType.LIST, _iter0.size()));
        for (Map.Entry<Integer, List<List<test.fixtures.complex_struct.MyStruct>>> _iter1 : _iter0.entrySet()) {
          oprot.writeI32(_iter1.getKey());
          
          oprot.writeListBegin(new TList(TType.LIST, _iter1.getValue().size()));
        for (List<test.fixtures.complex_struct.MyStruct> _iter2 : _iter1.getValue()) {
          oprot.writeListBegin(new TList(TType.STRUCT, _iter2.size()));
        for (test.fixtures.complex_struct.MyStruct _iter3 : _iter2) {
          _iter3.write0(oprot);
        }
        oprot.writeListEnd();
        }
        oprot.writeListEnd();
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mKeyStructValInt != null) {
        oprot.writeFieldBegin(M_KEY_STRUCT_VAL_INT_FIELD_DESC);
        Map<test.fixtures.complex_struct.MyStruct, Integer> _iter0 = this.mKeyStructValInt;
        oprot.writeMapBegin(new TMap(TType.STRUCT, TType.I32, _iter0.size()));
        for (Map.Entry<test.fixtures.complex_struct.MyStruct, Integer> _iter1 : _iter0.entrySet()) {
          _iter1.getKey().write0(oprot);
          oprot.writeI32(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.listOfMapKeyIntValInt != null) {
        oprot.writeFieldBegin(LIST_OF_MAP_KEY_INT_VAL_INT_FIELD_DESC);
        List<Map<Integer, Integer>> _iter0 = this.listOfMapKeyIntValInt;
        oprot.writeListBegin(new TList(TType.MAP, _iter0.size()));
        for (Map<Integer, Integer> _iter1 : _iter0) {
          oprot.writeMapBegin(new TMap(TType.I32, TType.I32, _iter1.size()));
        for (Map.Entry<Integer, Integer> _iter2 : _iter1.entrySet()) {
          oprot.writeI32(_iter2.getKey());
          oprot.writeI32(_iter2.getValue());
        }
        oprot.writeMapEnd();
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.listOfMapKeyStrValList != null) {
        oprot.writeFieldBegin(LIST_OF_MAP_KEY_STR_VAL_LIST_FIELD_DESC);
        List<Map<String, List<test.fixtures.complex_struct.MyStruct>>> _iter0 = this.listOfMapKeyStrValList;
        oprot.writeListBegin(new TList(TType.MAP, _iter0.size()));
        for (Map<String, List<test.fixtures.complex_struct.MyStruct>> _iter1 : _iter0) {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, _iter1.size()));
        for (Map.Entry<String, List<test.fixtures.complex_struct.MyStruct>> _iter2 : _iter1.entrySet()) {
          oprot.writeString(_iter2.getKey());
          
          oprot.writeListBegin(new TList(TType.STRUCT, _iter2.getValue().size()));
        for (test.fixtures.complex_struct.MyStruct _iter3 : _iter2.getValue()) {
          _iter3.write0(oprot);
        }
        oprot.writeListEnd();
        }
        oprot.writeMapEnd();
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeySetValLong != null) {
        oprot.writeFieldBegin(MAP_KEY_SET_VAL_LONG_FIELD_DESC);
        Map<Set<Integer>, Long> _iter0 = this.mapKeySetValLong;
        oprot.writeMapBegin(new TMap(TType.SET, TType.I64, _iter0.size()));
        for (Map.Entry<Set<Integer>, Long> _iter1 : _iter0.entrySet()) {
          oprot.writeSetBegin(new TSet(TType.I32, _iter1.getKey().size()));
        for (int _iter2 : _iter1.getKey()) {
          oprot.writeI32(_iter2);
        }
        oprot.writeSetEnd();
oprot.writeI64(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeyListValLong != null) {
        oprot.writeFieldBegin(MAP_KEY_LIST_VAL_LONG_FIELD_DESC);
        Map<List<String>, Integer> _iter0 = this.mapKeyListValLong;
        oprot.writeMapBegin(new TMap(TType.LIST, TType.I32, _iter0.size()));
        for (Map.Entry<List<String>, Integer> _iter1 : _iter0.entrySet()) {
          oprot.writeListBegin(new TList(TType.STRING, _iter1.getKey().size()));
        for (String _iter2 : _iter1.getKey()) {
          oprot.writeString(_iter2);
        }
        oprot.writeListEnd();
oprot.writeI32(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeyMapValMap != null) {
        oprot.writeFieldBegin(MAP_KEY_MAP_VAL_MAP_FIELD_DESC);
        Map<Map<Integer, String>, Map<Integer, String>> _iter0 = this.mapKeyMapValMap;
        oprot.writeMapBegin(new TMap(TType.MAP, TType.MAP, _iter0.size()));
        for (Map.Entry<Map<Integer, String>, Map<Integer, String>> _iter1 : _iter0.entrySet()) {
          oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, _iter1.getKey().size()));
        for (Map.Entry<Integer, String> _iter2 : _iter1.getKey().entrySet()) {
          oprot.writeI32(_iter2.getKey());
          oprot.writeString(_iter2.getValue());
        }
        oprot.writeMapEnd();

          oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, _iter1.getValue().size()));
        for (Map.Entry<Integer, String> _iter2 : _iter1.getValue().entrySet()) {
          oprot.writeI32(_iter2.getKey());
          oprot.writeString(_iter2.getValue());
        }
        oprot.writeMapEnd();
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeySetValMap != null) {
        oprot.writeFieldBegin(MAP_KEY_SET_VAL_MAP_FIELD_DESC);
        Map<Set<List<Integer>>, Map<List<Set<String>>, String>> _iter0 = this.mapKeySetValMap;
        oprot.writeMapBegin(new TMap(TType.SET, TType.MAP, _iter0.size()));
        for (Map.Entry<Set<List<Integer>>, Map<List<Set<String>>, String>> _iter1 : _iter0.entrySet()) {
          oprot.writeSetBegin(new TSet(TType.LIST, _iter1.getKey().size()));
        for (List<Integer> _iter2 : _iter1.getKey()) {
          oprot.writeListBegin(new TList(TType.I32, _iter2.size()));
        for (int _iter3 : _iter2) {
          oprot.writeI32(_iter3);
        }
        oprot.writeListEnd();
        }
        oprot.writeSetEnd();

          oprot.writeMapBegin(new TMap(TType.LIST, TType.STRING, _iter1.getValue().size()));
        for (Map.Entry<List<Set<String>>, String> _iter2 : _iter1.getValue().entrySet()) {
          oprot.writeListBegin(new TList(TType.SET, _iter2.getKey().size()));
        for (Set<String> _iter3 : _iter2.getKey()) {
          oprot.writeSetBegin(new TSet(TType.STRING, _iter3.size()));
        for (String _iter4 : _iter3) {
          oprot.writeString(_iter4);
        }
        oprot.writeSetEnd();
        }
        oprot.writeListEnd();
oprot.writeString(_iter2.getValue());
        }
        oprot.writeMapEnd();
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.nestedMaps != null) {
        oprot.writeFieldBegin(NESTED_MAPS_FIELD_DESC);
        Map<Map<Map<Integer, String>, String>, Map<Integer, String>> _iter0 = this.nestedMaps;
        oprot.writeMapBegin(new TMap(TType.MAP, TType.MAP, _iter0.size()));
        for (Map.Entry<Map<Map<Integer, String>, String>, Map<Integer, String>> _iter1 : _iter0.entrySet()) {
          oprot.writeMapBegin(new TMap(TType.MAP, TType.STRING, _iter1.getKey().size()));
        for (Map.Entry<Map<Integer, String>, String> _iter2 : _iter1.getKey().entrySet()) {
          oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, _iter2.getKey().size()));
        for (Map.Entry<Integer, String> _iter3 : _iter2.getKey().entrySet()) {
          oprot.writeI32(_iter3.getKey());
          oprot.writeString(_iter3.getValue());
        }
        oprot.writeMapEnd();
oprot.writeString(_iter2.getValue());
        }
        oprot.writeMapEnd();

          oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, _iter1.getValue().size()));
        for (Map.Entry<Integer, String> _iter2 : _iter1.getValue().entrySet()) {
          oprot.writeI32(_iter2.getKey());
          oprot.writeString(_iter2.getValue());
        }
        oprot.writeMapEnd();
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeyIntValList != null) {
        oprot.writeFieldBegin(MAP_KEY_INT_VAL_LIST_FIELD_DESC);
        Map<Integer, List<test.fixtures.complex_struct.MyStruct>> _iter0 = this.mapKeyIntValList;
        oprot.writeMapBegin(new TMap(TType.I32, TType.LIST, _iter0.size()));
        for (Map.Entry<Integer, List<test.fixtures.complex_struct.MyStruct>> _iter1 : _iter0.entrySet()) {
          oprot.writeI32(_iter1.getKey());
          
          oprot.writeListBegin(new TList(TType.STRUCT, _iter1.getValue().size()));
        for (test.fixtures.complex_struct.MyStruct _iter2 : _iter1.getValue()) {
          _iter2.write0(oprot);
        }
        oprot.writeListEnd();
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeyIntValSet != null) {
        oprot.writeFieldBegin(MAP_KEY_INT_VAL_SET_FIELD_DESC);
        Map<Integer, Set<Boolean>> _iter0 = this.mapKeyIntValSet;
        oprot.writeMapBegin(new TMap(TType.I32, TType.SET, _iter0.size()));
        for (Map.Entry<Integer, Set<Boolean>> _iter1 : _iter0.entrySet()) {
          oprot.writeI32(_iter1.getKey());
          
          oprot.writeSetBegin(new TSet(TType.BOOL, _iter1.getValue().size()));
        for (boolean _iter2 : _iter1.getValue()) {
          oprot.writeBool(_iter2);
        }
        oprot.writeSetEnd();
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeySetValInt != null) {
        oprot.writeFieldBegin(MAP_KEY_SET_VAL_INT_FIELD_DESC);
        Map<Set<Boolean>, test.fixtures.complex_struct.MyEnum> _iter0 = this.mapKeySetValInt;
        oprot.writeMapBegin(new TMap(TType.SET, TType.I32, _iter0.size()));
        for (Map.Entry<Set<Boolean>, test.fixtures.complex_struct.MyEnum> _iter1 : _iter0.entrySet()) {
          oprot.writeSetBegin(new TSet(TType.BOOL, _iter1.getKey().size()));
        for (boolean _iter2 : _iter1.getKey()) {
          oprot.writeBool(_iter2);
        }
        oprot.writeSetEnd();
oprot.writeI32(_iter1 == null ? 0 : _iter1.getValue().getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mapKeyListValSet != null) {
        oprot.writeFieldBegin(MAP_KEY_LIST_VAL_SET_FIELD_DESC);
        Map<List<Integer>, Set<Map<Double, String>>> _iter0 = this.mapKeyListValSet;
        oprot.writeMapBegin(new TMap(TType.LIST, TType.SET, _iter0.size()));
        for (Map.Entry<List<Integer>, Set<Map<Double, String>>> _iter1 : _iter0.entrySet()) {
          oprot.writeListBegin(new TList(TType.I32, _iter1.getKey().size()));
        for (int _iter2 : _iter1.getKey()) {
          oprot.writeI32(_iter2);
        }
        oprot.writeListEnd();

          oprot.writeSetBegin(new TSet(TType.MAP, _iter1.getValue().size()));
        for (Map<Double, String> _iter2 : _iter1.getValue()) {
          oprot.writeMapBegin(new TMap(TType.DOUBLE, TType.STRING, _iter2.size()));
        for (Map.Entry<Double, String> _iter3 : _iter2.entrySet()) {
          oprot.writeDouble(_iter3.getKey());
          oprot.writeString(_iter3.getValue());
        }
        oprot.writeMapEnd();
        }
        oprot.writeSetEnd();
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }
    
}
