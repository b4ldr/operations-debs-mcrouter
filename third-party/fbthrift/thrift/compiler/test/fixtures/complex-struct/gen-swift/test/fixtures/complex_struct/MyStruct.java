/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

package test.fixtures.complex_struct;

import com.facebook.swift.codec.*;
import com.facebook.swift.codec.ThriftField.Requiredness;
import com.facebook.swift.codec.ThriftField.Recursiveness;
import com.google.common.collect.*;
import java.util.*;
import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.server.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;
import org.apache.thrift.meta_data.FieldMetaData;
import org.apache.thrift.meta_data.FieldValueMetaData;
import static com.google.common.base.MoreObjects.toStringHelper;
import static com.google.common.base.MoreObjects.ToStringHelper;

@SwiftGenerated
@ThriftStruct(value="MyStruct", builder=MyStruct.Builder.class)
public final class MyStruct {
    @ThriftConstructor
    public MyStruct(
        @ThriftField(value=1, name="MyIntField", requiredness=Requiredness.NONE) final long myIntField,
        @ThriftField(value=2, name="MyStringField", requiredness=Requiredness.NONE) final String myStringField,
        @ThriftField(value=3, name="MyDataField", requiredness=Requiredness.NONE) final test.fixtures.complex_struct.MyDataItem myDataField,
        @ThriftField(value=4, name="myEnum", requiredness=Requiredness.NONE) final test.fixtures.complex_struct.MyEnum myEnum,
        @ThriftField(value=5, name="MyBoolField", requiredness=Requiredness.NONE) final boolean myBoolField,
        @ThriftField(value=6, name="MyByteField", requiredness=Requiredness.NONE) final byte myByteField,
        @ThriftField(value=7, name="MyShortField", requiredness=Requiredness.NONE) final short myShortField,
        @ThriftField(value=8, name="MyLongField", requiredness=Requiredness.NONE) final long myLongField,
        @ThriftField(value=9, name="MyDoubleField", requiredness=Requiredness.NONE) final double myDoubleField,
        @ThriftField(value=10, name="lDouble", requiredness=Requiredness.NONE) final List<Double> lDouble,
        @ThriftField(value=11, name="lShort", requiredness=Requiredness.NONE) final List<Short> lShort,
        @ThriftField(value=12, name="lInteger", requiredness=Requiredness.NONE) final List<Integer> lInteger,
        @ThriftField(value=13, name="lLong", requiredness=Requiredness.NONE) final List<Long> lLong,
        @ThriftField(value=14, name="lString", requiredness=Requiredness.NONE) final List<String> lString,
        @ThriftField(value=15, name="lBool", requiredness=Requiredness.NONE) final List<Boolean> lBool,
        @ThriftField(value=16, name="lByte", requiredness=Requiredness.NONE) final List<Byte> lByte,
        @ThriftField(value=17, name="mShortString", requiredness=Requiredness.NONE) final Map<Short, String> mShortString,
        @ThriftField(value=18, name="mIntegerString", requiredness=Requiredness.NONE) final Map<Integer, String> mIntegerString,
        @ThriftField(value=19, name="mStringMyStruct", requiredness=Requiredness.NONE) final Map<String, test.fixtures.complex_struct.MyStruct> mStringMyStruct,
        @ThriftField(value=20, name="mStringBool", requiredness=Requiredness.NONE) final Map<String, Boolean> mStringBool,
        @ThriftField(value=21, name="mIntegerInteger", requiredness=Requiredness.NONE) final Map<Integer, Integer> mIntegerInteger,
        @ThriftField(value=22, name="mIntegerBool", requiredness=Requiredness.NONE) final Map<Integer, Boolean> mIntegerBool,
        @ThriftField(value=23, name="sShort", requiredness=Requiredness.NONE) final Set<Short> sShort,
        @ThriftField(value=24, name="sMyStruct", requiredness=Requiredness.NONE) final Set<test.fixtures.complex_struct.MyStruct> sMyStruct,
        @ThriftField(value=25, name="sLong", requiredness=Requiredness.NONE) final Set<Long> sLong,
        @ThriftField(value=26, name="sString", requiredness=Requiredness.NONE) final Set<String> sString,
        @ThriftField(value=27, name="sByte", requiredness=Requiredness.NONE) final Set<Byte> sByte
    ) {
        this.myIntField = myIntField;
        this.myStringField = myStringField;
        this.myDataField = myDataField;
        this.myEnum = myEnum;
        this.myBoolField = myBoolField;
        this.myByteField = myByteField;
        this.myShortField = myShortField;
        this.myLongField = myLongField;
        this.myDoubleField = myDoubleField;
        this.lDouble = lDouble;
        this.lShort = lShort;
        this.lInteger = lInteger;
        this.lLong = lLong;
        this.lString = lString;
        this.lBool = lBool;
        this.lByte = lByte;
        this.mShortString = mShortString;
        this.mIntegerString = mIntegerString;
        this.mStringMyStruct = mStringMyStruct;
        this.mStringBool = mStringBool;
        this.mIntegerInteger = mIntegerInteger;
        this.mIntegerBool = mIntegerBool;
        this.sShort = sShort;
        this.sMyStruct = sMyStruct;
        this.sLong = sLong;
        this.sString = sString;
        this.sByte = sByte;
    }
    
    @ThriftConstructor
    protected MyStruct() {
      this.myIntField = 0L;
      this.myStringField = null;
      this.myDataField = null;
      this.myEnum = null;
      this.myBoolField = false;
      this.myByteField = 0;
      this.myShortField = 0;
      this.myLongField = 0L;
      this.myDoubleField = 0.;
      this.lDouble = null;
      this.lShort = null;
      this.lInteger = null;
      this.lLong = null;
      this.lString = null;
      this.lBool = null;
      this.lByte = null;
      this.mShortString = null;
      this.mIntegerString = null;
      this.mStringMyStruct = null;
      this.mStringBool = null;
      this.mIntegerInteger = null;
      this.mIntegerBool = null;
      this.sShort = null;
      this.sMyStruct = null;
      this.sLong = null;
      this.sString = null;
      this.sByte = null;
    }
    
    public static class Builder {
        private long myIntField = 0L;
        private String myStringField = null;
        private test.fixtures.complex_struct.MyDataItem myDataField = null;
        private test.fixtures.complex_struct.MyEnum myEnum = null;
        private boolean myBoolField = false;
        private byte myByteField = 0;
        private short myShortField = 0;
        private long myLongField = 0L;
        private double myDoubleField = 0.;
        private List<Double> lDouble = null;
        private List<Short> lShort = null;
        private List<Integer> lInteger = null;
        private List<Long> lLong = null;
        private List<String> lString = null;
        private List<Boolean> lBool = null;
        private List<Byte> lByte = null;
        private Map<Short, String> mShortString = null;
        private Map<Integer, String> mIntegerString = null;
        private Map<String, test.fixtures.complex_struct.MyStruct> mStringMyStruct = null;
        private Map<String, Boolean> mStringBool = null;
        private Map<Integer, Integer> mIntegerInteger = null;
        private Map<Integer, Boolean> mIntegerBool = null;
        private Set<Short> sShort = null;
        private Set<test.fixtures.complex_struct.MyStruct> sMyStruct = null;
        private Set<Long> sLong = null;
        private Set<String> sString = null;
        private Set<Byte> sByte = null;
    
        @ThriftField(value=1, name="MyIntField", requiredness=Requiredness.NONE)
        public Builder setMyIntField(long myIntField) {
            this.myIntField = myIntField;
            return this;
        }
        
        public long getMyIntField() { return myIntField; }
    
            @ThriftField(value=2, name="MyStringField", requiredness=Requiredness.NONE)
        public Builder setMyStringField(String myStringField) {
            this.myStringField = myStringField;
            return this;
        }
        
        public String getMyStringField() { return myStringField; }
    
            @ThriftField(value=3, name="MyDataField", requiredness=Requiredness.NONE)
        public Builder setMyDataField(test.fixtures.complex_struct.MyDataItem myDataField) {
            this.myDataField = myDataField;
            return this;
        }
        
        public test.fixtures.complex_struct.MyDataItem getMyDataField() { return myDataField; }
    
            @ThriftField(value=4, name="myEnum", requiredness=Requiredness.NONE)
        public Builder setMyEnum(test.fixtures.complex_struct.MyEnum myEnum) {
            this.myEnum = myEnum;
            return this;
        }
        
        public test.fixtures.complex_struct.MyEnum getMyEnum() { return myEnum; }
    
            @ThriftField(value=5, name="MyBoolField", requiredness=Requiredness.NONE)
        public Builder setMyBoolField(boolean myBoolField) {
            this.myBoolField = myBoolField;
            return this;
        }
        
        public boolean isMyBoolField() { return myBoolField; }
    
            @ThriftField(value=6, name="MyByteField", requiredness=Requiredness.NONE)
        public Builder setMyByteField(byte myByteField) {
            this.myByteField = myByteField;
            return this;
        }
        
        public byte getMyByteField() { return myByteField; }
    
            @ThriftField(value=7, name="MyShortField", requiredness=Requiredness.NONE)
        public Builder setMyShortField(short myShortField) {
            this.myShortField = myShortField;
            return this;
        }
        
        public short getMyShortField() { return myShortField; }
    
            @ThriftField(value=8, name="MyLongField", requiredness=Requiredness.NONE)
        public Builder setMyLongField(long myLongField) {
            this.myLongField = myLongField;
            return this;
        }
        
        public long getMyLongField() { return myLongField; }
    
            @ThriftField(value=9, name="MyDoubleField", requiredness=Requiredness.NONE)
        public Builder setMyDoubleField(double myDoubleField) {
            this.myDoubleField = myDoubleField;
            return this;
        }
        
        public double getMyDoubleField() { return myDoubleField; }
    
            @ThriftField(value=10, name="lDouble", requiredness=Requiredness.NONE)
        public Builder setLDouble(List<Double> lDouble) {
            this.lDouble = lDouble;
            return this;
        }
        
        public List<Double> getLDouble() { return lDouble; }
    
            @ThriftField(value=11, name="lShort", requiredness=Requiredness.NONE)
        public Builder setLShort(List<Short> lShort) {
            this.lShort = lShort;
            return this;
        }
        
        public List<Short> getLShort() { return lShort; }
    
            @ThriftField(value=12, name="lInteger", requiredness=Requiredness.NONE)
        public Builder setLInteger(List<Integer> lInteger) {
            this.lInteger = lInteger;
            return this;
        }
        
        public List<Integer> getLInteger() { return lInteger; }
    
            @ThriftField(value=13, name="lLong", requiredness=Requiredness.NONE)
        public Builder setLLong(List<Long> lLong) {
            this.lLong = lLong;
            return this;
        }
        
        public List<Long> getLLong() { return lLong; }
    
            @ThriftField(value=14, name="lString", requiredness=Requiredness.NONE)
        public Builder setLString(List<String> lString) {
            this.lString = lString;
            return this;
        }
        
        public List<String> getLString() { return lString; }
    
            @ThriftField(value=15, name="lBool", requiredness=Requiredness.NONE)
        public Builder setLBool(List<Boolean> lBool) {
            this.lBool = lBool;
            return this;
        }
        
        public List<Boolean> getLBool() { return lBool; }
    
            @ThriftField(value=16, name="lByte", requiredness=Requiredness.NONE)
        public Builder setLByte(List<Byte> lByte) {
            this.lByte = lByte;
            return this;
        }
        
        public List<Byte> getLByte() { return lByte; }
    
            @ThriftField(value=17, name="mShortString", requiredness=Requiredness.NONE)
        public Builder setMShortString(Map<Short, String> mShortString) {
            this.mShortString = mShortString;
            return this;
        }
        
        public Map<Short, String> getMShortString() { return mShortString; }
    
            @ThriftField(value=18, name="mIntegerString", requiredness=Requiredness.NONE)
        public Builder setMIntegerString(Map<Integer, String> mIntegerString) {
            this.mIntegerString = mIntegerString;
            return this;
        }
        
        public Map<Integer, String> getMIntegerString() { return mIntegerString; }
    
            @ThriftField(value=19, name="mStringMyStruct", requiredness=Requiredness.NONE)
        public Builder setMStringMyStruct(Map<String, test.fixtures.complex_struct.MyStruct> mStringMyStruct) {
            this.mStringMyStruct = mStringMyStruct;
            return this;
        }
        
        public Map<String, test.fixtures.complex_struct.MyStruct> getMStringMyStruct() { return mStringMyStruct; }
    
            @ThriftField(value=20, name="mStringBool", requiredness=Requiredness.NONE)
        public Builder setMStringBool(Map<String, Boolean> mStringBool) {
            this.mStringBool = mStringBool;
            return this;
        }
        
        public Map<String, Boolean> getMStringBool() { return mStringBool; }
    
            @ThriftField(value=21, name="mIntegerInteger", requiredness=Requiredness.NONE)
        public Builder setMIntegerInteger(Map<Integer, Integer> mIntegerInteger) {
            this.mIntegerInteger = mIntegerInteger;
            return this;
        }
        
        public Map<Integer, Integer> getMIntegerInteger() { return mIntegerInteger; }
    
            @ThriftField(value=22, name="mIntegerBool", requiredness=Requiredness.NONE)
        public Builder setMIntegerBool(Map<Integer, Boolean> mIntegerBool) {
            this.mIntegerBool = mIntegerBool;
            return this;
        }
        
        public Map<Integer, Boolean> getMIntegerBool() { return mIntegerBool; }
    
            @ThriftField(value=23, name="sShort", requiredness=Requiredness.NONE)
        public Builder setSShort(Set<Short> sShort) {
            this.sShort = sShort;
            return this;
        }
        
        public Set<Short> getSShort() { return sShort; }
    
            @ThriftField(value=24, name="sMyStruct", requiredness=Requiredness.NONE)
        public Builder setSMyStruct(Set<test.fixtures.complex_struct.MyStruct> sMyStruct) {
            this.sMyStruct = sMyStruct;
            return this;
        }
        
        public Set<test.fixtures.complex_struct.MyStruct> getSMyStruct() { return sMyStruct; }
    
            @ThriftField(value=25, name="sLong", requiredness=Requiredness.NONE)
        public Builder setSLong(Set<Long> sLong) {
            this.sLong = sLong;
            return this;
        }
        
        public Set<Long> getSLong() { return sLong; }
    
            @ThriftField(value=26, name="sString", requiredness=Requiredness.NONE)
        public Builder setSString(Set<String> sString) {
            this.sString = sString;
            return this;
        }
        
        public Set<String> getSString() { return sString; }
    
            @ThriftField(value=27, name="sByte", requiredness=Requiredness.NONE)
        public Builder setSByte(Set<Byte> sByte) {
            this.sByte = sByte;
            return this;
        }
        
        public Set<Byte> getSByte() { return sByte; }
    
        public Builder() { }
        public Builder(MyStruct other) {
            this.myIntField = other.myIntField;
            this.myStringField = other.myStringField;
            this.myDataField = other.myDataField;
            this.myEnum = other.myEnum;
            this.myBoolField = other.myBoolField;
            this.myByteField = other.myByteField;
            this.myShortField = other.myShortField;
            this.myLongField = other.myLongField;
            this.myDoubleField = other.myDoubleField;
            this.lDouble = other.lDouble;
            this.lShort = other.lShort;
            this.lInteger = other.lInteger;
            this.lLong = other.lLong;
            this.lString = other.lString;
            this.lBool = other.lBool;
            this.lByte = other.lByte;
            this.mShortString = other.mShortString;
            this.mIntegerString = other.mIntegerString;
            this.mStringMyStruct = other.mStringMyStruct;
            this.mStringBool = other.mStringBool;
            this.mIntegerInteger = other.mIntegerInteger;
            this.mIntegerBool = other.mIntegerBool;
            this.sShort = other.sShort;
            this.sMyStruct = other.sMyStruct;
            this.sLong = other.sLong;
            this.sString = other.sString;
            this.sByte = other.sByte;
        }
    
        @ThriftConstructor
        public MyStruct build() {
            return new MyStruct (
                this.myIntField,
                this.myStringField,
                this.myDataField,
                this.myEnum,
                this.myBoolField,
                this.myByteField,
                this.myShortField,
                this.myLongField,
                this.myDoubleField,
                this.lDouble,
                this.lShort,
                this.lInteger,
                this.lLong,
                this.lString,
                this.lBool,
                this.lByte,
                this.mShortString,
                this.mIntegerString,
                this.mStringMyStruct,
                this.mStringBool,
                this.mIntegerInteger,
                this.mIntegerBool,
                this.sShort,
                this.sMyStruct,
                this.sLong,
                this.sString,
                this.sByte
            );
        }
    }
    
    private static final TStruct STRUCT_DESC = new TStruct("MyStruct");
    private final long myIntField;
    public static final int _MYINTFIELD = 1;
    private static final TField MY_INT_FIELD_FIELD_DESC = new TField("myIntField", TType.I64, (short)1);
    private final String myStringField;
    public static final int _MYSTRINGFIELD = 2;
    private static final TField MY_STRING_FIELD_FIELD_DESC = new TField("myStringField", TType.STRING, (short)2);
    private final test.fixtures.complex_struct.MyDataItem myDataField;
    public static final int _MYDATAFIELD = 3;
    private static final TField MY_DATA_FIELD_FIELD_DESC = new TField("myDataField", TType.STRUCT, (short)3);
    private final test.fixtures.complex_struct.MyEnum myEnum;
    public static final int _MYENUM = 4;
    private static final TField MY_ENUM_FIELD_DESC = new TField("myEnum", TType.I32, (short)4);
    private final boolean myBoolField;
    public static final int _MYBOOLFIELD = 5;
    private static final TField MY_BOOL_FIELD_FIELD_DESC = new TField("myBoolField", TType.BOOL, (short)5);
    private final byte myByteField;
    public static final int _MYBYTEFIELD = 6;
    private static final TField MY_BYTE_FIELD_FIELD_DESC = new TField("myByteField", TType.BYTE, (short)6);
    private final short myShortField;
    public static final int _MYSHORTFIELD = 7;
    private static final TField MY_SHORT_FIELD_FIELD_DESC = new TField("myShortField", TType.I16, (short)7);
    private final long myLongField;
    public static final int _MYLONGFIELD = 8;
    private static final TField MY_LONG_FIELD_FIELD_DESC = new TField("myLongField", TType.I64, (short)8);
    private final double myDoubleField;
    public static final int _MYDOUBLEFIELD = 9;
    private static final TField MY_DOUBLE_FIELD_FIELD_DESC = new TField("myDoubleField", TType.DOUBLE, (short)9);
    private final List<Double> lDouble;
    public static final int _LDOUBLE = 10;
    private static final TField L_DOUBLE_FIELD_DESC = new TField("lDouble", TType.LIST, (short)10);
    private final List<Short> lShort;
    public static final int _LSHORT = 11;
    private static final TField L_SHORT_FIELD_DESC = new TField("lShort", TType.LIST, (short)11);
    private final List<Integer> lInteger;
    public static final int _LINTEGER = 12;
    private static final TField L_INTEGER_FIELD_DESC = new TField("lInteger", TType.LIST, (short)12);
    private final List<Long> lLong;
    public static final int _LLONG = 13;
    private static final TField L_LONG_FIELD_DESC = new TField("lLong", TType.LIST, (short)13);
    private final List<String> lString;
    public static final int _LSTRING = 14;
    private static final TField L_STRING_FIELD_DESC = new TField("lString", TType.LIST, (short)14);
    private final List<Boolean> lBool;
    public static final int _LBOOL = 15;
    private static final TField L_BOOL_FIELD_DESC = new TField("lBool", TType.LIST, (short)15);
    private final List<Byte> lByte;
    public static final int _LBYTE = 16;
    private static final TField L_BYTE_FIELD_DESC = new TField("lByte", TType.LIST, (short)16);
    private final Map<Short, String> mShortString;
    public static final int _MSHORTSTRING = 17;
    private static final TField M_SHORT_STRING_FIELD_DESC = new TField("mShortString", TType.MAP, (short)17);
    private final Map<Integer, String> mIntegerString;
    public static final int _MINTEGERSTRING = 18;
    private static final TField M_INTEGER_STRING_FIELD_DESC = new TField("mIntegerString", TType.MAP, (short)18);
    private final Map<String, test.fixtures.complex_struct.MyStruct> mStringMyStruct;
    public static final int _MSTRINGMYSTRUCT = 19;
    private static final TField M_STRING_MY_STRUCT_FIELD_DESC = new TField("mStringMyStruct", TType.MAP, (short)19);
    private final Map<String, Boolean> mStringBool;
    public static final int _MSTRINGBOOL = 20;
    private static final TField M_STRING_BOOL_FIELD_DESC = new TField("mStringBool", TType.MAP, (short)20);
    private final Map<Integer, Integer> mIntegerInteger;
    public static final int _MINTEGERINTEGER = 21;
    private static final TField M_INTEGER_INTEGER_FIELD_DESC = new TField("mIntegerInteger", TType.MAP, (short)21);
    private final Map<Integer, Boolean> mIntegerBool;
    public static final int _MINTEGERBOOL = 22;
    private static final TField M_INTEGER_BOOL_FIELD_DESC = new TField("mIntegerBool", TType.MAP, (short)22);
    private final Set<Short> sShort;
    public static final int _SSHORT = 23;
    private static final TField S_SHORT_FIELD_DESC = new TField("sShort", TType.SET, (short)23);
    private final Set<test.fixtures.complex_struct.MyStruct> sMyStruct;
    public static final int _SMYSTRUCT = 24;
    private static final TField S_MY_STRUCT_FIELD_DESC = new TField("sMyStruct", TType.SET, (short)24);
    private final Set<Long> sLong;
    public static final int _SLONG = 25;
    private static final TField S_LONG_FIELD_DESC = new TField("sLong", TType.SET, (short)25);
    private final Set<String> sString;
    public static final int _SSTRING = 26;
    private static final TField S_STRING_FIELD_DESC = new TField("sString", TType.SET, (short)26);
    private final Set<Byte> sByte;
    public static final int _SBYTE = 27;
    private static final TField S_BYTE_FIELD_DESC = new TField("sByte", TType.SET, (short)27);

    
    @ThriftField(value=1, name="MyIntField", requiredness=Requiredness.NONE)
    public long getMyIntField() { return myIntField; }
        
    @ThriftField(value=2, name="MyStringField", requiredness=Requiredness.NONE)
    public String getMyStringField() { return myStringField; }
        
    @ThriftField(value=3, name="MyDataField", requiredness=Requiredness.NONE)
    public test.fixtures.complex_struct.MyDataItem getMyDataField() { return myDataField; }
        
    @ThriftField(value=4, name="myEnum", requiredness=Requiredness.NONE)
    public test.fixtures.complex_struct.MyEnum getMyEnum() { return myEnum; }
        
    @ThriftField(value=5, name="MyBoolField", requiredness=Requiredness.NONE)
    public boolean isMyBoolField() { return myBoolField; }
        
    @ThriftField(value=6, name="MyByteField", requiredness=Requiredness.NONE)
    public byte getMyByteField() { return myByteField; }
        
    @ThriftField(value=7, name="MyShortField", requiredness=Requiredness.NONE)
    public short getMyShortField() { return myShortField; }
        
    @ThriftField(value=8, name="MyLongField", requiredness=Requiredness.NONE)
    public long getMyLongField() { return myLongField; }
        
    @ThriftField(value=9, name="MyDoubleField", requiredness=Requiredness.NONE)
    public double getMyDoubleField() { return myDoubleField; }
        
    @ThriftField(value=10, name="lDouble", requiredness=Requiredness.NONE)
    public List<Double> getLDouble() { return lDouble; }
        
    @ThriftField(value=11, name="lShort", requiredness=Requiredness.NONE)
    public List<Short> getLShort() { return lShort; }
        
    @ThriftField(value=12, name="lInteger", requiredness=Requiredness.NONE)
    public List<Integer> getLInteger() { return lInteger; }
        
    @ThriftField(value=13, name="lLong", requiredness=Requiredness.NONE)
    public List<Long> getLLong() { return lLong; }
        
    @ThriftField(value=14, name="lString", requiredness=Requiredness.NONE)
    public List<String> getLString() { return lString; }
        
    @ThriftField(value=15, name="lBool", requiredness=Requiredness.NONE)
    public List<Boolean> getLBool() { return lBool; }
        
    @ThriftField(value=16, name="lByte", requiredness=Requiredness.NONE)
    public List<Byte> getLByte() { return lByte; }
        
    @ThriftField(value=17, name="mShortString", requiredness=Requiredness.NONE)
    public Map<Short, String> getMShortString() { return mShortString; }
        
    @ThriftField(value=18, name="mIntegerString", requiredness=Requiredness.NONE)
    public Map<Integer, String> getMIntegerString() { return mIntegerString; }
        
    @ThriftField(value=19, name="mStringMyStruct", requiredness=Requiredness.NONE)
    public Map<String, test.fixtures.complex_struct.MyStruct> getMStringMyStruct() { return mStringMyStruct; }
        
    @ThriftField(value=20, name="mStringBool", requiredness=Requiredness.NONE)
    public Map<String, Boolean> getMStringBool() { return mStringBool; }
        
    @ThriftField(value=21, name="mIntegerInteger", requiredness=Requiredness.NONE)
    public Map<Integer, Integer> getMIntegerInteger() { return mIntegerInteger; }
        
    @ThriftField(value=22, name="mIntegerBool", requiredness=Requiredness.NONE)
    public Map<Integer, Boolean> getMIntegerBool() { return mIntegerBool; }
        
    @ThriftField(value=23, name="sShort", requiredness=Requiredness.NONE)
    public Set<Short> getSShort() { return sShort; }
        
    @ThriftField(value=24, name="sMyStruct", requiredness=Requiredness.NONE)
    public Set<test.fixtures.complex_struct.MyStruct> getSMyStruct() { return sMyStruct; }
        
    @ThriftField(value=25, name="sLong", requiredness=Requiredness.NONE)
    public Set<Long> getSLong() { return sLong; }
        
    @ThriftField(value=26, name="sString", requiredness=Requiredness.NONE)
    public Set<String> getSString() { return sString; }
        
    @ThriftField(value=27, name="sByte", requiredness=Requiredness.NONE)
    public Set<Byte> getSByte() { return sByte; }
    
    @Override
    public String toString() {
        ToStringHelper helper = toStringHelper(this);
        helper.add("myIntField", myIntField);
        helper.add("myStringField", myStringField);
        helper.add("myDataField", myDataField);
        helper.add("myEnum", myEnum);
        helper.add("myBoolField", myBoolField);
        helper.add("myByteField", myByteField);
        helper.add("myShortField", myShortField);
        helper.add("myLongField", myLongField);
        helper.add("myDoubleField", myDoubleField);
        helper.add("lDouble", lDouble);
        helper.add("lShort", lShort);
        helper.add("lInteger", lInteger);
        helper.add("lLong", lLong);
        helper.add("lString", lString);
        helper.add("lBool", lBool);
        helper.add("lByte", lByte);
        helper.add("mShortString", mShortString);
        helper.add("mIntegerString", mIntegerString);
        helper.add("mStringMyStruct", mStringMyStruct);
        helper.add("mStringBool", mStringBool);
        helper.add("mIntegerInteger", mIntegerInteger);
        helper.add("mIntegerBool", mIntegerBool);
        helper.add("sShort", sShort);
        helper.add("sMyStruct", sMyStruct);
        helper.add("sLong", sLong);
        helper.add("sString", sString);
        helper.add("sByte", sByte);
        return helper.toString();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
    
        MyStruct other = (MyStruct)o;
    
        return
            Objects.equals(myIntField, other.myIntField) &&
            Objects.equals(myStringField, other.myStringField) &&
            Objects.equals(myDataField, other.myDataField) &&
            Objects.equals(myEnum, other.myEnum) &&
            Objects.equals(myBoolField, other.myBoolField) &&
            Objects.equals(myByteField, other.myByteField) &&
            Objects.equals(myShortField, other.myShortField) &&
            Objects.equals(myLongField, other.myLongField) &&
            Objects.equals(myDoubleField, other.myDoubleField) &&
            Objects.equals(lDouble, other.lDouble) &&
            Objects.equals(lShort, other.lShort) &&
            Objects.equals(lInteger, other.lInteger) &&
            Objects.equals(lLong, other.lLong) &&
            Objects.equals(lString, other.lString) &&
            Objects.equals(lBool, other.lBool) &&
            Objects.equals(lByte, other.lByte) &&
            Objects.equals(mShortString, other.mShortString) &&
            Objects.equals(mIntegerString, other.mIntegerString) &&
            Objects.equals(mStringMyStruct, other.mStringMyStruct) &&
            Objects.equals(mStringBool, other.mStringBool) &&
            Objects.equals(mIntegerInteger, other.mIntegerInteger) &&
            Objects.equals(mIntegerBool, other.mIntegerBool) &&
            Objects.equals(sShort, other.sShort) &&
            Objects.equals(sMyStruct, other.sMyStruct) &&
            Objects.equals(sLong, other.sLong) &&
            Objects.equals(sString, other.sString) &&
            Objects.equals(sByte, other.sByte) &&
            true;
    }
    
    @Override
    public int hashCode() {
        return Arrays.deepHashCode(new Object[] {
            myIntField,
            myStringField,
            myDataField,
            myEnum,
            myBoolField,
            myByteField,
            myShortField,
            myLongField,
            myDoubleField,
            lDouble,
            lShort,
            lInteger,
            lLong,
            lString,
            lBool,
            lByte,
            mShortString,
            mIntegerString,
            mStringMyStruct,
            mStringBool,
            mIntegerInteger,
            mIntegerBool,
            sShort,
            sMyStruct,
            sLong,
            sString,
            sByte
        });
    }
    
    
      // Currently, the read0 method cannot read metadatamap for JSON styled serialization.
      // Perhaps, it will be implemented in the future!
    public static MyStruct read0(TProtocol oprot) throws TException {
      TField __field;
      oprot.readStructBegin();
      MyStruct.Builder builder = new MyStruct.Builder();
      while (true) {
        __field = oprot.readFieldBegin();
        if (__field.type == TType.STOP) { break; }
        switch (__field.id) {
        case _MYINTFIELD:
          if (__field.type == TType.I64) {
            long myIntField = oprot.readI64();
            builder.setMyIntField(myIntField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYSTRINGFIELD:
          if (__field.type == TType.STRING) {
            String myStringField = oprot.readString();
            builder.setMyStringField(myStringField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYDATAFIELD:
          if (__field.type == TType.STRUCT) {
            test.fixtures.complex_struct.MyDataItem myDataField = test.fixtures.complex_struct.MyDataItem.read0(oprot);
            builder.setMyDataField(myDataField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYENUM:
          if (__field.type == TType.I32) {
            test.fixtures.complex_struct.MyEnum myEnum = test.fixtures.complex_struct.MyEnum.fromInteger(oprot.readI32());
            builder.setMyEnum(myEnum);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYBOOLFIELD:
          if (__field.type == TType.BOOL) {
            boolean myBoolField = oprot.readBool();
            builder.setMyBoolField(myBoolField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYBYTEFIELD:
          if (__field.type == TType.BYTE) {
            byte myByteField = oprot.readByte();
            builder.setMyByteField(myByteField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYSHORTFIELD:
          if (__field.type == TType.I16) {
            short myShortField = oprot.readI16();
            builder.setMyShortField(myShortField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYLONGFIELD:
          if (__field.type == TType.I64) {
            long myLongField = oprot.readI64();
            builder.setMyLongField(myLongField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MYDOUBLEFIELD:
          if (__field.type == TType.DOUBLE) {
            double myDoubleField = oprot.readDouble();
            builder.setMyDoubleField(myDoubleField);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LDOUBLE:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Double> _iter1 = new ArrayList<Double>(Math.max(0, 2*_list1.size));
            List<Double> lDouble = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                _iter1.add(oprot.readDouble());
            }
            oprot.readListEnd();
            builder.setLDouble(lDouble);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LSHORT:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Short> _iter1 = new ArrayList<Short>(Math.max(0, 2*_list1.size));
            List<Short> lShort = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                _iter1.add(oprot.readI16());
            }
            oprot.readListEnd();
            builder.setLShort(lShort);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LINTEGER:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Integer> _iter1 = new ArrayList<Integer>(Math.max(0, 2*_list1.size));
            List<Integer> lInteger = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                _iter1.add(oprot.readI32());
            }
            oprot.readListEnd();
            builder.setLInteger(lInteger);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LLONG:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Long> _iter1 = new ArrayList<Long>(Math.max(0, 2*_list1.size));
            List<Long> lLong = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                _iter1.add(oprot.readI64());
            }
            oprot.readListEnd();
            builder.setLLong(lLong);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LSTRING:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<String> _iter1 = new ArrayList<String>(Math.max(0, 2*_list1.size));
            List<String> lString = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                _iter1.add(oprot.readString());
            }
            oprot.readListEnd();
            builder.setLString(lString);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LBOOL:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Boolean> _iter1 = new ArrayList<Boolean>(Math.max(0, 2*_list1.size));
            List<Boolean> lBool = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                _iter1.add(oprot.readBool());
            }
            oprot.readListEnd();
            builder.setLBool(lBool);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _LBYTE:
          if (__field.type == TType.LIST) {
            TList _list1 = oprot.readListBegin();
            List<Byte> _iter1 = new ArrayList<Byte>(Math.max(0, 2*_list1.size));
            List<Byte> lByte = _iter1;
            if (_list1.size < 0) {  throw new TException("Using an unsupported List, size is less than zero.");}
            for (int _i1 = 0; _i1 < _list1.size; ++_i1) {
                _iter1.add(oprot.readByte());
            }
            oprot.readListEnd();
            builder.setLByte(lByte);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MSHORTSTRING:
          if (__field.type == TType.MAP) {
            Map<Short, String> mShortString;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Short, String> _iter1 = new HashMap<Short, String>(Math.max(0, 2*_map1.size));
            mShortString = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                short _key1 = oprot.readI16();
                String _val1 = oprot.readString();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMShortString(mShortString);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MINTEGERSTRING:
          if (__field.type == TType.MAP) {
            Map<Integer, String> mIntegerString;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Integer, String> _iter1 = new HashMap<Integer, String>(Math.max(0, 2*_map1.size));
            mIntegerString = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                int _key1 = oprot.readI32();
                String _val1 = oprot.readString();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMIntegerString(mIntegerString);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MSTRINGMYSTRUCT:
          if (__field.type == TType.MAP) {
            Map<String, test.fixtures.complex_struct.MyStruct> mStringMyStruct;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<String, test.fixtures.complex_struct.MyStruct> _iter1 = new HashMap<String, test.fixtures.complex_struct.MyStruct>(Math.max(0, 2*_map1.size));
            mStringMyStruct = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                String _key1 = oprot.readString();
                test.fixtures.complex_struct.MyStruct _val1 = test.fixtures.complex_struct.MyStruct.read0(oprot);
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMStringMyStruct(mStringMyStruct);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MSTRINGBOOL:
          if (__field.type == TType.MAP) {
            Map<String, Boolean> mStringBool;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<String, Boolean> _iter1 = new HashMap<String, Boolean>(Math.max(0, 2*_map1.size));
            mStringBool = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                String _key1 = oprot.readString();
                boolean _val1 = oprot.readBool();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMStringBool(mStringBool);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MINTEGERINTEGER:
          if (__field.type == TType.MAP) {
            Map<Integer, Integer> mIntegerInteger;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Integer, Integer> _iter1 = new HashMap<Integer, Integer>(Math.max(0, 2*_map1.size));
            mIntegerInteger = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                int _key1 = oprot.readI32();
                int _val1 = oprot.readI32();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMIntegerInteger(mIntegerInteger);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _MINTEGERBOOL:
          if (__field.type == TType.MAP) {
            Map<Integer, Boolean> mIntegerBool;
            {
            TMap _map1 = oprot.readMapBegin();
            Map<Integer, Boolean> _iter1 = new HashMap<Integer, Boolean>(Math.max(0, 2*_map1.size));
            mIntegerBool = _iter1;
            if (_map1.size < 0) {  throw new TException("Using an unsupported Map, size is less than zero.");}
            for (int _i1 = 0; _i1 < _map1.size; ++_i1) {
                int _key1 = oprot.readI32();
                boolean _val1 = oprot.readBool();
                _iter1.put(_key1, _val1);
            }
            }
            oprot.readMapEnd();
            builder.setMIntegerBool(mIntegerBool);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _SSHORT:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<Short> _iter1 = new HashSet<Short>(Math.max(0, 2*_set1.size));
            Set<Short> sShort = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                _iter1.add(oprot.readI16());
            }
            oprot.readSetEnd();
            builder.setSShort(sShort);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _SMYSTRUCT:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<test.fixtures.complex_struct.MyStruct> _iter1 = new HashSet<test.fixtures.complex_struct.MyStruct>(Math.max(0, 2*_set1.size));
            Set<test.fixtures.complex_struct.MyStruct> sMyStruct = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                _iter1.add(test.fixtures.complex_struct.MyStruct.read0(oprot));
            }
            oprot.readSetEnd();
            builder.setSMyStruct(sMyStruct);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _SLONG:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<Long> _iter1 = new HashSet<Long>(Math.max(0, 2*_set1.size));
            Set<Long> sLong = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                _iter1.add(oprot.readI64());
            }
            oprot.readSetEnd();
            builder.setSLong(sLong);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _SSTRING:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<String> _iter1 = new HashSet<String>(Math.max(0, 2*_set1.size));
            Set<String> sString = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                _iter1.add(oprot.readString());
            }
            oprot.readSetEnd();
            builder.setSString(sString);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        case _SBYTE:
          if (__field.type == TType.SET) {
            TSet _set1 = oprot.readSetBegin();
            Set<Byte> _iter1 = new HashSet<Byte>(Math.max(0, 2*_set1.size));
            Set<Byte> sByte = _iter1;
            if (_set1.size < 0) {  throw new TException("Using an unsupported Set, size is less than zero.");}
            for (int _i1 = 0; _i1 < _set1.size; ++_i1) {
                _iter1.add(oprot.readByte());
            }
            oprot.readSetEnd();
            builder.setSByte(sByte);
          } else {
            TProtocolUtil.skip(oprot, __field.type);
          }
          break;
        default:
          TProtocolUtil.skip(oprot, __field.type);
          break;
        }
        oprot.readFieldEnd();
      }
      oprot.readStructEnd();
      return builder.build();
    }
    
    public void write0(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MY_INT_FIELD_FIELD_DESC);
      oprot.writeI64(this.myIntField);
      oprot.writeFieldEnd();
      if (this.myStringField != null) {
        oprot.writeFieldBegin(MY_STRING_FIELD_FIELD_DESC);
        oprot.writeString(this.myStringField);
        oprot.writeFieldEnd();
      }
      if (this.myDataField != null) {
        oprot.writeFieldBegin(MY_DATA_FIELD_FIELD_DESC);
        this.myDataField.write0(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MY_ENUM_FIELD_DESC);
      oprot.writeI32(this.myEnum == null ? 0 : this.myEnum.getValue());
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MY_BOOL_FIELD_FIELD_DESC);
      oprot.writeBool(this.myBoolField);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MY_BYTE_FIELD_FIELD_DESC);
      oprot.writeByte(this.myByteField);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MY_SHORT_FIELD_FIELD_DESC);
      oprot.writeI16(this.myShortField);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MY_LONG_FIELD_FIELD_DESC);
      oprot.writeI64(this.myLongField);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MY_DOUBLE_FIELD_FIELD_DESC);
      oprot.writeDouble(this.myDoubleField);
      oprot.writeFieldEnd();
      if (this.lDouble != null) {
        oprot.writeFieldBegin(L_DOUBLE_FIELD_DESC);
        List<Double> _iter0 = this.lDouble;
        oprot.writeListBegin(new TList(TType.DOUBLE, _iter0.size()));
        for (double _iter1 : _iter0) {
          oprot.writeDouble(_iter1);
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.lShort != null) {
        oprot.writeFieldBegin(L_SHORT_FIELD_DESC);
        List<Short> _iter0 = this.lShort;
        oprot.writeListBegin(new TList(TType.I16, _iter0.size()));
        for (short _iter1 : _iter0) {
          oprot.writeI16(_iter1);
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.lInteger != null) {
        oprot.writeFieldBegin(L_INTEGER_FIELD_DESC);
        List<Integer> _iter0 = this.lInteger;
        oprot.writeListBegin(new TList(TType.I32, _iter0.size()));
        for (int _iter1 : _iter0) {
          oprot.writeI32(_iter1);
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.lLong != null) {
        oprot.writeFieldBegin(L_LONG_FIELD_DESC);
        List<Long> _iter0 = this.lLong;
        oprot.writeListBegin(new TList(TType.I64, _iter0.size()));
        for (long _iter1 : _iter0) {
          oprot.writeI64(_iter1);
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.lString != null) {
        oprot.writeFieldBegin(L_STRING_FIELD_DESC);
        List<String> _iter0 = this.lString;
        oprot.writeListBegin(new TList(TType.STRING, _iter0.size()));
        for (String _iter1 : _iter0) {
          oprot.writeString(_iter1);
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.lBool != null) {
        oprot.writeFieldBegin(L_BOOL_FIELD_DESC);
        List<Boolean> _iter0 = this.lBool;
        oprot.writeListBegin(new TList(TType.BOOL, _iter0.size()));
        for (boolean _iter1 : _iter0) {
          oprot.writeBool(_iter1);
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.lByte != null) {
        oprot.writeFieldBegin(L_BYTE_FIELD_DESC);
        List<Byte> _iter0 = this.lByte;
        oprot.writeListBegin(new TList(TType.BYTE, _iter0.size()));
        for (byte _iter1 : _iter0) {
          oprot.writeByte(_iter1);
        }
        oprot.writeListEnd();
        oprot.writeFieldEnd();
      }
      if (this.mShortString != null) {
        oprot.writeFieldBegin(M_SHORT_STRING_FIELD_DESC);
        Map<Short, String> _iter0 = this.mShortString;
        oprot.writeMapBegin(new TMap(TType.I16, TType.STRING, _iter0.size()));
        for (Map.Entry<Short, String> _iter1 : _iter0.entrySet()) {
          oprot.writeI16(_iter1.getKey());
          oprot.writeString(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mIntegerString != null) {
        oprot.writeFieldBegin(M_INTEGER_STRING_FIELD_DESC);
        Map<Integer, String> _iter0 = this.mIntegerString;
        oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, _iter0.size()));
        for (Map.Entry<Integer, String> _iter1 : _iter0.entrySet()) {
          oprot.writeI32(_iter1.getKey());
          oprot.writeString(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mStringMyStruct != null) {
        oprot.writeFieldBegin(M_STRING_MY_STRUCT_FIELD_DESC);
        Map<String, test.fixtures.complex_struct.MyStruct> _iter0 = this.mStringMyStruct;
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, _iter0.size()));
        for (Map.Entry<String, test.fixtures.complex_struct.MyStruct> _iter1 : _iter0.entrySet()) {
          oprot.writeString(_iter1.getKey());
          _iter1.getValue().write0(oprot);
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mStringBool != null) {
        oprot.writeFieldBegin(M_STRING_BOOL_FIELD_DESC);
        Map<String, Boolean> _iter0 = this.mStringBool;
        oprot.writeMapBegin(new TMap(TType.STRING, TType.BOOL, _iter0.size()));
        for (Map.Entry<String, Boolean> _iter1 : _iter0.entrySet()) {
          oprot.writeString(_iter1.getKey());
          oprot.writeBool(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mIntegerInteger != null) {
        oprot.writeFieldBegin(M_INTEGER_INTEGER_FIELD_DESC);
        Map<Integer, Integer> _iter0 = this.mIntegerInteger;
        oprot.writeMapBegin(new TMap(TType.I32, TType.I32, _iter0.size()));
        for (Map.Entry<Integer, Integer> _iter1 : _iter0.entrySet()) {
          oprot.writeI32(_iter1.getKey());
          oprot.writeI32(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.mIntegerBool != null) {
        oprot.writeFieldBegin(M_INTEGER_BOOL_FIELD_DESC);
        Map<Integer, Boolean> _iter0 = this.mIntegerBool;
        oprot.writeMapBegin(new TMap(TType.I32, TType.BOOL, _iter0.size()));
        for (Map.Entry<Integer, Boolean> _iter1 : _iter0.entrySet()) {
          oprot.writeI32(_iter1.getKey());
          oprot.writeBool(_iter1.getValue());
        }
        oprot.writeMapEnd();
        oprot.writeFieldEnd();
      }
      if (this.sShort != null) {
        oprot.writeFieldBegin(S_SHORT_FIELD_DESC);
        Set<Short> _iter0 = this.sShort;
        oprot.writeSetBegin(new TSet(TType.I16, _iter0.size()));
        for (short _iter1 : _iter0) {
          oprot.writeI16(_iter1);
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      if (this.sMyStruct != null) {
        oprot.writeFieldBegin(S_MY_STRUCT_FIELD_DESC);
        Set<test.fixtures.complex_struct.MyStruct> _iter0 = this.sMyStruct;
        oprot.writeSetBegin(new TSet(TType.STRUCT, _iter0.size()));
        for (test.fixtures.complex_struct.MyStruct _iter1 : _iter0) {
          _iter1.write0(oprot);
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      if (this.sLong != null) {
        oprot.writeFieldBegin(S_LONG_FIELD_DESC);
        Set<Long> _iter0 = this.sLong;
        oprot.writeSetBegin(new TSet(TType.I64, _iter0.size()));
        for (long _iter1 : _iter0) {
          oprot.writeI64(_iter1);
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      if (this.sString != null) {
        oprot.writeFieldBegin(S_STRING_FIELD_DESC);
        Set<String> _iter0 = this.sString;
        oprot.writeSetBegin(new TSet(TType.STRING, _iter0.size()));
        for (String _iter1 : _iter0) {
          oprot.writeString(_iter1);
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      if (this.sByte != null) {
        oprot.writeFieldBegin(S_BYTE_FIELD_DESC);
        Set<Byte> _iter0 = this.sByte;
        oprot.writeSetBegin(new TSet(TType.BYTE, _iter0.size()));
        for (byte _iter1 : _iter0) {
          oprot.writeByte(_iter1);
        }
        oprot.writeSetEnd();
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }
    
}
