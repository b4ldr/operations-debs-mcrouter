// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

pub use self::consts::*;
pub use self::errors::*;
pub use self::types::*;

pub mod consts {
    pub const myInt: i32 = 1337;

    pub const name: &str = "Mark Zuckerberg";

    lazy_static::lazy_static! {
        pub static ref states: Vec<std::collections::BTreeMap<String, i32>> = vec![
            {
                let mut map = std::collections::BTreeMap::new();
                map.insert("San Diego".to_owned(), 3211000);
                map.insert("Sacramento".to_owned(), 479600);
                map.insert("SF".to_owned(), 837400);
                map
            },
            {
                let mut map = std::collections::BTreeMap::new();
                map.insert("New York".to_owned(), 8406000);
                map.insert("Albany".to_owned(), 98400);
                map
            },
        ];
    }

    pub const x: f64 = 1.0;

    pub const y: f64 = 0.0;

    pub const z: f64 = 1000000000.0;

    pub const zeroDoubleValue: f64 = 0.0;

    pub const longDoubleValue: f64 = 2.59961000990301e-05;

    pub const my_company: crate::types::MyCompany = crate::types::Company::FACEBOOK;

    pub const foo: &str = "foo";

    pub const bar: crate::types::MyIntIdentifier = 42;

    lazy_static::lazy_static! {
        pub static ref mymap: crate::types::MyMapIdentifier = {
            let mut map = std::collections::BTreeMap::new();
            map.insert("keys".to_owned(), "values".to_owned());
            map
        };
    }

    lazy_static::lazy_static! {
        pub static ref instagram: crate::types::Internship = crate::types::Internship {
            weeks: 12,
            title: "Software Engineer".to_owned(),
            employer: Some(crate::types::Company::INSTAGRAM),
        };
    }

    lazy_static::lazy_static! {
        pub static ref partial_const: crate::types::Internship = crate::types::Internship {
            weeks: 8,
            title: "Some Job".to_owned(),
            employer: Default::default(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref kRanges: Vec<crate::types::Range> = vec![
            crate::types::Range {
                min: 1,
                max: 2,
            },
            crate::types::Range {
                min: 5,
                max: 6,
            },
        ];
    }

    lazy_static::lazy_static! {
        pub static ref internList: Vec<crate::types::Internship> = vec![
            crate::types::Internship {
                weeks: 12,
                title: "Software Engineer".to_owned(),
                employer: Some(crate::types::Company::INSTAGRAM),
            },
            crate::types::Internship {
                weeks: 10,
                title: "Sales Intern".to_owned(),
                employer: Some(crate::types::Company::FACEBOOK),
            },
        ];
    }

    lazy_static::lazy_static! {
        pub static ref pod_0: crate::types::struct1 = crate::types::struct1 {
            a: 1234567,
            b: "<uninitialized>".to_owned(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_1: crate::types::struct1 = crate::types::struct1 {
            a: 10,
            b: "foo".to_owned(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_2: crate::types::struct2 = crate::types::struct2 {
            a: 98,
            b: "gaz".to_owned(),
            c: crate::types::struct1 {
                a: 12,
                b: "bar".to_owned(),
            },
            d: vec![
                11,
                22,
                33,
            ],
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_3: crate::types::struct3 = crate::types::struct3 {
            a: "abc".to_owned(),
            b: 456,
            c: crate::types::struct2 {
                a: 888,
                b: Default::default(),
                c: crate::types::struct1 {
                    a: 1234567,
                    b: "gaz".to_owned(),
                },
                d: vec![
                    1,
                    2,
                    3,
                ],
            },
        };
    }

    lazy_static::lazy_static! {
        pub static ref u_1_1: crate::types::union1 = crate::types::union1::i(97);
    }

    lazy_static::lazy_static! {
        pub static ref u_1_2: crate::types::union1 = crate::types::union1::d(5.6);
    }

    lazy_static::lazy_static! {
        pub static ref u_1_3: crate::types::union1 = ;
    }

    lazy_static::lazy_static! {
        pub static ref u_2_1: crate::types::union2 = crate::types::union2::i(51);
    }

    lazy_static::lazy_static! {
        pub static ref u_2_2: crate::types::union2 = crate::types::union2::d(6.7);
    }

    lazy_static::lazy_static! {
        pub static ref u_2_3: crate::types::union2 = crate::types::union2::s(crate::types::struct1 {
                a: 8,
                b: "abacabb".to_owned(),
            });
    }

    lazy_static::lazy_static! {
        pub static ref u_2_4: crate::types::union2 = crate::types::union2::u(crate::types::union1::i(43));
    }

    lazy_static::lazy_static! {
        pub static ref u_2_5: crate::types::union2 = crate::types::union2::u(crate::types::union1::d(9.8));
    }

    lazy_static::lazy_static! {
        pub static ref u_2_6: crate::types::union2 = crate::types::union2::u();
    }

    pub const apostrophe: &str = "'";

    pub const tripleApostrophe: &str = "'''";

    pub const quotationMark: &str = "\"";

    pub const backslash: &str = "\\\\";

    pub const escaped_a: &str = "\\x61";

    lazy_static::lazy_static! {
        pub static ref char2ascii: std::collections::BTreeMap<String, i32> = {
            let mut map = std::collections::BTreeMap::new();
            map.insert("'".to_owned(), 39);
            map.insert("\"".to_owned(), 34);
            map.insert("\\\\".to_owned(), 92);
            map.insert("\\x61".to_owned(), 97);
            map
        };
    }

    lazy_static::lazy_static! {
        pub static ref escaped_strings: Vec<String> = vec![
            "\\x61".to_owned(),
            "\\xab".to_owned(),
            "\\x6a".to_owned(),
            "\\xa6".to_owned(),
            "\\x61yyy".to_owned(),
            "\\xabyyy".to_owned(),
            "\\x6ayyy".to_owned(),
            "\\xa6yyy".to_owned(),
            "zzz\\x61".to_owned(),
            "zzz\\xab".to_owned(),
            "zzz\\x6a".to_owned(),
            "zzz\\xa6".to_owned(),
            "zzz\\x61yyy".to_owned(),
            "zzz\\xabyyy".to_owned(),
            "zzz\\x6ayyy".to_owned(),
            "zzz\\xa6yyy".to_owned(),
        ];
    }

    pub const false_c: bool = false;

    pub const true_c: bool = true;

    pub const zero_byte: i8 = 0;

    pub const zero16: i16 = 0;

    pub const zero32: i32 = 0;

    pub const zero64: i64 = 0;

    pub const zero_dot_zero: f64 = 0.0;

    pub const empty_string: &str = "";

    lazy_static::lazy_static! {
        pub static ref empty_int_list: Vec<i32> = Vec::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_list: Vec<String> = Vec::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_int_set: std::collections::BTreeSet<i32> = std::collections::BTreeSet::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_set: std::collections::BTreeSet<String> = std::collections::BTreeSet::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_int_int_map: std::collections::BTreeMap<i32, i32> = std::collections::BTreeMap::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_int_string_map: std::collections::BTreeMap<i32, String> = std::collections::BTreeMap::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_int_map: std::collections::BTreeMap<String, i32> = std::collections::BTreeMap::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_string_map: std::collections::BTreeMap<String, String> = std::collections::BTreeMap::new();
    }
}

pub mod types {
    #![allow(clippy::redundant_closure)]

    use fbthrift::{
        Deserialize, GetTType, ProtocolReader, ProtocolWriter, Serialize, TType,
    };

    pub type MyCompany = crate::types::Company;

    pub type MyStringIdentifier = String;

    pub type MyIntIdentifier = i32;

    pub type MyMapIdentifier = std::collections::BTreeMap<String, String>;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Internship {
        pub weeks: i32,
        pub title: String,
        pub employer: Option<crate::types::Company>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Range {
        pub min: i32,
        pub max: i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct struct1 {
        pub a: i32,
        pub b: String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct2 {
        pub a: i32,
        pub b: String,
        pub c: crate::types::struct1,
        pub d: Vec<i32>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct3 {
        pub a: String,
        pub b: i32,
        pub c: crate::types::struct2,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum union1 {
        i(i32),
        d(f64),
        UnknownField(i32),
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum union2 {
        i(i32),
        d(f64),
        s(crate::types::struct1),
        u(crate::types::union1),
        UnknownField(i32),
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EmptyEnum(pub i32);

    impl EmptyEnum {
    }

    impl Default for EmptyEnum {
        fn default() -> Self {
            EmptyEnum(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a EmptyEnum> for i32 {
        #[inline]
        fn from(x: &'a EmptyEnum) -> i32 {
            x.0
        }
    }

    impl From<EmptyEnum> for i32 {
        #[inline]
        fn from(x: EmptyEnum) -> i32 {
            x.0
        }
    }

    impl From<i32> for EmptyEnum {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for EmptyEnum {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}", self.0)
        }
    }

    impl std::fmt::Debug for EmptyEnum {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "EmptyEnum::{}", self)
        }
    }

    impl std::str::FromStr for EmptyEnum {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                _ => anyhow::bail!("Unable to parse {} as EmptyEnum", string),
            }
        }
    }

    impl GetTType for EmptyEnum {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for EmptyEnum {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for EmptyEnum {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(EmptyEnum::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct City(pub i32);

    impl City {
        pub const NYC: Self = City(0i32);
        pub const MPK: Self = City(1i32);
        pub const SEA: Self = City(2i32);
        pub const LON: Self = City(3i32);
    }

    impl Default for City {
        fn default() -> Self {
            City(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a City> for i32 {
        #[inline]
        fn from(x: &'a City) -> i32 {
            x.0
        }
    }

    impl From<City> for i32 {
        #[inline]
        fn from(x: City) -> i32 {
            x.0
        }
    }

    impl From<i32> for City {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for City {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                City::NYC => "NYC",
                City::MPK => "MPK",
                City::SEA => "SEA",
                City::LON => "LON",
                City(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for City {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "City::{}", self)
        }
    }

    impl std::str::FromStr for City {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "NYC" => Ok(City::NYC),
                "MPK" => Ok(City::MPK),
                "SEA" => Ok(City::SEA),
                "LON" => Ok(City::LON),
                _ => anyhow::bail!("Unable to parse {} as City", string),
            }
        }
    }

    impl GetTType for City {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for City {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for City {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(City::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct Company(pub i32);

    impl Company {
        pub const FACEBOOK: Self = Company(0i32);
        pub const WHATSAPP: Self = Company(1i32);
        pub const OCULUS: Self = Company(2i32);
        pub const INSTAGRAM: Self = Company(3i32);
    }

    impl Default for Company {
        fn default() -> Self {
            Company(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a Company> for i32 {
        #[inline]
        fn from(x: &'a Company) -> i32 {
            x.0
        }
    }

    impl From<Company> for i32 {
        #[inline]
        fn from(x: Company) -> i32 {
            x.0
        }
    }

    impl From<i32> for Company {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for Company {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                Company::FACEBOOK => "FACEBOOK",
                Company::WHATSAPP => "WHATSAPP",
                Company::OCULUS => "OCULUS",
                Company::INSTAGRAM => "INSTAGRAM",
                Company(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for Company {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "Company::{}", self)
        }
    }

    impl std::str::FromStr for Company {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "FACEBOOK" => Ok(Company::FACEBOOK),
                "WHATSAPP" => Ok(Company::WHATSAPP),
                "OCULUS" => Ok(Company::OCULUS),
                "INSTAGRAM" => Ok(Company::INSTAGRAM),
                _ => anyhow::bail!("Unable to parse {} as Company", string),
            }
        }
    }

    impl GetTType for Company {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for Company {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for Company {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(Company::from(p.read_i32()?))
        }
    }





    impl Default for self::Internship {
        fn default() -> Self {
            Self {
                weeks: Default::default(),
                title: Default::default(),
                employer: None,
            }
        }
    }

    impl GetTType for self::Internship {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::Internship {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Internship");
            p.write_field_begin("weeks", TType::I32, 1);
            Serialize::write(&self.weeks, p);
            p.write_field_end();
            p.write_field_begin("title", TType::String, 2);
            Serialize::write(&self.title, p);
            p.write_field_end();
            if let Some(some) = &self.employer {
                p.write_field_begin("employer", TType::I32, 3);
                Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::Internship {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_weeks = None;
            let mut field_title = None;
            let mut field_employer = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_weeks = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_title = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_employer = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                weeks: field_weeks.unwrap_or_default(),
                title: field_title.unwrap_or_default(),
                employer: field_employer,
            })
        }
    }


    impl Default for self::Range {
        fn default() -> Self {
            Self {
                min: Default::default(),
                max: Default::default(),
            }
        }
    }

    impl GetTType for self::Range {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::Range {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Range");
            p.write_field_begin("min", TType::I32, 1);
            Serialize::write(&self.min, p);
            p.write_field_end();
            p.write_field_begin("max", TType::I32, 2);
            Serialize::write(&self.max, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::Range {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_min = None;
            let mut field_max = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_min = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_max = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                min: field_min.unwrap_or_default(),
                max: field_max.unwrap_or_default(),
            })
        }
    }


    impl Default for self::struct1 {
        fn default() -> Self {
            Self {
                a: 1234567,
                b: "<uninitialized>".to_owned(),
            }
        }
    }

    impl GetTType for self::struct1 {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::struct1 {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct1");
            p.write_field_begin("a", TType::I32, 1);
            Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", TType::String, 2);
            Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::struct1 {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_a = None;
            let mut field_b = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_a = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_b = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                a: field_a.unwrap_or_else(|| 1234567),
                b: field_b.unwrap_or_else(|| "<uninitialized>".to_owned()),
            })
        }
    }


    impl Default for self::struct2 {
        fn default() -> Self {
            Self {
                a: Default::default(),
                b: Default::default(),
                c: Default::default(),
                d: Default::default(),
            }
        }
    }

    impl GetTType for self::struct2 {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::struct2 {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct2");
            p.write_field_begin("a", TType::I32, 1);
            Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", TType::String, 2);
            Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_begin("c", TType::Struct, 3);
            Serialize::write(&self.c, p);
            p.write_field_end();
            p.write_field_begin("d", TType::List, 4);
            Serialize::write(&self.d, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::struct2 {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_a = None;
            let mut field_b = None;
            let mut field_c = None;
            let mut field_d = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_a = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_b = Some(Deserialize::read(p)?),
                    (TType::Struct, 3) => field_c = Some(Deserialize::read(p)?),
                    (TType::List, 4) => field_d = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b.unwrap_or_default(),
                c: field_c.unwrap_or_default(),
                d: field_d.unwrap_or_default(),
            })
        }
    }


    impl Default for self::struct3 {
        fn default() -> Self {
            Self {
                a: Default::default(),
                b: Default::default(),
                c: Default::default(),
            }
        }
    }

    impl GetTType for self::struct3 {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::struct3 {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct3");
            p.write_field_begin("a", TType::String, 1);
            Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", TType::I32, 2);
            Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_begin("c", TType::Struct, 3);
            Serialize::write(&self.c, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::struct3 {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_a = None;
            let mut field_b = None;
            let mut field_c = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_a = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_b = Some(Deserialize::read(p)?),
                    (TType::Struct, 3) => field_c = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b.unwrap_or_default(),
                c: field_c.unwrap_or_default(),
            })
        }
    }



    impl Default for union1 {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl GetTType for union1 {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for union1 {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("union1");
            match self {
                union1::i(inner) => {
                    p.write_field_begin("i", TType::I32, 1);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                union1::d(inner) => {
                    p.write_field_begin("d", TType::Double, 2);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                union1::UnknownField(x) => {
                    p.write_field_begin("UnknownField", TType::I32, *x as i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for union1 {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32, once) {
                    (TType::Stop, _, _) => break,
                    (TType::I32, 1, false) => {
                        once = true;
                        alt = Some(union1::i(Deserialize::read(p)?));
                    }
                    (TType::Double, 2, false) => {
                        once = true;
                        alt = Some(union1::d(Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return Err(From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "union1",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(alt.unwrap_or_default())
        }
    }


    impl Default for union2 {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl GetTType for union2 {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for union2 {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("union2");
            match self {
                union2::i(inner) => {
                    p.write_field_begin("i", TType::I32, 1);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::d(inner) => {
                    p.write_field_begin("d", TType::Double, 2);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::s(inner) => {
                    p.write_field_begin("s", TType::Struct, 3);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::u(inner) => {
                    p.write_field_begin("u", TType::Struct, 4);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::UnknownField(x) => {
                    p.write_field_begin("UnknownField", TType::I32, *x as i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for union2 {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32, once) {
                    (TType::Stop, _, _) => break,
                    (TType::I32, 1, false) => {
                        once = true;
                        alt = Some(union2::i(Deserialize::read(p)?));
                    }
                    (TType::Double, 2, false) => {
                        once = true;
                        alt = Some(union2::d(Deserialize::read(p)?));
                    }
                    (TType::Struct, 3, false) => {
                        once = true;
                        alt = Some(union2::s(Deserialize::read(p)?));
                    }
                    (TType::Struct, 4, false) => {
                        once = true;
                        alt = Some(union2::u(Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return Err(From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "union2",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(alt.unwrap_or_default())
        }
    }
}

pub mod errors {
}
