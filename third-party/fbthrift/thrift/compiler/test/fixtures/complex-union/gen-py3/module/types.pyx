#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import (
    NOTSET as __NOTSET,
    NumberType as __NumberType,
    StructSpec as __StructSpec,
    ListSpec as __ListSpec,
    SetSpec as __SetSpec,
    MapSpec as __MapSpec,
    FieldSpec as __FieldSpec,
    StructType as __StructType,
    Qualifier as __Qualifier,
)
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
    default_inst,
)
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol as __Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import types as _py_types
import itertools
from collections.abc import Sequence, Set, Mapping, Iterable
import warnings
import weakref as __weakref
import builtins as _builtins



cdef object __ComplexUnion_Union_TypeEnumMembers = None


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ComplexUnion_Union_TypeMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __ComplexUnion_Union_TypeEnumMembers:
            return value

        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return __ComplexUnionType.EMPTY
            elif cvalue == 1:
                return __ComplexUnionType.intValue
            elif cvalue == 5:
                return __ComplexUnionType.stringValue
            elif cvalue == 2:
                return __ComplexUnionType.intListValue
            elif cvalue == 3:
                return __ComplexUnionType.stringListValue
            elif cvalue == 9:
                return __ComplexUnionType.typedefValue
            elif cvalue == 14:
                return __ComplexUnionType.stringRef

        raise ValueError(f'{value} is not a valid ComplexUnion.Type')

    def __getitem__(cls, name):
        if name == "EMPTY":
            return __ComplexUnionType.EMPTY
        elif name == "intValue":
            return __ComplexUnionType.intValue
        elif name == "stringValue":
            return __ComplexUnionType.stringValue
        elif name == "intListValue":
            return __ComplexUnionType.intListValue
        elif name == "stringListValue":
            return __ComplexUnionType.stringListValue
        elif name == "typedefValue":
            return __ComplexUnionType.typedefValue
        elif name == "stringRef":
            return __ComplexUnionType.stringRef
        raise KeyError(name)

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__', 'EMPTY',
            'intValue',
            'stringValue',
            'intListValue',
            'stringListValue',
            'typedefValue',
            'stringRef',
        ]

    @property
    def __members__(cls):
        return {m.name: m for m in cls}

    def __iter__(cls):
        yield __ComplexUnionType.EMPTY
        yield __ComplexUnionType.intValue
        yield __ComplexUnionType.stringValue
        yield __ComplexUnionType.intListValue
        yield __ComplexUnionType.stringListValue
        yield __ComplexUnionType.typedefValue
        yield __ComplexUnionType.stringRef

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __ComplexUnion_Union_TypeEnumMembers

    def __len__(cls):
        return 6+1  # For Empty


@__cython.final
@__cython.auto_pickle(False)
cdef class __ComplexUnionType(thrift.py3.types.CompiledEnum):
    EMPTY = __ComplexUnionType.__new__(__ComplexUnionType, 0, "EMPTY")
    intValue = __ComplexUnionType.__new__(__ComplexUnionType, 1, "intValue")
    stringValue = __ComplexUnionType.__new__(__ComplexUnionType, 5, "stringValue")
    intListValue = __ComplexUnionType.__new__(__ComplexUnionType, 2, "intListValue")
    stringListValue = __ComplexUnionType.__new__(__ComplexUnionType, 3, "stringListValue")
    typedefValue = __ComplexUnionType.__new__(__ComplexUnionType, 9, "typedefValue")
    stringRef = __ComplexUnionType.__new__(__ComplexUnionType, 14, "stringRef")

    def __cinit__(self, value, name):
        if __ComplexUnion_Union_TypeEnumMembers is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"ComplexUnion.Type.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, __ComplexUnionType):
            warnings.warn(f"comparison not supported between instances of { __ComplexUnionType } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return __ComplexUnionType, (self.value,)

__SetMetaClass(<PyTypeObject*> __ComplexUnionType, <PyTypeObject*> __ComplexUnion_Union_TypeMeta)
__ComplexUnion_Union_TypeEnumMembers = set(__ComplexUnionType)



cdef object __ListUnion_Union_TypeEnumMembers = None


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ListUnion_Union_TypeMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __ListUnion_Union_TypeEnumMembers:
            return value

        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return __ListUnionType.EMPTY
            elif cvalue == 2:
                return __ListUnionType.intListValue
            elif cvalue == 3:
                return __ListUnionType.stringListValue

        raise ValueError(f'{value} is not a valid ListUnion.Type')

    def __getitem__(cls, name):
        if name == "EMPTY":
            return __ListUnionType.EMPTY
        elif name == "intListValue":
            return __ListUnionType.intListValue
        elif name == "stringListValue":
            return __ListUnionType.stringListValue
        raise KeyError(name)

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__', 'EMPTY',
            'intListValue',
            'stringListValue',
        ]

    @property
    def __members__(cls):
        return {m.name: m for m in cls}

    def __iter__(cls):
        yield __ListUnionType.EMPTY
        yield __ListUnionType.intListValue
        yield __ListUnionType.stringListValue

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __ListUnion_Union_TypeEnumMembers

    def __len__(cls):
        return 2+1  # For Empty


@__cython.final
@__cython.auto_pickle(False)
cdef class __ListUnionType(thrift.py3.types.CompiledEnum):
    EMPTY = __ListUnionType.__new__(__ListUnionType, 0, "EMPTY")
    intListValue = __ListUnionType.__new__(__ListUnionType, 2, "intListValue")
    stringListValue = __ListUnionType.__new__(__ListUnionType, 3, "stringListValue")

    def __cinit__(self, value, name):
        if __ListUnion_Union_TypeEnumMembers is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"ListUnion.Type.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, __ListUnionType):
            warnings.warn(f"comparison not supported between instances of { __ListUnionType } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return __ListUnionType, (self.value,)

__SetMetaClass(<PyTypeObject*> __ListUnionType, <PyTypeObject*> __ListUnion_Union_TypeMeta)
__ListUnion_Union_TypeEnumMembers = set(__ListUnionType)



cdef object __DataUnion_Union_TypeEnumMembers = None


@__cython.internal
@__cython.auto_pickle(False)
cdef class __DataUnion_Union_TypeMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __DataUnion_Union_TypeEnumMembers:
            return value

        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return __DataUnionType.EMPTY
            elif cvalue == 1:
                return __DataUnionType.binaryData
            elif cvalue == 2:
                return __DataUnionType.stringData

        raise ValueError(f'{value} is not a valid DataUnion.Type')

    def __getitem__(cls, name):
        if name == "EMPTY":
            return __DataUnionType.EMPTY
        elif name == "binaryData":
            return __DataUnionType.binaryData
        elif name == "stringData":
            return __DataUnionType.stringData
        raise KeyError(name)

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__', 'EMPTY',
            'binaryData',
            'stringData',
        ]

    @property
    def __members__(cls):
        return {m.name: m for m in cls}

    def __iter__(cls):
        yield __DataUnionType.EMPTY
        yield __DataUnionType.binaryData
        yield __DataUnionType.stringData

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __DataUnion_Union_TypeEnumMembers

    def __len__(cls):
        return 2+1  # For Empty


@__cython.final
@__cython.auto_pickle(False)
cdef class __DataUnionType(thrift.py3.types.CompiledEnum):
    EMPTY = __DataUnionType.__new__(__DataUnionType, 0, "EMPTY")
    binaryData = __DataUnionType.__new__(__DataUnionType, 1, "binaryData")
    stringData = __DataUnionType.__new__(__DataUnionType, 2, "stringData")

    def __cinit__(self, value, name):
        if __DataUnion_Union_TypeEnumMembers is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"DataUnion.Type.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, __DataUnionType):
            warnings.warn(f"comparison not supported between instances of { __DataUnionType } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return __DataUnionType, (self.value,)

__SetMetaClass(<PyTypeObject*> __DataUnionType, <PyTypeObject*> __DataUnion_Union_TypeMeta)
__DataUnion_Union_TypeEnumMembers = set(__DataUnionType)



cdef object __ValUnion_Union_TypeEnumMembers = None


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ValUnion_Union_TypeMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __ValUnion_Union_TypeEnumMembers:
            return value

        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return __ValUnionType.EMPTY
            elif cvalue == 1:
                return __ValUnionType.v1
            elif cvalue == 2:
                return __ValUnionType.v2

        raise ValueError(f'{value} is not a valid ValUnion.Type')

    def __getitem__(cls, name):
        if name == "EMPTY":
            return __ValUnionType.EMPTY
        elif name == "v1":
            return __ValUnionType.v1
        elif name == "v2":
            return __ValUnionType.v2
        raise KeyError(name)

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__', 'EMPTY',
            'v1',
            'v2',
        ]

    @property
    def __members__(cls):
        return {m.name: m for m in cls}

    def __iter__(cls):
        yield __ValUnionType.EMPTY
        yield __ValUnionType.v1
        yield __ValUnionType.v2

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __ValUnion_Union_TypeEnumMembers

    def __len__(cls):
        return 2+1  # For Empty


@__cython.final
@__cython.auto_pickle(False)
cdef class __ValUnionType(thrift.py3.types.CompiledEnum):
    EMPTY = __ValUnionType.__new__(__ValUnionType, 0, "EMPTY")
    v1 = __ValUnionType.__new__(__ValUnionType, 1, "v1")
    v2 = __ValUnionType.__new__(__ValUnionType, 2, "v2")

    def __cinit__(self, value, name):
        if __ValUnion_Union_TypeEnumMembers is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"ValUnion.Type.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, __ValUnionType):
            warnings.warn(f"comparison not supported between instances of { __ValUnionType } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return __ValUnionType, (self.value,)

__SetMetaClass(<PyTypeObject*> __ValUnionType, <PyTypeObject*> __ValUnion_Union_TypeMeta)
__ValUnion_Union_TypeEnumMembers = set(__ValUnionType)



cdef object __VirtualComplexUnion_Union_TypeEnumMembers = None


@__cython.internal
@__cython.auto_pickle(False)
cdef class __VirtualComplexUnion_Union_TypeMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __VirtualComplexUnion_Union_TypeEnumMembers:
            return value

        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return __VirtualComplexUnionType.EMPTY
            elif cvalue == 1:
                return __VirtualComplexUnionType.thingOne
            elif cvalue == 2:
                return __VirtualComplexUnionType.thingTwo

        raise ValueError(f'{value} is not a valid VirtualComplexUnion.Type')

    def __getitem__(cls, name):
        if name == "EMPTY":
            return __VirtualComplexUnionType.EMPTY
        elif name == "thingOne":
            return __VirtualComplexUnionType.thingOne
        elif name == "thingTwo":
            return __VirtualComplexUnionType.thingTwo
        raise KeyError(name)

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__', 'EMPTY',
            'thingOne',
            'thingTwo',
        ]

    @property
    def __members__(cls):
        return {m.name: m for m in cls}

    def __iter__(cls):
        yield __VirtualComplexUnionType.EMPTY
        yield __VirtualComplexUnionType.thingOne
        yield __VirtualComplexUnionType.thingTwo

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __VirtualComplexUnion_Union_TypeEnumMembers

    def __len__(cls):
        return 2+1  # For Empty


@__cython.final
@__cython.auto_pickle(False)
cdef class __VirtualComplexUnionType(thrift.py3.types.CompiledEnum):
    EMPTY = __VirtualComplexUnionType.__new__(__VirtualComplexUnionType, 0, "EMPTY")
    thingOne = __VirtualComplexUnionType.__new__(__VirtualComplexUnionType, 1, "thingOne")
    thingTwo = __VirtualComplexUnionType.__new__(__VirtualComplexUnionType, 2, "thingTwo")

    def __cinit__(self, value, name):
        if __VirtualComplexUnion_Union_TypeEnumMembers is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"VirtualComplexUnion.Type.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, __VirtualComplexUnionType):
            warnings.warn(f"comparison not supported between instances of { __VirtualComplexUnionType } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return __VirtualComplexUnionType, (self.value,)

__SetMetaClass(<PyTypeObject*> __VirtualComplexUnionType, <PyTypeObject*> __VirtualComplexUnion_Union_TypeMeta)
__VirtualComplexUnion_Union_TypeEnumMembers = set(__VirtualComplexUnionType)



cdef object __NonCopyableUnion_Union_TypeEnumMembers = None


@__cython.internal
@__cython.auto_pickle(False)
cdef class __NonCopyableUnion_Union_TypeMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __NonCopyableUnion_Union_TypeEnumMembers:
            return value

        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return __NonCopyableUnionType.EMPTY
            elif cvalue == 1:
                return __NonCopyableUnionType.s

        raise ValueError(f'{value} is not a valid NonCopyableUnion.Type')

    def __getitem__(cls, name):
        if name == "EMPTY":
            return __NonCopyableUnionType.EMPTY
        elif name == "s":
            return __NonCopyableUnionType.s
        raise KeyError(name)

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__', 'EMPTY',
            's',
        ]

    @property
    def __members__(cls):
        return {m.name: m for m in cls}

    def __iter__(cls):
        yield __NonCopyableUnionType.EMPTY
        yield __NonCopyableUnionType.s

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __NonCopyableUnion_Union_TypeEnumMembers

    def __len__(cls):
        return 1+1  # For Empty


@__cython.final
@__cython.auto_pickle(False)
cdef class __NonCopyableUnionType(thrift.py3.types.CompiledEnum):
    EMPTY = __NonCopyableUnionType.__new__(__NonCopyableUnionType, 0, "EMPTY")
    s = __NonCopyableUnionType.__new__(__NonCopyableUnionType, 1, "s")

    def __cinit__(self, value, name):
        if __NonCopyableUnion_Union_TypeEnumMembers is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"NonCopyableUnion.Type.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, __NonCopyableUnionType):
            warnings.warn(f"comparison not supported between instances of { __NonCopyableUnionType } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return __NonCopyableUnionType, (self.value,)

__SetMetaClass(<PyTypeObject*> __NonCopyableUnionType, <PyTypeObject*> __NonCopyableUnion_Union_TypeMeta)
__NonCopyableUnion_Union_TypeEnumMembers = set(__NonCopyableUnionType)




@__cython.auto_pickle(False)
cdef class ComplexUnion(thrift.py3.types.Union):
    Type = __ComplexUnionType

    def __init__(
        self, *,
        intValue=None,
        str stringValue=None,
        intListValue=None,
        stringListValue=None,
        typedefValue=None,
        str stringRef=None
    ):
        if intValue is not None:
            if not isinstance(intValue, int):
                raise TypeError(f'intValue is not a { int !r}.')
            intValue = <cint64_t> intValue

        self._cpp_obj = move(ComplexUnion._make_instance(
          NULL,
          intValue,
          stringValue,
          intListValue,
          stringListValue,
          typedefValue,
          stringRef,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return ComplexUnion()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <cint64_t> value
                    return ComplexUnion(intValue=value)
                except OverflowError:
                    pass
        if isinstance(value, str):
            return ComplexUnion(stringValue=value)
        if isinstance(value, List__i64):
            return ComplexUnion(intListValue=value)
        if isinstance(value, List__string):
            return ComplexUnion(stringListValue=value)
        if isinstance(value, Map__i16_string):
            return ComplexUnion(typedefValue=value)
        if isinstance(value, str):
            return ComplexUnion(stringRef=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cComplexUnion] _make_instance(
        cComplexUnion* base_instance,
        object intValue,
        str stringValue,
        object intListValue,
        object stringListValue,
        object typedefValue,
        str stringRef
    ) except *:
        cdef unique_ptr[cComplexUnion] c_inst = make_unique[cComplexUnion]()
        cdef bint any_set = False
        if intValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_intValue(intValue)
            any_set = True
        if stringValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringValue(stringValue.encode('UTF-8'))
            any_set = True
        if intListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_intListValue(<vector[cint64_t]>deref(List__i64(intListValue)._cpp_obj))
            any_set = True
        if stringListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringListValue(<vector[string]>deref(List__string(stringListValue)._cpp_obj))
            any_set = True
        if typedefValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_typedefValue(<cmap[cint16_t,string]>deref(Map__i16_string(typedefValue)._cpp_obj))
            any_set = True
        if stringRef is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringRef(string(deref((<str?>stringRef)._cpp_obj)))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type is not __ComplexUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cComplexUnion] cpp_obj):
        inst = <ComplexUnion>ComplexUnion.__new__(ComplexUnion)
        inst._cpp_obj = move_shared(cpp_obj)
        inst._load_cache()
        return inst

    @property
    def intValue(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not intValue')
        return self.value

    @property
    def stringValue(self):
        if self.type.value != 5:
            raise TypeError(f'Union contains a value of type {self.type.name}, not stringValue')
        return self.value

    @property
    def intListValue(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not intListValue')
        return self.value

    @property
    def stringListValue(self):
        if self.type.value != 3:
            raise TypeError(f'Union contains a value of type {self.type.name}, not stringListValue')
        return self.value

    @property
    def typedefValue(self):
        if self.type.value != 9:
            raise TypeError(f'Union contains a value of type {self.type.name}, not typedefValue')
        return self.value

    @property
    def stringRef(self):
        if self.type.value != 14:
            raise TypeError(f'Union contains a value of type {self.type.name}, not stringRef')
        return self.value


    def __hash__(ComplexUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(ComplexUnion self):
        return f'ComplexUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(ComplexUnion self):
        self.type = ComplexUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = deref(self._cpp_obj).get_intValue()
        elif type == 5:
            self.value = bytes(deref(self._cpp_obj).get_stringValue()).decode('UTF-8')
        elif type == 2:
            self.value = List__i64.create(make_shared[vector[cint64_t]](deref(self._cpp_obj).get_intListValue()))
        elif type == 3:
            self.value = List__string.create(make_shared[vector[string]](deref(self._cpp_obj).get_stringListValue()))
        elif type == 9:
            self.value = Map__i16_string.create(make_shared[cmap[cint16_t,string]](deref(self._cpp_obj).get_typedefValue()))
        elif type == 14:
            if not deref(self._cpp_obj).get_stringRef():
                self.value = None
            else:
                self.value = str.create(reference_shared_ptr_stringRef(self._cpp_obj, deref(deref(self._cpp_obj).get_stringRef())))

    def get_type(ComplexUnion self):
        return self.type

    def __copy__(ComplexUnion self):
        cdef shared_ptr[cComplexUnion] cpp_obj = make_shared[cComplexUnion](
            deref(self._cpp_obj)
        )
        return ComplexUnion.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ComplexUnion) and
                isinstance(other, ComplexUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cComplexUnion* cself = (<ComplexUnion>self)._cpp_obj.get()
        cdef cComplexUnion* cother = (<ComplexUnion>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      return __StructSpec(
        name="ComplexUnion",
        kind=__StructType.UNION,
        fields=[
          __FieldSpec(
  name="intValue",
  type=int,
  kind=__NumberType.I64,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="stringValue",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="intListValue",
  type=List__i64,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="stringListValue",
  type=List__string,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="typedefValue",
  type=Map__i16_string,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="stringRef",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
    """cpp2.ref""": """true""",  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(ComplexUnion self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cComplexUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(ComplexUnion self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cComplexUnion]()
        cdef cComplexUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (ComplexUnion, serialize(self)))




@__cython.auto_pickle(False)
cdef class ListUnion(thrift.py3.types.Union):
    Type = __ListUnionType

    def __init__(
        self, *,
        intListValue=None,
        stringListValue=None
    ):
        self._cpp_obj = move(ListUnion._make_instance(
          NULL,
          intListValue,
          stringListValue,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return ListUnion()
        if isinstance(value, List__i64):
            return ListUnion(intListValue=value)
        if isinstance(value, List__string):
            return ListUnion(stringListValue=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cListUnion] _make_instance(
        cListUnion* base_instance,
        object intListValue,
        object stringListValue
    ) except *:
        cdef unique_ptr[cListUnion] c_inst = make_unique[cListUnion]()
        cdef bint any_set = False
        if intListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_intListValue(<vector[cint64_t]>deref(List__i64(intListValue)._cpp_obj))
            any_set = True
        if stringListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringListValue(<vector[string]>deref(List__string(stringListValue)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type is not __ListUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cListUnion] cpp_obj):
        inst = <ListUnion>ListUnion.__new__(ListUnion)
        inst._cpp_obj = move_shared(cpp_obj)
        inst._load_cache()
        return inst

    @property
    def intListValue(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not intListValue')
        return self.value

    @property
    def stringListValue(self):
        if self.type.value != 3:
            raise TypeError(f'Union contains a value of type {self.type.name}, not stringListValue')
        return self.value


    def __hash__(ListUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(ListUnion self):
        return f'ListUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(ListUnion self):
        self.type = ListUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 2:
            self.value = List__i64.create(make_shared[vector[cint64_t]](deref(self._cpp_obj).get_intListValue()))
        elif type == 3:
            self.value = List__string.create(make_shared[vector[string]](deref(self._cpp_obj).get_stringListValue()))

    def get_type(ListUnion self):
        return self.type

    def __copy__(ListUnion self):
        cdef shared_ptr[cListUnion] cpp_obj = make_shared[cListUnion](
            deref(self._cpp_obj)
        )
        return ListUnion.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ListUnion) and
                isinstance(other, ListUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cListUnion* cself = (<ListUnion>self)._cpp_obj.get()
        cdef cListUnion* cother = (<ListUnion>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      return __StructSpec(
        name="ListUnion",
        kind=__StructType.UNION,
        fields=[
          __FieldSpec(
  name="intListValue",
  type=List__i64,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="stringListValue",
  type=List__string,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(ListUnion self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cListUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cListUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cListUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cListUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cListUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(ListUnion self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cListUnion]()
        cdef cListUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cListUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cListUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cListUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cListUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (ListUnion, serialize(self)))




@__cython.auto_pickle(False)
cdef class DataUnion(thrift.py3.types.Union):
    Type = __DataUnionType

    def __init__(
        self, *,
        bytes binaryData=None,
        str stringData=None
    ):
        self._cpp_obj = move(DataUnion._make_instance(
          NULL,
          binaryData,
          stringData,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return DataUnion()
        if isinstance(value, bytes):
            return DataUnion(binaryData=value)
        if isinstance(value, str):
            return DataUnion(stringData=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cDataUnion] _make_instance(
        cDataUnion* base_instance,
        bytes binaryData,
        str stringData
    ) except *:
        cdef unique_ptr[cDataUnion] c_inst = make_unique[cDataUnion]()
        cdef bint any_set = False
        if binaryData is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_binaryData(binaryData)
            any_set = True
        if stringData is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringData(stringData.encode('UTF-8'))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type is not __DataUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cDataUnion] cpp_obj):
        inst = <DataUnion>DataUnion.__new__(DataUnion)
        inst._cpp_obj = move_shared(cpp_obj)
        inst._load_cache()
        return inst

    @property
    def binaryData(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not binaryData')
        return self.value

    @property
    def stringData(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not stringData')
        return self.value


    def __hash__(DataUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(DataUnion self):
        return f'DataUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(DataUnion self):
        self.type = DataUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = deref(self._cpp_obj).get_binaryData()
        elif type == 2:
            self.value = bytes(deref(self._cpp_obj).get_stringData()).decode('UTF-8')

    def get_type(DataUnion self):
        return self.type

    def __copy__(DataUnion self):
        cdef shared_ptr[cDataUnion] cpp_obj = make_shared[cDataUnion](
            deref(self._cpp_obj)
        )
        return DataUnion.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, DataUnion) and
                isinstance(other, DataUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cDataUnion* cself = (<DataUnion>self)._cpp_obj.get()
        cdef cDataUnion* cother = (<DataUnion>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      return __StructSpec(
        name="DataUnion",
        kind=__StructType.UNION,
        fields=[
          __FieldSpec(
  name="binaryData",
  type=bytes,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="stringData",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(DataUnion self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cDataUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cDataUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cDataUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cDataUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cDataUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(DataUnion self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cDataUnion]()
        cdef cDataUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cDataUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cDataUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cDataUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cDataUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (DataUnion, serialize(self)))


@__cython.auto_pickle(False)
cdef class Val(thrift.py3.types.Struct):

    def __init__(
        Val self, *,
        str strVal=None,
        intVal=None,
        typedefValue=None
    ):
        if intVal is not None:
            if not isinstance(intVal, int):
                raise TypeError(f'intVal is not a { int !r}.')
            intVal = <cint32_t> intVal

        self._cpp_obj = move(Val._make_instance(
          NULL,
          NULL,
          strVal,
          intVal,
          typedefValue,
        ))

    def __call__(
        Val self,
        strVal=__NOTSET,
        intVal=__NOTSET,
        typedefValue=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[3] __isNOTSET  # so make_instance is typed

        changes = False
        if strVal is ___NOTSET:
            __isNOTSET[0] = True
            strVal = None
        else:
            __isNOTSET[0] = False
            changes = True

        if intVal is ___NOTSET:
            __isNOTSET[1] = True
            intVal = None
        else:
            __isNOTSET[1] = False
            changes = True

        if typedefValue is ___NOTSET:
            __isNOTSET[2] = True
            typedefValue = None
        else:
            __isNOTSET[2] = False
            changes = True


        if not changes:
            return self

        if strVal is not None:
            if not isinstance(strVal, str):
                raise TypeError(f'strVal is not a { str !r}.')

        if intVal is not None:
            if not isinstance(intVal, int):
                raise TypeError(f'intVal is not a { int !r}.')
            intVal = <cint32_t> intVal

        inst = <Val>Val.__new__(Val)
        inst._cpp_obj = move(Val._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          strVal,
          intVal,
          typedefValue,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cVal] _make_instance(
        cVal* base_instance,
        bint* __isNOTSET,
        str strVal ,
        object intVal ,
        object typedefValue 
    ) except *:
        cdef unique_ptr[cVal] c_inst
        if base_instance:
            c_inst = make_unique[cVal](deref(base_instance))
        else:
            c_inst = make_unique[cVal]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and strVal is None:
                deref(c_inst).strVal = default_inst[cVal]().strVal
                deref(c_inst).__isset.strVal = False
                pass

            if not __isNOTSET[1] and intVal is None:
                deref(c_inst).intVal = default_inst[cVal]().intVal
                deref(c_inst).__isset.intVal = False
                pass

            if not __isNOTSET[2] and typedefValue is None:
                deref(c_inst).typedefValue = default_inst[cVal]().typedefValue
                deref(c_inst).__isset.typedefValue = False
                pass

        if strVal is not None:
            deref(c_inst).strVal = thrift.py3.types.move(thrift.py3.types.bytes_to_string(strVal.encode('utf-8')))
            deref(c_inst).__isset.strVal = True
        if intVal is not None:
            deref(c_inst).intVal = intVal
            deref(c_inst).__isset.intVal = True
        if typedefValue is not None:
            deref(c_inst).typedefValue = deref(Map__i16_string(typedefValue)._cpp_obj)
            deref(c_inst).__isset.typedefValue = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'strVal', self.strVal
        yield 'intVal', self.intVal
        yield 'typedefValue', self.typedefValue

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cVal] cpp_obj):
        inst = <Val>Val.__new__(Val)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def strVal(self):

        return (<bytes>deref(self._cpp_obj).strVal).decode('UTF-8')

    @property
    def intVal(self):

        return deref(self._cpp_obj).intVal

    @property
    def typedefValue(self):

        if self.__field_typedefValue is None:
            self.__field_typedefValue = Map__i16_string.create(reference_shared_ptr_typedefValue(self._cpp_obj, deref(self._cpp_obj).typedefValue))
        return self.__field_typedefValue


    def __hash__(Val self):
        if not self.__hash:
            self.__hash = hash((
            self.strVal,
            self.intVal,
            self.typedefValue,
            ))
        return self.__hash

    def __repr__(Val self):
        return f'Val(strVal={repr(self.strVal)}, intVal={repr(self.intVal)}, typedefValue={repr(self.typedefValue)})'
    def __copy__(Val self):
        cdef shared_ptr[cVal] cpp_obj = make_shared[cVal](
            deref(self._cpp_obj)
        )
        return Val.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, Val) and
                isinstance(other, Val)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cVal* cself = (<Val>self)._cpp_obj.get()
        cdef cVal* cother = (<Val>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = Val.create(constant_shared_ptr[cVal](default_inst[cVal]()))
      return __StructSpec(
        name="Val",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="strVal",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="intVal",
  type=int,
  kind=__NumberType.I32,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="typedefValue",
  type=Map__i16_string,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(Val self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cVal* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cVal](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cVal](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cVal](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cVal](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(Val self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cVal]()
        cdef cVal* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cVal](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cVal](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cVal](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cVal](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (Val, serialize(self)))




@__cython.auto_pickle(False)
cdef class ValUnion(thrift.py3.types.Union):
    Type = __ValUnionType

    def __init__(
        self, *,
        Val v1=None,
        Val v2=None
    ):
        self._cpp_obj = move(ValUnion._make_instance(
          NULL,
          v1,
          v2,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return ValUnion()
        if isinstance(value, Val):
            return ValUnion(v1=value)
        if isinstance(value, Val):
            return ValUnion(v2=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cValUnion] _make_instance(
        cValUnion* base_instance,
        Val v1,
        Val v2
    ) except *:
        cdef unique_ptr[cValUnion] c_inst = make_unique[cValUnion]()
        cdef bint any_set = False
        if v1 is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_v1(deref((<Val?> v1)._cpp_obj))
            any_set = True
        if v2 is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_v2(deref((<Val?> v2)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type is not __ValUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cValUnion] cpp_obj):
        inst = <ValUnion>ValUnion.__new__(ValUnion)
        inst._cpp_obj = move_shared(cpp_obj)
        inst._load_cache()
        return inst

    @property
    def v1(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not v1')
        return self.value

    @property
    def v2(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not v2')
        return self.value


    def __hash__(ValUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(ValUnion self):
        return f'ValUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(ValUnion self):
        self.type = ValUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = Val.create(make_shared[cVal](deref(self._cpp_obj).get_v1()))
        elif type == 2:
            self.value = Val.create(make_shared[cVal](deref(self._cpp_obj).get_v2()))

    def get_type(ValUnion self):
        return self.type

    def __copy__(ValUnion self):
        cdef shared_ptr[cValUnion] cpp_obj = make_shared[cValUnion](
            deref(self._cpp_obj)
        )
        return ValUnion.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ValUnion) and
                isinstance(other, ValUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cValUnion* cself = (<ValUnion>self)._cpp_obj.get()
        cdef cValUnion* cother = (<ValUnion>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      return __StructSpec(
        name="ValUnion",
        kind=__StructType.UNION,
        fields=[
          __FieldSpec(
  name="v1",
  type=Val,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="v2",
  type=Val,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(ValUnion self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cValUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cValUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cValUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cValUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cValUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(ValUnion self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cValUnion]()
        cdef cValUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cValUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cValUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cValUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cValUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (ValUnion, serialize(self)))




@__cython.auto_pickle(False)
cdef class VirtualComplexUnion(thrift.py3.types.Union):
    Type = __VirtualComplexUnionType

    def __init__(
        self, *,
        str thingOne=None,
        str thingTwo=None
    ):
        self._cpp_obj = move(VirtualComplexUnion._make_instance(
          NULL,
          thingOne,
          thingTwo,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return VirtualComplexUnion()
        if isinstance(value, str):
            return VirtualComplexUnion(thingOne=value)
        if isinstance(value, str):
            return VirtualComplexUnion(thingTwo=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cVirtualComplexUnion] _make_instance(
        cVirtualComplexUnion* base_instance,
        str thingOne,
        str thingTwo
    ) except *:
        cdef unique_ptr[cVirtualComplexUnion] c_inst = make_unique[cVirtualComplexUnion]()
        cdef bint any_set = False
        if thingOne is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_thingOne(thingOne.encode('UTF-8'))
            any_set = True
        if thingTwo is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_thingTwo(thingTwo.encode('UTF-8'))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type is not __VirtualComplexUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cVirtualComplexUnion] cpp_obj):
        inst = <VirtualComplexUnion>VirtualComplexUnion.__new__(VirtualComplexUnion)
        inst._cpp_obj = move_shared(cpp_obj)
        inst._load_cache()
        return inst

    @property
    def thingOne(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not thingOne')
        return self.value

    @property
    def thingTwo(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not thingTwo')
        return self.value


    def __hash__(VirtualComplexUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(VirtualComplexUnion self):
        return f'VirtualComplexUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(VirtualComplexUnion self):
        self.type = VirtualComplexUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = bytes(deref(self._cpp_obj).get_thingOne()).decode('UTF-8')
        elif type == 2:
            self.value = bytes(deref(self._cpp_obj).get_thingTwo()).decode('UTF-8')

    def get_type(VirtualComplexUnion self):
        return self.type

    def __copy__(VirtualComplexUnion self):
        cdef shared_ptr[cVirtualComplexUnion] cpp_obj = make_shared[cVirtualComplexUnion](
            deref(self._cpp_obj)
        )
        return VirtualComplexUnion.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, VirtualComplexUnion) and
                isinstance(other, VirtualComplexUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cVirtualComplexUnion* cself = (<VirtualComplexUnion>self)._cpp_obj.get()
        cdef cVirtualComplexUnion* cother = (<VirtualComplexUnion>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      return __StructSpec(
        name="VirtualComplexUnion",
        kind=__StructType.UNION,
        fields=[
          __FieldSpec(
  name="thingOne",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="thingTwo",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
          """cpp.virtual""": """1""",    }),
      )
    cdef __iobuf.IOBuf _serialize(VirtualComplexUnion self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cVirtualComplexUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cVirtualComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cVirtualComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cVirtualComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cVirtualComplexUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(VirtualComplexUnion self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cVirtualComplexUnion]()
        cdef cVirtualComplexUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cVirtualComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cVirtualComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cVirtualComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cVirtualComplexUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (VirtualComplexUnion, serialize(self)))


@__cython.auto_pickle(False)
cdef class NonCopyableStruct(thrift.py3.types.Struct):

    def __init__(
        NonCopyableStruct self, *,
        num=None
    ):
        if num is not None:
            if not isinstance(num, int):
                raise TypeError(f'num is not a { int !r}.')
            num = <cint64_t> num

        self._cpp_obj = move(NonCopyableStruct._make_instance(
          NULL,
          NULL,
          num,
        ))

    def __call__(
        NonCopyableStruct self,
        num=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        changes = False
        if num is ___NOTSET:
            __isNOTSET[0] = True
            num = None
        else:
            __isNOTSET[0] = False
            changes = True


        if not changes:
            return self

        if num is not None:
            if not isinstance(num, int):
                raise TypeError(f'num is not a { int !r}.')
            num = <cint64_t> num

        inst = <NonCopyableStruct>NonCopyableStruct.__new__(NonCopyableStruct)
        inst._cpp_obj = move(NonCopyableStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          num,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNonCopyableStruct] _make_instance(
        cNonCopyableStruct* base_instance,
        bint* __isNOTSET,
        object num 
    ) except *:
        cdef unique_ptr[cNonCopyableStruct] c_inst
        if base_instance:
            c_inst = make_unique[cNonCopyableStruct](deref(base_instance))
        else:
            c_inst = make_unique[cNonCopyableStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and num is None:
                deref(c_inst).num = default_inst[cNonCopyableStruct]().num
                deref(c_inst).__isset.num = False
                pass

        if num is not None:
            deref(c_inst).num = num
            deref(c_inst).__isset.num = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'num', self.num

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNonCopyableStruct] cpp_obj):
        inst = <NonCopyableStruct>NonCopyableStruct.__new__(NonCopyableStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def num(self):

        return deref(self._cpp_obj).num


    def __hash__(NonCopyableStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.num,
            ))
        return self.__hash

    def __repr__(NonCopyableStruct self):
        return f'NonCopyableStruct(num={repr(self.num)})'
    def __copy__(NonCopyableStruct self):
        cdef shared_ptr[cNonCopyableStruct] cpp_obj = make_shared[cNonCopyableStruct](
            deref(self._cpp_obj)
        )
        return NonCopyableStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, NonCopyableStruct) and
                isinstance(other, NonCopyableStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cNonCopyableStruct* cself = (<NonCopyableStruct>self)._cpp_obj.get()
        cdef cNonCopyableStruct* cother = (<NonCopyableStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = NonCopyableStruct.create(constant_shared_ptr[cNonCopyableStruct](default_inst[cNonCopyableStruct]()))
      return __StructSpec(
        name="NonCopyableStruct",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="num",
  type=int,
  kind=__NumberType.I64,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
          """cpp2.noncopyable""": """1""",    }),
      )
    cdef __iobuf.IOBuf _serialize(NonCopyableStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cNonCopyableStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cNonCopyableStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cNonCopyableStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cNonCopyableStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cNonCopyableStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(NonCopyableStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cNonCopyableStruct]()
        cdef cNonCopyableStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cNonCopyableStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cNonCopyableStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cNonCopyableStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cNonCopyableStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (NonCopyableStruct, serialize(self)))




@__cython.auto_pickle(False)
cdef class NonCopyableUnion(thrift.py3.types.Union):
    Type = __NonCopyableUnionType

    def __init__(
        self, *,
        NonCopyableStruct s=None
    ):
        self._cpp_obj = move(NonCopyableUnion._make_instance(
          NULL,
          s,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return NonCopyableUnion()
        if isinstance(value, NonCopyableStruct):
            return NonCopyableUnion(s=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cNonCopyableUnion] _make_instance(
        cNonCopyableUnion* base_instance,
        NonCopyableStruct s
    ) except *:
        cdef unique_ptr[cNonCopyableUnion] c_inst = make_unique[cNonCopyableUnion]()
        cdef bint any_set = False
        if s is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_s(deref((<NonCopyableStruct?> s)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type is not __NonCopyableUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cNonCopyableUnion] cpp_obj):
        inst = <NonCopyableUnion>NonCopyableUnion.__new__(NonCopyableUnion)
        inst._cpp_obj = move_shared(cpp_obj)
        inst._load_cache()
        return inst

    @property
    def s(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not s')
        return self.value


    def __hash__(NonCopyableUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(NonCopyableUnion self):
        return f'NonCopyableUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(NonCopyableUnion self):
        self.type = NonCopyableUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = NonCopyableStruct.create(make_shared[cNonCopyableStruct](deref(self._cpp_obj).get_s()))

    def get_type(NonCopyableUnion self):
        return self.type

    def __copy__(NonCopyableUnion self):
        cdef shared_ptr[cNonCopyableUnion] cpp_obj = make_shared[cNonCopyableUnion](
            deref(self._cpp_obj)
        )
        return NonCopyableUnion.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, NonCopyableUnion) and
                isinstance(other, NonCopyableUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cNonCopyableUnion* cself = (<NonCopyableUnion>self)._cpp_obj.get()
        cdef cNonCopyableUnion* cother = (<NonCopyableUnion>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      return __StructSpec(
        name="NonCopyableUnion",
        kind=__StructType.UNION,
        fields=[
          __FieldSpec(
  name="s",
  type=NonCopyableStruct,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
          ],
        annotations=_py_types.MappingProxyType({
          """cpp2.noncopyable""": """1""",    }),
      )
    cdef __iobuf.IOBuf _serialize(NonCopyableUnion self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cNonCopyableUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cNonCopyableUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cNonCopyableUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cNonCopyableUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cNonCopyableUnion](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef cuint32_t _deserialize(NonCopyableUnion self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cNonCopyableUnion]()
        cdef cNonCopyableUnion* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cNonCopyableUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cNonCopyableUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cNonCopyableUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cNonCopyableUnion](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (NonCopyableUnion, serialize(self)))


@__cython.auto_pickle(False)
cdef class List__i64(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint64_t]] c_items):
        inst = <List__i64>List__i64.__new__(List__i64)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__i64 self):
        cdef shared_ptr[vector[cint64_t]] cpp_obj = make_shared[vector[cint64_t]](
            deref(self._cpp_obj)
        )
        return List__i64.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cint64_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint64_t]] c_inst = make_shared[vector[cint64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint64_t]] c_inst
        cdef cint64_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint64_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i64.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint64_t].iterator, cint64_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint64_t citem
        cdef vector[cint64_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef cint64_t citem
        cdef vector[cint64_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint64_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint64_t].iterator loc = std_libcpp.find[vector[cint64_t].iterator, cint64_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint64_t].iterator, cint64_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__i64, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=int, kind=__NumberType.I64)


Sequence.register(List__i64)

@__cython.auto_pickle(False)
cdef class List__string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = List__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__string self):
        cdef shared_ptr[vector[string]] cpp_obj = make_shared[vector[string]](
            deref(self._cpp_obj)
        )
        return List__string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[string]] _make_instance(object items) except *:
        cdef shared_ptr[vector[string]] c_inst = make_shared[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__string.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return std_libcpp.find[vector[string].iterator, string](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item.encode('UTF-8')) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, str):
            raise err
        cdef vector[string].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find[vector[string].iterator, string](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item.encode('UTF-8')        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, str):
            return 0
        return <cint64_t> std_libcpp.count[vector[string].iterator, string](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item.encode('UTF-8'))

    def __reduce__(self):
        return (List__string, (list(self), ))

    @staticmethod
    def __get_reflection__():
        return __ListSpec(value=str, kind=None)


Sequence.register(List__string)

@__cython.auto_pickle(False)
cdef class Map__i16_string(thrift.py3.types.Container):
    def __init__(self, items=None):
        if isinstance(items, Map__i16_string):
            self._cpp_obj = (<Map__i16_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__i16_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint16_t,string]] c_items):
        inst = <Map__i16_string>Map__i16_string.__new__(Map__i16_string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i16_string self):
        cdef shared_ptr[cmap[cint16_t,string]] cpp_obj = make_shared[cmap[cint16_t,string]](
            deref(self._cpp_obj)
        )
        return Map__i16_string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[cint16_t,string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint16_t,string]] c_inst = make_shared[cmap[cint16_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint16_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[key] = item.encode('UTF-8')
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[cint16_t,string].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            return
        cdef cint16_t citem
        cdef cmap[cint16_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef cint16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            return
        cdef string citem
        cdef cmap[cint16_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def items(self):
        if not self:
            return
        cdef cint16_t ckey
        cdef string citem
        cdef cmap[cint16_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, bytes(citem).decode('UTF-8'))
            inc(loc)

    def __reduce__(self):
        return (Map__i16_string, (dict(self), ))

    @staticmethod
    def __get_reflection__():
        return __MapSpec(key=int, key_kind=__NumberType.I16, value=str, value_kind=None)


Mapping.register(Map__i16_string)

containerTypedef = Map__i16_string
