<?hh // strict
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace test\fixtures;

/**
 * Original thrift enum:-
 * Enum
 */
enum Enum: int {
  ENUM = 1;
}

enum UnionEnum: int {
  _EMPTY_ = 0;
  intValue = 1;
  stringValue = 5;
}

/**
 * Original thrift struct:-
 * Union
 */
class Union implements \IThriftStruct, \IThriftUnion<\test\fixtures\UnionEnum>, \IThriftShapishStruct {
  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'intValue',
      'union' => true,
      'type' => \TType::I64,
    ),
    5 => shape(
      'var' => 'stringValue',
      'union' => true,
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'intValue' => 1,
    'stringValue' => 5,
  ];
  const type TShape = shape(
    ?'intValue' => ?int,
    ?'stringValue' => ?string,
  );
  const int STRUCTURAL_ID = 7430801321277306554;
  /**
   * Original thrift field:-
   * 1: i64 intValue
   */
  public ?int $intValue;
  /**
   * Original thrift field:-
   * 5: string stringValue
   */
  public ?string $stringValue;
  protected \test\fixtures\UnionEnum $_type = \test\fixtures\UnionEnum::_EMPTY_;

  <<__Rx>>
  public function __construct(?int $intValue = null, ?string $stringValue = null  ) {
    $this->_type = \test\fixtures\UnionEnum::_EMPTY_;
    if ($intValue !== null) {
      $this->intValue = $intValue;
      $this->_type = \test\fixtures\UnionEnum::intValue;
    }
    if ($stringValue !== null) {
      $this->stringValue = $stringValue;
      $this->_type = \test\fixtures\UnionEnum::stringValue;
    }
  }

  public function getName(): string {
    return 'Union';
  }

  public function getType(): \test\fixtures\UnionEnum {
    return $this->_type;
  }

  public function set_intValue(int $intValue): this {
    $this->_type = \test\fixtures\UnionEnum::intValue;
    $this->intValue = $intValue;
    return $this;
  }

  public function get_intValue(): int {
    invariant(
      $this->_type === \test\fixtures\UnionEnum::intValue,
      'get_intValue called on an instance of Union whose current type is %s',
      (string)$this->_type,
    );
    return \nullthrows($this->intValue);
  }

  public function set_stringValue(string $stringValue): this {
    $this->_type = \test\fixtures\UnionEnum::stringValue;
    $this->stringValue = $stringValue;
    return $this;
  }

  public function get_stringValue(): string {
    invariant(
      $this->_type === \test\fixtures\UnionEnum::stringValue,
      'get_stringValue called on an instance of Union whose current type is %s',
      (string)$this->_type,
    );
    return \nullthrows($this->stringValue);
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public static function __fromShape(self::TShape $shape): this {
    $me = new static();
    $me->_type = \test\fixtures\UnionEnum::_EMPTY_;
    if (Shapes::idx($shape, 'intValue') !== null) {
      $me->intValue = $shape['intValue'];
      $me->_type = \test\fixtures\UnionEnum::intValue;
    }
    if (Shapes::idx($shape, 'stringValue') !== null) {
      $me->stringValue = $shape['stringValue'];
      $me->_type = \test\fixtures\UnionEnum::stringValue;
    }
    return $me;
  }

  <<__Rx>>
  public function __toShape(): self::TShape {
    return shape(
      'intValue' => $this->intValue,
      'stringValue' => $this->stringValue,
    );
  }
  public function read(\TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $this->_type = \test\fixtures\UnionEnum::_EMPTY_;
    $xfer += $input->readStructBegin(inout $fname);
    while (true)
    {
      $xfer += $input->readFieldBegin(inout $fname, inout $ftype, inout $fid);
      if ($ftype == \TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == \TType::I64) {
            $xfer += $input->readI64(&$this->intValue);
            $this->_type = \test\fixtures\UnionEnum::intValue;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == \TType::STRING) {
            $xfer += $input->readString(&$this->stringValue);
            $this->_type = \test\fixtures\UnionEnum::stringValue;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(\TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Union');
    if ($this->intValue !== null) {
      $_val0 = $this->intValue;
      $xfer += $output->writeFieldBegin('intValue', \TType::I64, 1);
      $xfer += $output->writeI64($_val0);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringValue !== null) {
      $_val1 = $this->stringValue;
      $xfer += $output->writeFieldBegin('stringValue', \TType::STRING, 5);
      $xfer += $output->writeString($_val1);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Original thrift struct:-
 * A
 */
class A implements \IThriftStruct, \IThriftShapishStruct {
  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
  ];
  const type TShape = shape(
    'a' => string,
  );
  const int STRUCTURAL_ID = 7939807933046472325;
  /**
   * Original thrift field:-
   * 1: string a
   */
  public string $a;

  <<__Rx>>
  public function __construct(?string $a = null  ) {
    if ($a === null) {
      $this->a = '';
    } else {
      $this->a = $a;
    }
  }

  public function getName(): string {
    return 'A';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public static function __fromShape(self::TShape $shape): this {
    $me = new static();
    $me->a = $shape['a'];
    return $me;
  }

  <<__Rx>>
  public function __toShape(): self::TShape {
    return shape(
      'a' => $this->a,
    );
  }
  public function read(\TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin(inout $fname);
    while (true)
    {
      $xfer += $input->readFieldBegin(inout $fname, inout $ftype, inout $fid);
      if ($ftype == \TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == \TType::STRING) {
            $xfer += $input->readString(&$this->a);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(\TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('A');
    if ($this->a !== null) {
      $_val0 = $this->a;
      $xfer += $output->writeFieldBegin('a', \TType::STRING, 1);
      $xfer += $output->writeString($_val0);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Original thrift struct:-
 * B
 */
class B implements \IThriftStruct, \IThriftShapishStruct {
  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'just_an_A',
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\A::class,
    ),
    2 => shape(
      'var' => 'set_of_i32',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'list_of_i32',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'list_of_string',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    5 => shape(
      'var' => 'map_of_string_to_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    6 => shape(
      'var' => 'map_of_string_to_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRUCT,
        'class' => \test\fixtures\A::class,
      ),
      'format' => 'collection',
    ),
    7 => shape(
      'var' => 'map_of_string_to_list_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::LST,
        'etype' => \TType::I32,
        'elem' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    8 => shape(
      'var' => 'map_of_string_to_list_of_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::LST,
        'etype' => \TType::STRUCT,
        'elem' => shape(
          'type' => \TType::STRUCT,
          'class' => \test\fixtures\A::class,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    9 => shape(
      'var' => 'map_of_string_to_set_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::SET,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::SET,
        'etype' => \TType::I32,
        'elem' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    10 => shape(
      'var' => 'map_of_string_to_map_of_string_to_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::MAP,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::I32,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    11 => shape(
      'var' => 'map_of_string_to_map_of_string_to_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::MAP,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::STRUCT,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::STRUCT,
          'class' => \test\fixtures\A::class,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    12 => shape(
      'var' => 'list_of_set_of_i32',
      'type' => \TType::LST,
      'etype' => \TType::SET,
      'elem' => shape(
        'type' => \TType::SET,
        'etype' => \TType::I32,
        'elem' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    13 => shape(
      'var' => 'list_of_map_of_string_to_list_of_A',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::LST,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::LST,
          'etype' => \TType::STRUCT,
          'elem' => shape(
            'type' => \TType::STRUCT,
            'class' => \test\fixtures\A::class,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    14 => shape(
      'var' => 'list_of_map_of_string_to_A',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::STRUCT,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::STRUCT,
          'class' => \test\fixtures\A::class,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    15 => shape(
      'var' => 'list_of_self',
      'type' => \TType::LST,
      'etype' => \TType::STRUCT,
      'elem' => shape(
        'type' => \TType::STRUCT,
        'class' => \test\fixtures\B::class,
      ),
      'format' => 'collection',
    ),
    16 => shape(
      'var' => 'map_of_string_to_self',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRUCT,
        'class' => \test\fixtures\B::class,
      ),
      'format' => 'collection',
    ),
    17 => shape(
      'var' => 'just_an_enum',
      'type' => \TType::I32,
      'enum' => \test\fixtures\Enum::class,
    ),
    18 => shape(
      'var' => 'just_a_union',
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\Union::class,
    ),
    51 => shape(
      'var' => 'optional_just_an_A',
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\A::class,
    ),
    52 => shape(
      'var' => 'optional_set_of_i32',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    53 => shape(
      'var' => 'optional_list_of_i32',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    54 => shape(
      'var' => 'optional_list_of_string',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    55 => shape(
      'var' => 'optional_map_of_string_to_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    56 => shape(
      'var' => 'optional_map_of_string_to_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRUCT,
        'class' => \test\fixtures\A::class,
      ),
      'format' => 'collection',
    ),
    57 => shape(
      'var' => 'optional_map_of_string_to_list_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::LST,
        'etype' => \TType::I32,
        'elem' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    58 => shape(
      'var' => 'optional_map_of_string_to_list_of_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::LST,
        'etype' => \TType::STRUCT,
        'elem' => shape(
          'type' => \TType::STRUCT,
          'class' => \test\fixtures\A::class,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    59 => shape(
      'var' => 'optional_map_of_string_to_set_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::SET,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::SET,
        'etype' => \TType::I32,
        'elem' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    60 => shape(
      'var' => 'optional_enum',
      'type' => \TType::I32,
      'enum' => \test\fixtures\Enum::class,
    ),
    70 => shape(
      'var' => 'required_enum_with_default',
      'type' => \TType::I32,
      'enum' => \test\fixtures\Enum::class,
    ),
    80 => shape(
      'var' => 'string_with_default_value',
      'type' => \TType::STRING,
    ),
    81 => shape(
      'var' => 'i32_with_default_value',
      'type' => \TType::I32,
    ),
    82 => shape(
      'var' => 'double_with_default_value',
      'type' => \TType::DOUBLE,
    ),
    83 => shape(
      'var' => 'enum_with_default_value',
      'type' => \TType::I32,
      'enum' => \test\fixtures\Enum::class,
    ),
    84 => shape(
      'var' => 'A_with_default_value',
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\A::class,
    ),
    85 => shape(
      'var' => 'set_of_i32_with_default_value',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    86 => shape(
      'var' => 'map_of_i32_to_string_with_default_value',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    87 => shape(
      'var' => 'list_of_string_with_default_value',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    88 => shape(
      'var' => 'map_of_string_to_list_of_i32_with_default_value',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::LST,
        'etype' => \TType::I32,
        'elem' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'just_an_A' => 1,
    'set_of_i32' => 2,
    'list_of_i32' => 3,
    'list_of_string' => 4,
    'map_of_string_to_i32' => 5,
    'map_of_string_to_A' => 6,
    'map_of_string_to_list_of_i32' => 7,
    'map_of_string_to_list_of_A' => 8,
    'map_of_string_to_set_of_i32' => 9,
    'map_of_string_to_map_of_string_to_i32' => 10,
    'map_of_string_to_map_of_string_to_A' => 11,
    'list_of_set_of_i32' => 12,
    'list_of_map_of_string_to_list_of_A' => 13,
    'list_of_map_of_string_to_A' => 14,
    'list_of_self' => 15,
    'map_of_string_to_self' => 16,
    'just_an_enum' => 17,
    'just_a_union' => 18,
    'optional_just_an_A' => 51,
    'optional_set_of_i32' => 52,
    'optional_list_of_i32' => 53,
    'optional_list_of_string' => 54,
    'optional_map_of_string_to_i32' => 55,
    'optional_map_of_string_to_A' => 56,
    'optional_map_of_string_to_list_of_i32' => 57,
    'optional_map_of_string_to_list_of_A' => 58,
    'optional_map_of_string_to_set_of_i32' => 59,
    'optional_enum' => 60,
    'required_enum_with_default' => 70,
    'string_with_default_value' => 80,
    'i32_with_default_value' => 81,
    'double_with_default_value' => 82,
    'enum_with_default_value' => 83,
    'A_with_default_value' => 84,
    'set_of_i32_with_default_value' => 85,
    'map_of_i32_to_string_with_default_value' => 86,
    'list_of_string_with_default_value' => 87,
    'map_of_string_to_list_of_i32_with_default_value' => 88,
  ];
  const type TShape = shape(
    ?'just_an_A' => ?\test\fixtures\A::TShape,
    'set_of_i32' => dict<int, bool>,
    'list_of_i32' => vec<int>,
    'list_of_string' => vec<string>,
    'map_of_string_to_i32' => dict<string, int>,
    'map_of_string_to_A' => dict<string, \test\fixtures\A::TShape>,
    'map_of_string_to_list_of_i32' => dict<string, vec<int>>,
    'map_of_string_to_list_of_A' => dict<string, vec<\test\fixtures\A::TShape>>,
    'map_of_string_to_set_of_i32' => dict<string, dict<int, bool>>,
    'map_of_string_to_map_of_string_to_i32' => dict<string, dict<string, int>>,
    'map_of_string_to_map_of_string_to_A' => dict<string, dict<string, \test\fixtures\A::TShape>>,
    'list_of_set_of_i32' => vec<dict<int, bool>>,
    'list_of_map_of_string_to_list_of_A' => vec<dict<string, vec<\test\fixtures\A::TShape>>>,
    'list_of_map_of_string_to_A' => vec<dict<string, \test\fixtures\A::TShape>>,
    'list_of_self' => vec<\test\fixtures\B::TShape>,
    'map_of_string_to_self' => dict<string, \test\fixtures\B::TShape>,
    ?'just_an_enum' => ?\test\fixtures\Enum,
    ?'just_a_union' => ?\test\fixtures\Union::TShape,
    ?'optional_just_an_A' => ?\test\fixtures\A::TShape,
    ?'optional_set_of_i32' => ?dict<int, bool>,
    ?'optional_list_of_i32' => ?vec<int>,
    ?'optional_list_of_string' => ?vec<string>,
    ?'optional_map_of_string_to_i32' => ?dict<string, int>,
    ?'optional_map_of_string_to_A' => ?dict<string, \test\fixtures\A::TShape>,
    ?'optional_map_of_string_to_list_of_i32' => ?dict<string, vec<int>>,
    ?'optional_map_of_string_to_list_of_A' => ?dict<string, vec<\test\fixtures\A::TShape>>,
    ?'optional_map_of_string_to_set_of_i32' => ?dict<string, dict<int, bool>>,
    ?'optional_enum' => ?\test\fixtures\Enum,
    'required_enum_with_default' => \test\fixtures\Enum,
    'string_with_default_value' => string,
    'i32_with_default_value' => int,
    'double_with_default_value' => float,
    ?'enum_with_default_value' => ?\test\fixtures\Enum,
    ?'A_with_default_value' => ?\test\fixtures\A::TShape,
    'set_of_i32_with_default_value' => dict<int, bool>,
    'map_of_i32_to_string_with_default_value' => dict<int, string>,
    'list_of_string_with_default_value' => vec<string>,
    'map_of_string_to_list_of_i32_with_default_value' => dict<string, vec<int>>,
  );
  const int STRUCTURAL_ID = 4145763473660405611;
  /**
   * Original thrift field:-
   * 1: struct module.A just_an_A
   */
  public ?\test\fixtures\A $just_an_A;
  /**
   * Original thrift field:-
   * 2: set<i32> set_of_i32
   */
  public Set<int> $set_of_i32;
  /**
   * Original thrift field:-
   * 3: list<i32> list_of_i32
   */
  public Vector<int> $list_of_i32;
  /**
   * Original thrift field:-
   * 4: list<string> list_of_string
   */
  public Vector<string> $list_of_string;
  /**
   * Original thrift field:-
   * 5: map<string, i32> map_of_string_to_i32
   */
  public Map<string, int> $map_of_string_to_i32;
  /**
   * Original thrift field:-
   * 6: map<string, struct module.A> map_of_string_to_A
   */
  public Map<string, \test\fixtures\A> $map_of_string_to_A;
  /**
   * Original thrift field:-
   * 7: map<string, list<i32>> map_of_string_to_list_of_i32
   */
  public Map<string, Vector<int>> $map_of_string_to_list_of_i32;
  /**
   * Original thrift field:-
   * 8: map<string, list<struct module.A>> map_of_string_to_list_of_A
   */
  public Map<string, Vector<\test\fixtures\A>> $map_of_string_to_list_of_A;
  /**
   * Original thrift field:-
   * 9: map<string, set<i32>> map_of_string_to_set_of_i32
   */
  public Map<string, Set<int>> $map_of_string_to_set_of_i32;
  /**
   * Original thrift field:-
   * 10: map<string, map<string, i32>> map_of_string_to_map_of_string_to_i32
   */
  public Map<string, Map<string, int>> $map_of_string_to_map_of_string_to_i32;
  /**
   * Original thrift field:-
   * 11: map<string, map<string, struct module.A>> map_of_string_to_map_of_string_to_A
   */
  public Map<string, Map<string, \test\fixtures\A>> $map_of_string_to_map_of_string_to_A;
  /**
   * Original thrift field:-
   * 12: list<set<i32>> list_of_set_of_i32
   */
  public Vector<Set<int>> $list_of_set_of_i32;
  /**
   * Original thrift field:-
   * 13: list<map<string, list<struct module.A>>> list_of_map_of_string_to_list_of_A
   */
  public Vector<Map<string, Vector<\test\fixtures\A>>> $list_of_map_of_string_to_list_of_A;
  /**
   * Original thrift field:-
   * 14: list<map<string, struct module.A>> list_of_map_of_string_to_A
   */
  public Vector<Map<string, \test\fixtures\A>> $list_of_map_of_string_to_A;
  /**
   * Original thrift field:-
   * 15: list<struct module.B> list_of_self
   */
  public Vector<\test\fixtures\B> $list_of_self;
  /**
   * Original thrift field:-
   * 16: map<string, struct module.B> map_of_string_to_self
   */
  public Map<string, \test\fixtures\B> $map_of_string_to_self;
  /**
   * Original thrift field:-
   * 17: enum module.Enum just_an_enum
   */
  public ?\test\fixtures\Enum $just_an_enum;
  /**
   * Original thrift field:-
   * 18: struct module.Union just_a_union
   */
  public ?\test\fixtures\Union $just_a_union;
  /**
   * Original thrift field:-
   * 51: struct module.A optional_just_an_A
   */
  public ?\test\fixtures\A $optional_just_an_A;
  /**
   * Original thrift field:-
   * 52: set<i32> optional_set_of_i32
   */
  public ?Set<int> $optional_set_of_i32;
  /**
   * Original thrift field:-
   * 53: list<i32> optional_list_of_i32
   */
  public ?Vector<int> $optional_list_of_i32;
  /**
   * Original thrift field:-
   * 54: list<string> optional_list_of_string
   */
  public ?Vector<string> $optional_list_of_string;
  /**
   * Original thrift field:-
   * 55: map<string, i32> optional_map_of_string_to_i32
   */
  public ?Map<string, int> $optional_map_of_string_to_i32;
  /**
   * Original thrift field:-
   * 56: map<string, struct module.A> optional_map_of_string_to_A
   */
  public ?Map<string, \test\fixtures\A> $optional_map_of_string_to_A;
  /**
   * Original thrift field:-
   * 57: map<string, list<i32>> optional_map_of_string_to_list_of_i32
   */
  public ?Map<string, Vector<int>> $optional_map_of_string_to_list_of_i32;
  /**
   * Original thrift field:-
   * 58: map<string, list<struct module.A>> optional_map_of_string_to_list_of_A
   */
  public ?Map<string, Vector<\test\fixtures\A>> $optional_map_of_string_to_list_of_A;
  /**
   * Original thrift field:-
   * 59: map<string, set<i32>> optional_map_of_string_to_set_of_i32
   */
  public ?Map<string, Set<int>> $optional_map_of_string_to_set_of_i32;
  /**
   * Original thrift field:-
   * 60: enum module.Enum optional_enum
   */
  public ?\test\fixtures\Enum $optional_enum;
  /**
   * Original thrift field:-
   * 70: enum module.Enum required_enum_with_default
   */
  public \test\fixtures\Enum $required_enum_with_default;
  /**
   * Original thrift field:-
   * 80: string string_with_default_value
   */
  public string $string_with_default_value;
  /**
   * Original thrift field:-
   * 81: i32 i32_with_default_value
   */
  public int $i32_with_default_value;
  /**
   * Original thrift field:-
   * 82: double double_with_default_value
   */
  public float $double_with_default_value;
  /**
   * Original thrift field:-
   * 83: enum module.Enum enum_with_default_value
   */
  public ?\test\fixtures\Enum $enum_with_default_value;
  /**
   * Original thrift field:-
   * 84: struct module.A A_with_default_value
   */
  public ?\test\fixtures\A $A_with_default_value;
  /**
   * Original thrift field:-
   * 85: set<i32> set_of_i32_with_default_value
   */
  public Set<int> $set_of_i32_with_default_value;
  /**
   * Original thrift field:-
   * 86: map<i32, string> map_of_i32_to_string_with_default_value
   */
  public Map<int, string> $map_of_i32_to_string_with_default_value;
  /**
   * Original thrift field:-
   * 87: list<string> list_of_string_with_default_value
   */
  public Vector<string> $list_of_string_with_default_value;
  /**
   * Original thrift field:-
   * 88: map<string, list<i32>> map_of_string_to_list_of_i32_with_default_value
   */
  public Map<string, Vector<int>> $map_of_string_to_list_of_i32_with_default_value;

  <<__Rx>>
  public function __construct(?\test\fixtures\A $just_an_A = null, ?Set<int> $set_of_i32 = null, ?Vector<int> $list_of_i32 = null, ?Vector<string> $list_of_string = null, ?Map<string, int> $map_of_string_to_i32 = null, ?Map<string, \test\fixtures\A> $map_of_string_to_A = null, ?Map<string, Vector<int>> $map_of_string_to_list_of_i32 = null, ?Map<string, Vector<\test\fixtures\A>> $map_of_string_to_list_of_A = null, ?Map<string, Set<int>> $map_of_string_to_set_of_i32 = null, ?Map<string, Map<string, int>> $map_of_string_to_map_of_string_to_i32 = null, ?Map<string, Map<string, \test\fixtures\A>> $map_of_string_to_map_of_string_to_A = null, ?Vector<Set<int>> $list_of_set_of_i32 = null, ?Vector<Map<string, Vector<\test\fixtures\A>>> $list_of_map_of_string_to_list_of_A = null, ?Vector<Map<string, \test\fixtures\A>> $list_of_map_of_string_to_A = null, ?Vector<\test\fixtures\B> $list_of_self = null, ?Map<string, \test\fixtures\B> $map_of_string_to_self = null, ?\test\fixtures\Enum $just_an_enum = null, ?\test\fixtures\Union $just_a_union = null, ?\test\fixtures\A $optional_just_an_A = null, ?Set<int> $optional_set_of_i32 = null, ?Vector<int> $optional_list_of_i32 = null, ?Vector<string> $optional_list_of_string = null, ?Map<string, int> $optional_map_of_string_to_i32 = null, ?Map<string, \test\fixtures\A> $optional_map_of_string_to_A = null, ?Map<string, Vector<int>> $optional_map_of_string_to_list_of_i32 = null, ?Map<string, Vector<\test\fixtures\A>> $optional_map_of_string_to_list_of_A = null, ?Map<string, Set<int>> $optional_map_of_string_to_set_of_i32 = null, ?\test\fixtures\Enum $optional_enum = null, ?\test\fixtures\Enum $required_enum_with_default = null, ?string $string_with_default_value = null, ?int $i32_with_default_value = null, ?float $double_with_default_value = null, ?\test\fixtures\Enum $enum_with_default_value = null, ?\test\fixtures\A $A_with_default_value = null, ?Set<int> $set_of_i32_with_default_value = null, ?Map<int, string> $map_of_i32_to_string_with_default_value = null, ?Vector<string> $list_of_string_with_default_value = null, ?Map<string, Vector<int>> $map_of_string_to_list_of_i32_with_default_value = null  ) {
    $this->just_an_A = $just_an_A;
    if ($set_of_i32 === null) {
      $this->set_of_i32 = Set {};
    } else {
      $this->set_of_i32 = $set_of_i32;
    }
    if ($list_of_i32 === null) {
      $this->list_of_i32 = Vector {};
    } else {
      $this->list_of_i32 = $list_of_i32;
    }
    if ($list_of_string === null) {
      $this->list_of_string = Vector {};
    } else {
      $this->list_of_string = $list_of_string;
    }
    if ($map_of_string_to_i32 === null) {
      $this->map_of_string_to_i32 = Map {};
    } else {
      $this->map_of_string_to_i32 = $map_of_string_to_i32;
    }
    if ($map_of_string_to_A === null) {
      $this->map_of_string_to_A = Map {};
    } else {
      $this->map_of_string_to_A = $map_of_string_to_A;
    }
    if ($map_of_string_to_list_of_i32 === null) {
      $this->map_of_string_to_list_of_i32 = Map {};
    } else {
      $this->map_of_string_to_list_of_i32 = $map_of_string_to_list_of_i32;
    }
    if ($map_of_string_to_list_of_A === null) {
      $this->map_of_string_to_list_of_A = Map {};
    } else {
      $this->map_of_string_to_list_of_A = $map_of_string_to_list_of_A;
    }
    if ($map_of_string_to_set_of_i32 === null) {
      $this->map_of_string_to_set_of_i32 = Map {};
    } else {
      $this->map_of_string_to_set_of_i32 = $map_of_string_to_set_of_i32;
    }
    if ($map_of_string_to_map_of_string_to_i32 === null) {
      $this->map_of_string_to_map_of_string_to_i32 = Map {};
    } else {
      $this->map_of_string_to_map_of_string_to_i32 = $map_of_string_to_map_of_string_to_i32;
    }
    if ($map_of_string_to_map_of_string_to_A === null) {
      $this->map_of_string_to_map_of_string_to_A = Map {};
    } else {
      $this->map_of_string_to_map_of_string_to_A = $map_of_string_to_map_of_string_to_A;
    }
    if ($list_of_set_of_i32 === null) {
      $this->list_of_set_of_i32 = Vector {};
    } else {
      $this->list_of_set_of_i32 = $list_of_set_of_i32;
    }
    if ($list_of_map_of_string_to_list_of_A === null) {
      $this->list_of_map_of_string_to_list_of_A = Vector {};
    } else {
      $this->list_of_map_of_string_to_list_of_A = $list_of_map_of_string_to_list_of_A;
    }
    if ($list_of_map_of_string_to_A === null) {
      $this->list_of_map_of_string_to_A = Vector {};
    } else {
      $this->list_of_map_of_string_to_A = $list_of_map_of_string_to_A;
    }
    if ($list_of_self === null) {
      $this->list_of_self = Vector {};
    } else {
      $this->list_of_self = $list_of_self;
    }
    if ($map_of_string_to_self === null) {
      $this->map_of_string_to_self = Map {};
    } else {
      $this->map_of_string_to_self = $map_of_string_to_self;
    }
    $this->just_an_enum = $just_an_enum;
    $this->just_a_union = $just_a_union;
    $this->optional_just_an_A = $optional_just_an_A;
    $this->optional_set_of_i32 = $optional_set_of_i32;
    $this->optional_list_of_i32 = $optional_list_of_i32;
    $this->optional_list_of_string = $optional_list_of_string;
    $this->optional_map_of_string_to_i32 = $optional_map_of_string_to_i32;
    $this->optional_map_of_string_to_A = $optional_map_of_string_to_A;
    $this->optional_map_of_string_to_list_of_i32 = $optional_map_of_string_to_list_of_i32;
    $this->optional_map_of_string_to_list_of_A = $optional_map_of_string_to_list_of_A;
    $this->optional_map_of_string_to_set_of_i32 = $optional_map_of_string_to_set_of_i32;
    $this->optional_enum = $optional_enum;
    if ($required_enum_with_default === null) {
      $this->required_enum_with_default = \test\fixtures\Enum::ENUM;
    } else {
      $this->required_enum_with_default = $required_enum_with_default;
    }
    if ($string_with_default_value === null) {
      $this->string_with_default_value = "de_fault_in_our_stars";
    } else {
      $this->string_with_default_value = $string_with_default_value;
    }
    if ($i32_with_default_value === null) {
      $this->i32_with_default_value = 1729;
    } else {
      $this->i32_with_default_value = $i32_with_default_value;
    }
    if ($double_with_default_value === null) {
      $this->double_with_default_value = 3.14159;
    } else {
      $this->double_with_default_value = $double_with_default_value;
    }
    if ($enum_with_default_value === null) {
      $this->enum_with_default_value = \test\fixtures\Enum::ENUM;
    } else {
      $this->enum_with_default_value = $enum_with_default_value;
    }
    $this->A_with_default_value = $A_with_default_value;
    if ($set_of_i32_with_default_value === null) {
      $this->set_of_i32_with_default_value = Set {
      3,
      7,
      31,
      127,
    };
    } else {
      $this->set_of_i32_with_default_value = $set_of_i32_with_default_value;
    }
    if ($map_of_i32_to_string_with_default_value === null) {
      $this->map_of_i32_to_string_with_default_value = Map {
      1 => "fish",
      2 => "fish",
    };
    } else {
      $this->map_of_i32_to_string_with_default_value = $map_of_i32_to_string_with_default_value;
    }
    if ($list_of_string_with_default_value === null) {
      $this->list_of_string_with_default_value = Vector {
      "red fish",
      "blue fish",
    };
    } else {
      $this->list_of_string_with_default_value = $list_of_string_with_default_value;
    }
    if ($map_of_string_to_list_of_i32_with_default_value === null) {
      $this->map_of_string_to_list_of_i32_with_default_value = Map {
      "Jenny" => Vector {
        8,
        6,
        7,
        5,
        3,
        0,
        9,
      },
    };
    } else {
      $this->map_of_string_to_list_of_i32_with_default_value = $map_of_string_to_list_of_i32_with_default_value;
    }
  }

  public function getName(): string {
    return 'B';
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }
  public static function __fromShape(self::TShape $shape): this {
    $me = new static();
    if (Shapes::idx($shape, 'just_an_A') !== null) {
      $me->just_an_A = \test\fixtures\A::__fromShape($shape['just_an_A']);
    }
    $me->set_of_i32 = new Set(Keyset\keys($shape['set_of_i32']));
    $me->list_of_i32 = (new Vector($shape['list_of_i32']));
    $me->list_of_string = (new Vector($shape['list_of_string']));
    $me->map_of_string_to_i32 = (new Map($shape['map_of_string_to_i32']));
    $me->map_of_string_to_A = (new Map($shape['map_of_string_to_A']))->map(
      $val0 ==> \test\fixtures\A::__fromShape($val0),
    );
    $me->map_of_string_to_list_of_i32 = (new Map($shape['map_of_string_to_list_of_i32']))->map(
      $val1 ==> (new Vector($val1)),
    );
    $me->map_of_string_to_list_of_A = (new Map($shape['map_of_string_to_list_of_A']))->map(
      $val2 ==> (new Vector($val2))->map(
        $val3 ==> \test\fixtures\A::__fromShape($val3),
      ),
    );
    $me->map_of_string_to_set_of_i32 = (new Map($shape['map_of_string_to_set_of_i32']))->map(
      $val4 ==> new Set(Keyset\keys($val4)),
    );
    $me->map_of_string_to_map_of_string_to_i32 = (new Map($shape['map_of_string_to_map_of_string_to_i32']))->map(
      $val5 ==> (new Map($val5)),
    );
    $me->map_of_string_to_map_of_string_to_A = (new Map($shape['map_of_string_to_map_of_string_to_A']))->map(
      $val6 ==> (new Map($val6))->map(
        $val7 ==> \test\fixtures\A::__fromShape($val7),
      ),
    );
    $me->list_of_set_of_i32 = (new Vector($shape['list_of_set_of_i32']))->map(
      $val8 ==> new Set(Keyset\keys($val8)),
    );
    $me->list_of_map_of_string_to_list_of_A = (new Vector($shape['list_of_map_of_string_to_list_of_A']))->map(
      $val9 ==> (new Map($val9))->map(
        $val10 ==> (new Vector($val10))->map(
          $val11 ==> \test\fixtures\A::__fromShape($val11),
        ),
      ),
    );
    $me->list_of_map_of_string_to_A = (new Vector($shape['list_of_map_of_string_to_A']))->map(
      $val12 ==> (new Map($val12))->map(
        $val13 ==> \test\fixtures\A::__fromShape($val13),
      ),
    );
    $me->list_of_self = (new Vector($shape['list_of_self']))->map(
      $val14 ==> \test\fixtures\B::__fromShape($val14),
    );
    $me->map_of_string_to_self = (new Map($shape['map_of_string_to_self']))->map(
      $val15 ==> \test\fixtures\B::__fromShape($val15),
    );
    if (Shapes::idx($shape, 'just_an_enum') !== null) {
      $me->just_an_enum = $shape['just_an_enum'];
    }
    if (Shapes::idx($shape, 'just_a_union') !== null) {
      $me->just_a_union = \test\fixtures\Union::__fromShape($shape['just_a_union']);
    }
    if (Shapes::idx($shape, 'optional_just_an_A') !== null) {
      $me->optional_just_an_A = \test\fixtures\A::__fromShape($shape['optional_just_an_A']);
    }
    if (Shapes::idx($shape, 'optional_set_of_i32') !== null) {
      $me->optional_set_of_i32 = new Set(Keyset\keys($shape['optional_set_of_i32']));
    }
    if (Shapes::idx($shape, 'optional_list_of_i32') !== null) {
      $me->optional_list_of_i32 = (new Vector($shape['optional_list_of_i32']));
    }
    if (Shapes::idx($shape, 'optional_list_of_string') !== null) {
      $me->optional_list_of_string = (new Vector($shape['optional_list_of_string']));
    }
    if (Shapes::idx($shape, 'optional_map_of_string_to_i32') !== null) {
      $me->optional_map_of_string_to_i32 = (new Map($shape['optional_map_of_string_to_i32']));
    }
    if (Shapes::idx($shape, 'optional_map_of_string_to_A') !== null) {
      $me->optional_map_of_string_to_A = (new Map($shape['optional_map_of_string_to_A']))->map(
        $val16 ==> \test\fixtures\A::__fromShape($val16),
      );
    }
    if (Shapes::idx($shape, 'optional_map_of_string_to_list_of_i32') !== null) {
      $me->optional_map_of_string_to_list_of_i32 = (new Map($shape['optional_map_of_string_to_list_of_i32']))->map(
        $val17 ==> (new Vector($val17)),
      );
    }
    if (Shapes::idx($shape, 'optional_map_of_string_to_list_of_A') !== null) {
      $me->optional_map_of_string_to_list_of_A = (new Map($shape['optional_map_of_string_to_list_of_A']))->map(
        $val18 ==> (new Vector($val18))->map(
          $val19 ==> \test\fixtures\A::__fromShape($val19),
        ),
      );
    }
    if (Shapes::idx($shape, 'optional_map_of_string_to_set_of_i32') !== null) {
      $me->optional_map_of_string_to_set_of_i32 = (new Map($shape['optional_map_of_string_to_set_of_i32']))->map(
        $val20 ==> new Set(Keyset\keys($val20)),
      );
    }
    if (Shapes::idx($shape, 'optional_enum') !== null) {
      $me->optional_enum = $shape['optional_enum'];
    }
    $me->required_enum_with_default = $shape['required_enum_with_default'];
    $me->string_with_default_value = $shape['string_with_default_value'];
    $me->i32_with_default_value = $shape['i32_with_default_value'];
    $me->double_with_default_value = $shape['double_with_default_value'];
    if (Shapes::idx($shape, 'enum_with_default_value') !== null) {
      $me->enum_with_default_value = $shape['enum_with_default_value'];
    }
    if (Shapes::idx($shape, 'A_with_default_value') !== null) {
      $me->A_with_default_value = \test\fixtures\A::__fromShape($shape['A_with_default_value']);
    }
    $me->set_of_i32_with_default_value = new Set(Keyset\keys($shape['set_of_i32_with_default_value']));
    $me->map_of_i32_to_string_with_default_value = (new Map($shape['map_of_i32_to_string_with_default_value']));
    $me->list_of_string_with_default_value = (new Vector($shape['list_of_string_with_default_value']));
    $me->map_of_string_to_list_of_i32_with_default_value = (new Map($shape['map_of_string_to_list_of_i32_with_default_value']))->map(
      $val21 ==> (new Vector($val21)),
    );
    return $me;
  }

  <<__Rx>>
  public function __toShape(): self::TShape {
    return shape(
      'just_an_A' => $this->just_an_A?->__toShape(),
      'set_of_i32' => ThriftUtil::toDArray(Dict\fill_keys($this->set_of_i32->toValuesArray(), true)),
      'list_of_i32' => vec($this->list_of_i32),
      'list_of_string' => vec($this->list_of_string),
      'map_of_string_to_i32' => dict($this->map_of_string_to_i32),
      'map_of_string_to_A' => $this->map_of_string_to_A->map(
        $_val0 ==> $_val0->__toShape(),
      )
        |> dict($$),
      'map_of_string_to_list_of_i32' => $this->map_of_string_to_list_of_i32->map(
        $_val0 ==> vec($_val0),
      )
        |> dict($$),
      'map_of_string_to_list_of_A' => $this->map_of_string_to_list_of_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )
          |> vec($$),
      )
        |> dict($$),
      'map_of_string_to_set_of_i32' => $this->map_of_string_to_set_of_i32->map(
        $_val0 ==> ThriftUtil::toDArray(Dict\fill_keys($_val0, true)),
      )
        |> dict($$),
      'map_of_string_to_map_of_string_to_i32' => $this->map_of_string_to_map_of_string_to_i32->map(
        $_val0 ==> dict($_val0),
      )
        |> dict($$),
      'map_of_string_to_map_of_string_to_A' => $this->map_of_string_to_map_of_string_to_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )
          |> dict($$),
      )
        |> dict($$),
      'list_of_set_of_i32' => $this->list_of_set_of_i32->map(
        $_val0 ==> ThriftUtil::toDArray(Dict\fill_keys($_val0, true)),
      )
        |> vec($$),
      'list_of_map_of_string_to_list_of_A' => $this->list_of_map_of_string_to_list_of_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->map(
            $_val2 ==> $_val2->__toShape(),
          )
            |> vec($$),
        )
          |> dict($$),
      )
        |> vec($$),
      'list_of_map_of_string_to_A' => $this->list_of_map_of_string_to_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )
          |> dict($$),
      )
        |> vec($$),
      'list_of_self' => $this->list_of_self->map(
        $_val0 ==> $_val0->__toShape(),
      )
        |> vec($$),
      'map_of_string_to_self' => $this->map_of_string_to_self->map(
        $_val0 ==> $_val0->__toShape(),
      )
        |> dict($$),
      'just_an_enum' => $this->just_an_enum,
      'just_a_union' => $this->just_a_union?->__toShape(),
      'optional_just_an_A' => $this->optional_just_an_A?->__toShape(),
      'optional_set_of_i32' => $this->optional_set_of_i32
        |> $$ === null ? null : ThriftUtil::toDArray(Dict\fill_keys($$->toValuesArray(), true)),
      'optional_list_of_i32' => $this->optional_list_of_i32
        |> $$ === null ? null : vec($$),
      'optional_list_of_string' => $this->optional_list_of_string
        |> $$ === null ? null : vec($$),
      'optional_map_of_string_to_i32' => $this->optional_map_of_string_to_i32
        |> $$ === null ? null : dict($$),
      'optional_map_of_string_to_A' => $this->optional_map_of_string_to_A?->map(
        $_val0 ==> $_val0->__toShape(),
      )
        |> $$ === null ? null : dict($$),
      'optional_map_of_string_to_list_of_i32' => $this->optional_map_of_string_to_list_of_i32?->map(
        $_val0 ==> vec($_val0),
      )
        |> $$ === null ? null : dict($$),
      'optional_map_of_string_to_list_of_A' => $this->optional_map_of_string_to_list_of_A?->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )
          |> vec($$),
      )
        |> $$ === null ? null : dict($$),
      'optional_map_of_string_to_set_of_i32' => $this->optional_map_of_string_to_set_of_i32?->map(
        $_val0 ==> ThriftUtil::toDArray(Dict\fill_keys($_val0, true)),
      )
        |> $$ === null ? null : dict($$),
      'optional_enum' => $this->optional_enum,
      'required_enum_with_default' => $this->required_enum_with_default,
      'string_with_default_value' => $this->string_with_default_value,
      'i32_with_default_value' => $this->i32_with_default_value,
      'double_with_default_value' => $this->double_with_default_value,
      'enum_with_default_value' => $this->enum_with_default_value,
      'A_with_default_value' => $this->A_with_default_value?->__toShape(),
      'set_of_i32_with_default_value' => ThriftUtil::toDArray(Dict\fill_keys($this->set_of_i32_with_default_value->toValuesArray(), true)),
      'map_of_i32_to_string_with_default_value' => dict($this->map_of_i32_to_string_with_default_value),
      'list_of_string_with_default_value' => vec($this->list_of_string_with_default_value),
      'map_of_string_to_list_of_i32_with_default_value' => $this->map_of_string_to_list_of_i32_with_default_value->map(
        $_val0 ==> vec($_val0),
      )
        |> dict($$),
    );
  }
  public function read(\TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $required_enum_with_default__isset = false;
    $xfer += $input->readStructBegin(inout $fname);
    while (true)
    {
      $xfer += $input->readFieldBegin(inout $fname, inout $ftype, inout $fid);
      if ($ftype == \TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == \TType::STRUCT) {
            $this->just_an_A = new \test\fixtures\A();
            $xfer += $this->just_an_A->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == \TType::SET) {
            $_size1 = 0;
            $_etype4 = 0;
            $_val0 = Set{};
            $xfer += $input->readSetBegin(&$_etype4, &$_size1);
            for ($_i5 = 0; $_size1 === null || $_i5 < $_size1; ++$_i5)
            {
              if ($_size1 === null && !$input->readSetHasNext()) {
                break;
              }
              $elem6 = null;
              $xfer += $input->readI32(&$elem6);
              if ($elem6 !== null) {
                $_val0->add($elem6);
              }
            }
            $xfer += $input->readSetEnd();
            $this->set_of_i32 = $_val0;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == \TType::LST) {
            $_size8 = 0;
            $_val7 = Vector {};
            $_etype11 = 0;
            $xfer += $input->readListBegin(&$_etype11, &$_size8);
            for ($_i12 = 0; $_size8 === null || $_i12 < $_size8; ++$_i12)
            {
              if ($_size8 === null && !$input->readListHasNext()) {
                break;
              }
              $elem13 = null;
              $xfer += $input->readI32(&$elem13);
              if ($elem13 !== null) {
                $_val7 []= $elem13;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_i32 = $_val7;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == \TType::LST) {
            $_size15 = 0;
            $_val14 = Vector {};
            $_etype18 = 0;
            $xfer += $input->readListBegin(&$_etype18, &$_size15);
            for ($_i19 = 0; $_size15 === null || $_i19 < $_size15; ++$_i19)
            {
              if ($_size15 === null && !$input->readListHasNext()) {
                break;
              }
              $elem20 = null;
              $xfer += $input->readString(&$elem20);
              if ($elem20 !== null) {
                $_val14 []= $elem20;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_string = $_val14;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == \TType::MAP) {
            $_size22 = 0;
            $_val21 = Map {};
            $_ktype23 = 0;
            $_vtype24 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype23,
              inout $_vtype24,
              inout $_size22,
            );
            for ($_i26 = 0; $_size22 === null || $_i26 < $_size22; ++$_i26)
            {
              if ($_size22 === null && !$input->readMapHasNext()) {
                break;
              }
              $key27 = null;
              $xfer += $input->readString(&$key27);
              $val28 = null;
              $xfer += $input->readI32(&$val28);
              if ($key27 !== null && $val28 !== null) {
                $_val21[$key27] = $val28;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_i32 = $_val21;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == \TType::MAP) {
            $_size30 = 0;
            $_val29 = Map {};
            $_ktype31 = 0;
            $_vtype32 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype31,
              inout $_vtype32,
              inout $_size30,
            );
            for ($_i34 = 0; $_size30 === null || $_i34 < $_size30; ++$_i34)
            {
              if ($_size30 === null && !$input->readMapHasNext()) {
                break;
              }
              $key35 = null;
              $xfer += $input->readString(&$key35);
              $val36 = new \test\fixtures\A();
              $xfer += $val36->read($input);
              if ($key35 !== null && $val36 !== null) {
                $_val29[$key35] = $val36;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_A = $_val29;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == \TType::MAP) {
            $_size38 = 0;
            $_val37 = Map {};
            $_ktype39 = 0;
            $_vtype40 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype39,
              inout $_vtype40,
              inout $_size38,
            );
            for ($_i42 = 0; $_size38 === null || $_i42 < $_size38; ++$_i42)
            {
              if ($_size38 === null && !$input->readMapHasNext()) {
                break;
              }
              $key43 = null;
              $xfer += $input->readString(&$key43);
              $_size46 = 0;
              $_val45 = Vector {};
              $_etype49 = 0;
              $xfer += $input->readListBegin(&$_etype49, &$_size46);
              for ($_i50 = 0; $_size46 === null || $_i50 < $_size46; ++$_i50)
              {
                if ($_size46 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem51 = null;
                $xfer += $input->readI32(&$elem51);
                if ($elem51 !== null) {
                  $_val45 []= $elem51;
                }
              }
              $xfer += $input->readListEnd();
              $val44 = $_val45;
              if ($key43 !== null && $val44 !== null) {
                $_val37[$key43] = $val44;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_list_of_i32 = $_val37;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == \TType::MAP) {
            $_size53 = 0;
            $_val52 = Map {};
            $_ktype54 = 0;
            $_vtype55 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype54,
              inout $_vtype55,
              inout $_size53,
            );
            for ($_i57 = 0; $_size53 === null || $_i57 < $_size53; ++$_i57)
            {
              if ($_size53 === null && !$input->readMapHasNext()) {
                break;
              }
              $key58 = null;
              $xfer += $input->readString(&$key58);
              $_size61 = 0;
              $_val60 = Vector {};
              $_etype64 = 0;
              $xfer += $input->readListBegin(&$_etype64, &$_size61);
              for ($_i65 = 0; $_size61 === null || $_i65 < $_size61; ++$_i65)
              {
                if ($_size61 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem66 = new \test\fixtures\A();
                $xfer += $elem66->read($input);
                if ($elem66 !== null) {
                  $_val60 []= $elem66;
                }
              }
              $xfer += $input->readListEnd();
              $val59 = $_val60;
              if ($key58 !== null && $val59 !== null) {
                $_val52[$key58] = $val59;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_list_of_A = $_val52;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == \TType::MAP) {
            $_size68 = 0;
            $_val67 = Map {};
            $_ktype69 = 0;
            $_vtype70 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype69,
              inout $_vtype70,
              inout $_size68,
            );
            for ($_i72 = 0; $_size68 === null || $_i72 < $_size68; ++$_i72)
            {
              if ($_size68 === null && !$input->readMapHasNext()) {
                break;
              }
              $key73 = null;
              $xfer += $input->readString(&$key73);
              $_size76 = 0;
              $_etype79 = 0;
              $_val75 = Set{};
              $xfer += $input->readSetBegin(&$_etype79, &$_size76);
              for ($_i80 = 0; $_size76 === null || $_i80 < $_size76; ++$_i80)
              {
                if ($_size76 === null && !$input->readSetHasNext()) {
                  break;
                }
                $elem81 = null;
                $xfer += $input->readI32(&$elem81);
                if ($elem81 !== null) {
                  $_val75->add($elem81);
                }
              }
              $xfer += $input->readSetEnd();
              $val74 = $_val75;
              if ($key73 !== null && $val74 !== null) {
                $_val67[$key73] = $val74;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_set_of_i32 = $_val67;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == \TType::MAP) {
            $_size83 = 0;
            $_val82 = Map {};
            $_ktype84 = 0;
            $_vtype85 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype84,
              inout $_vtype85,
              inout $_size83,
            );
            for ($_i87 = 0; $_size83 === null || $_i87 < $_size83; ++$_i87)
            {
              if ($_size83 === null && !$input->readMapHasNext()) {
                break;
              }
              $key88 = null;
              $xfer += $input->readString(&$key88);
              $_size91 = 0;
              $_val90 = Map {};
              $_ktype92 = 0;
              $_vtype93 = 0;
              $xfer += $input->readMapBegin(
                inout $_ktype92,
                inout $_vtype93,
                inout $_size91,
              );
              for ($_i95 = 0; $_size91 === null || $_i95 < $_size91; ++$_i95)
              {
                if ($_size91 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key96 = null;
                $xfer += $input->readString(&$key96);
                $val97 = null;
                $xfer += $input->readI32(&$val97);
                if ($key96 !== null && $val97 !== null) {
                  $_val90[$key96] = $val97;
                }
              }
              $xfer += $input->readMapEnd();
              $val89 = $_val90;
              if ($key88 !== null && $val89 !== null) {
                $_val82[$key88] = $val89;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_map_of_string_to_i32 = $_val82;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == \TType::MAP) {
            $_size99 = 0;
            $_val98 = Map {};
            $_ktype100 = 0;
            $_vtype101 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype100,
              inout $_vtype101,
              inout $_size99,
            );
            for ($_i103 = 0; $_size99 === null || $_i103 < $_size99; ++$_i103)
            {
              if ($_size99 === null && !$input->readMapHasNext()) {
                break;
              }
              $key104 = null;
              $xfer += $input->readString(&$key104);
              $_size107 = 0;
              $_val106 = Map {};
              $_ktype108 = 0;
              $_vtype109 = 0;
              $xfer += $input->readMapBegin(
                inout $_ktype108,
                inout $_vtype109,
                inout $_size107,
              );
              for ($_i111 = 0; $_size107 === null || $_i111 < $_size107; ++$_i111)
              {
                if ($_size107 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key112 = null;
                $xfer += $input->readString(&$key112);
                $val113 = new \test\fixtures\A();
                $xfer += $val113->read($input);
                if ($key112 !== null && $val113 !== null) {
                  $_val106[$key112] = $val113;
                }
              }
              $xfer += $input->readMapEnd();
              $val105 = $_val106;
              if ($key104 !== null && $val105 !== null) {
                $_val98[$key104] = $val105;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_map_of_string_to_A = $_val98;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == \TType::LST) {
            $_size115 = 0;
            $_val114 = Vector {};
            $_etype118 = 0;
            $xfer += $input->readListBegin(&$_etype118, &$_size115);
            for ($_i119 = 0; $_size115 === null || $_i119 < $_size115; ++$_i119)
            {
              if ($_size115 === null && !$input->readListHasNext()) {
                break;
              }
              $_size122 = 0;
              $_etype125 = 0;
              $_val121 = Set{};
              $xfer += $input->readSetBegin(&$_etype125, &$_size122);
              for ($_i126 = 0; $_size122 === null || $_i126 < $_size122; ++$_i126)
              {
                if ($_size122 === null && !$input->readSetHasNext()) {
                  break;
                }
                $elem127 = null;
                $xfer += $input->readI32(&$elem127);
                if ($elem127 !== null) {
                  $_val121->add($elem127);
                }
              }
              $xfer += $input->readSetEnd();
              $elem120 = $_val121;
              if ($elem120 !== null) {
                $_val114 []= $elem120;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_set_of_i32 = $_val114;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == \TType::LST) {
            $_size129 = 0;
            $_val128 = Vector {};
            $_etype132 = 0;
            $xfer += $input->readListBegin(&$_etype132, &$_size129);
            for ($_i133 = 0; $_size129 === null || $_i133 < $_size129; ++$_i133)
            {
              if ($_size129 === null && !$input->readListHasNext()) {
                break;
              }
              $_size136 = 0;
              $_val135 = Map {};
              $_ktype137 = 0;
              $_vtype138 = 0;
              $xfer += $input->readMapBegin(
                inout $_ktype137,
                inout $_vtype138,
                inout $_size136,
              );
              for ($_i140 = 0; $_size136 === null || $_i140 < $_size136; ++$_i140)
              {
                if ($_size136 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key141 = null;
                $xfer += $input->readString(&$key141);
                $_size144 = 0;
                $_val143 = Vector {};
                $_etype147 = 0;
                $xfer += $input->readListBegin(&$_etype147, &$_size144);
                for ($_i148 = 0; $_size144 === null || $_i148 < $_size144; ++$_i148)
                {
                  if ($_size144 === null && !$input->readListHasNext()) {
                    break;
                  }
                  $elem149 = new \test\fixtures\A();
                  $xfer += $elem149->read($input);
                  if ($elem149 !== null) {
                    $_val143 []= $elem149;
                  }
                }
                $xfer += $input->readListEnd();
                $val142 = $_val143;
                if ($key141 !== null && $val142 !== null) {
                  $_val135[$key141] = $val142;
                }
              }
              $xfer += $input->readMapEnd();
              $elem134 = $_val135;
              if ($elem134 !== null) {
                $_val128 []= $elem134;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_map_of_string_to_list_of_A = $_val128;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == \TType::LST) {
            $_size151 = 0;
            $_val150 = Vector {};
            $_etype154 = 0;
            $xfer += $input->readListBegin(&$_etype154, &$_size151);
            for ($_i155 = 0; $_size151 === null || $_i155 < $_size151; ++$_i155)
            {
              if ($_size151 === null && !$input->readListHasNext()) {
                break;
              }
              $_size158 = 0;
              $_val157 = Map {};
              $_ktype159 = 0;
              $_vtype160 = 0;
              $xfer += $input->readMapBegin(
                inout $_ktype159,
                inout $_vtype160,
                inout $_size158,
              );
              for ($_i162 = 0; $_size158 === null || $_i162 < $_size158; ++$_i162)
              {
                if ($_size158 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key163 = null;
                $xfer += $input->readString(&$key163);
                $val164 = new \test\fixtures\A();
                $xfer += $val164->read($input);
                if ($key163 !== null && $val164 !== null) {
                  $_val157[$key163] = $val164;
                }
              }
              $xfer += $input->readMapEnd();
              $elem156 = $_val157;
              if ($elem156 !== null) {
                $_val150 []= $elem156;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_map_of_string_to_A = $_val150;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == \TType::LST) {
            $_size166 = 0;
            $_val165 = Vector {};
            $_etype169 = 0;
            $xfer += $input->readListBegin(&$_etype169, &$_size166);
            for ($_i170 = 0; $_size166 === null || $_i170 < $_size166; ++$_i170)
            {
              if ($_size166 === null && !$input->readListHasNext()) {
                break;
              }
              $elem171 = new \test\fixtures\B();
              $xfer += $elem171->read($input);
              if ($elem171 !== null) {
                $_val165 []= $elem171;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_self = $_val165;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == \TType::MAP) {
            $_size173 = 0;
            $_val172 = Map {};
            $_ktype174 = 0;
            $_vtype175 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype174,
              inout $_vtype175,
              inout $_size173,
            );
            for ($_i177 = 0; $_size173 === null || $_i177 < $_size173; ++$_i177)
            {
              if ($_size173 === null && !$input->readMapHasNext()) {
                break;
              }
              $key178 = null;
              $xfer += $input->readString(&$key178);
              $val179 = new \test\fixtures\B();
              $xfer += $val179->read($input);
              if ($key178 !== null && $val179 !== null) {
                $_val172[$key178] = $val179;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_self = $_val172;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == \TType::I32) {
            $_val180 = null;
            $xfer += $input->readI32($_val180);
            $this->just_an_enum = \test\fixtures\Enum::coerce($_val180);

          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 18:
          if ($ftype == \TType::STRUCT) {
            $this->just_a_union = new \test\fixtures\Union();
            $xfer += $this->just_a_union->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 51:
          if ($ftype == \TType::STRUCT) {
            $this->optional_just_an_A = new \test\fixtures\A();
            $xfer += $this->optional_just_an_A->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 52:
          if ($ftype == \TType::SET) {
            $_size182 = 0;
            $_etype185 = 0;
            $_val181 = Set{};
            $xfer += $input->readSetBegin(&$_etype185, &$_size182);
            for ($_i186 = 0; $_size182 === null || $_i186 < $_size182; ++$_i186)
            {
              if ($_size182 === null && !$input->readSetHasNext()) {
                break;
              }
              $elem187 = null;
              $xfer += $input->readI32(&$elem187);
              if ($elem187 !== null) {
                $_val181->add($elem187);
              }
            }
            $xfer += $input->readSetEnd();
            $this->optional_set_of_i32 = $_val181;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 53:
          if ($ftype == \TType::LST) {
            $_size189 = 0;
            $_val188 = Vector {};
            $_etype192 = 0;
            $xfer += $input->readListBegin(&$_etype192, &$_size189);
            for ($_i193 = 0; $_size189 === null || $_i193 < $_size189; ++$_i193)
            {
              if ($_size189 === null && !$input->readListHasNext()) {
                break;
              }
              $elem194 = null;
              $xfer += $input->readI32(&$elem194);
              if ($elem194 !== null) {
                $_val188 []= $elem194;
              }
            }
            $xfer += $input->readListEnd();
            $this->optional_list_of_i32 = $_val188;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 54:
          if ($ftype == \TType::LST) {
            $_size196 = 0;
            $_val195 = Vector {};
            $_etype199 = 0;
            $xfer += $input->readListBegin(&$_etype199, &$_size196);
            for ($_i200 = 0; $_size196 === null || $_i200 < $_size196; ++$_i200)
            {
              if ($_size196 === null && !$input->readListHasNext()) {
                break;
              }
              $elem201 = null;
              $xfer += $input->readString(&$elem201);
              if ($elem201 !== null) {
                $_val195 []= $elem201;
              }
            }
            $xfer += $input->readListEnd();
            $this->optional_list_of_string = $_val195;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 55:
          if ($ftype == \TType::MAP) {
            $_size203 = 0;
            $_val202 = Map {};
            $_ktype204 = 0;
            $_vtype205 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype204,
              inout $_vtype205,
              inout $_size203,
            );
            for ($_i207 = 0; $_size203 === null || $_i207 < $_size203; ++$_i207)
            {
              if ($_size203 === null && !$input->readMapHasNext()) {
                break;
              }
              $key208 = null;
              $xfer += $input->readString(&$key208);
              $val209 = null;
              $xfer += $input->readI32(&$val209);
              if ($key208 !== null && $val209 !== null) {
                $_val202[$key208] = $val209;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_i32 = $_val202;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 56:
          if ($ftype == \TType::MAP) {
            $_size211 = 0;
            $_val210 = Map {};
            $_ktype212 = 0;
            $_vtype213 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype212,
              inout $_vtype213,
              inout $_size211,
            );
            for ($_i215 = 0; $_size211 === null || $_i215 < $_size211; ++$_i215)
            {
              if ($_size211 === null && !$input->readMapHasNext()) {
                break;
              }
              $key216 = null;
              $xfer += $input->readString(&$key216);
              $val217 = new \test\fixtures\A();
              $xfer += $val217->read($input);
              if ($key216 !== null && $val217 !== null) {
                $_val210[$key216] = $val217;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_A = $_val210;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 57:
          if ($ftype == \TType::MAP) {
            $_size219 = 0;
            $_val218 = Map {};
            $_ktype220 = 0;
            $_vtype221 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype220,
              inout $_vtype221,
              inout $_size219,
            );
            for ($_i223 = 0; $_size219 === null || $_i223 < $_size219; ++$_i223)
            {
              if ($_size219 === null && !$input->readMapHasNext()) {
                break;
              }
              $key224 = null;
              $xfer += $input->readString(&$key224);
              $_size227 = 0;
              $_val226 = Vector {};
              $_etype230 = 0;
              $xfer += $input->readListBegin(&$_etype230, &$_size227);
              for ($_i231 = 0; $_size227 === null || $_i231 < $_size227; ++$_i231)
              {
                if ($_size227 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem232 = null;
                $xfer += $input->readI32(&$elem232);
                if ($elem232 !== null) {
                  $_val226 []= $elem232;
                }
              }
              $xfer += $input->readListEnd();
              $val225 = $_val226;
              if ($key224 !== null && $val225 !== null) {
                $_val218[$key224] = $val225;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_list_of_i32 = $_val218;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 58:
          if ($ftype == \TType::MAP) {
            $_size234 = 0;
            $_val233 = Map {};
            $_ktype235 = 0;
            $_vtype236 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype235,
              inout $_vtype236,
              inout $_size234,
            );
            for ($_i238 = 0; $_size234 === null || $_i238 < $_size234; ++$_i238)
            {
              if ($_size234 === null && !$input->readMapHasNext()) {
                break;
              }
              $key239 = null;
              $xfer += $input->readString(&$key239);
              $_size242 = 0;
              $_val241 = Vector {};
              $_etype245 = 0;
              $xfer += $input->readListBegin(&$_etype245, &$_size242);
              for ($_i246 = 0; $_size242 === null || $_i246 < $_size242; ++$_i246)
              {
                if ($_size242 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem247 = new \test\fixtures\A();
                $xfer += $elem247->read($input);
                if ($elem247 !== null) {
                  $_val241 []= $elem247;
                }
              }
              $xfer += $input->readListEnd();
              $val240 = $_val241;
              if ($key239 !== null && $val240 !== null) {
                $_val233[$key239] = $val240;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_list_of_A = $_val233;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 59:
          if ($ftype == \TType::MAP) {
            $_size249 = 0;
            $_val248 = Map {};
            $_ktype250 = 0;
            $_vtype251 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype250,
              inout $_vtype251,
              inout $_size249,
            );
            for ($_i253 = 0; $_size249 === null || $_i253 < $_size249; ++$_i253)
            {
              if ($_size249 === null && !$input->readMapHasNext()) {
                break;
              }
              $key254 = null;
              $xfer += $input->readString(&$key254);
              $_size257 = 0;
              $_etype260 = 0;
              $_val256 = Set{};
              $xfer += $input->readSetBegin(&$_etype260, &$_size257);
              for ($_i261 = 0; $_size257 === null || $_i261 < $_size257; ++$_i261)
              {
                if ($_size257 === null && !$input->readSetHasNext()) {
                  break;
                }
                $elem262 = null;
                $xfer += $input->readI32(&$elem262);
                if ($elem262 !== null) {
                  $_val256->add($elem262);
                }
              }
              $xfer += $input->readSetEnd();
              $val255 = $_val256;
              if ($key254 !== null && $val255 !== null) {
                $_val248[$key254] = $val255;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_set_of_i32 = $_val248;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 60:
          if ($ftype == \TType::I32) {
            $_val263 = null;
            $xfer += $input->readI32($_val263);
            $this->optional_enum = \test\fixtures\Enum::coerce($_val263);

          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 70:
          if ($ftype == \TType::I32) {
            $_val264 = null;
            $xfer += $input->readI32($_val264);
            $this->required_enum_with_default = \test\fixtures\Enum::assert($_val264);

            $required_enum_with_default__isset = true;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 80:
          if ($ftype == \TType::STRING) {
            $xfer += $input->readString(&$this->string_with_default_value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 81:
          if ($ftype == \TType::I32) {
            $xfer += $input->readI32(&$this->i32_with_default_value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 82:
          if ($ftype == \TType::DOUBLE) {
            $xfer += $input->readDouble(&$this->double_with_default_value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 83:
          if ($ftype == \TType::I32) {
            $_val265 = null;
            $xfer += $input->readI32($_val265);
            $this->enum_with_default_value = \test\fixtures\Enum::coerce($_val265);

          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 84:
          if ($ftype == \TType::STRUCT) {
            $this->A_with_default_value = new \test\fixtures\A();
            $xfer += $this->A_with_default_value->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 85:
          if ($ftype == \TType::SET) {
            $_size267 = 0;
            $_etype270 = 0;
            $_val266 = Set{};
            $xfer += $input->readSetBegin(&$_etype270, &$_size267);
            for ($_i271 = 0; $_size267 === null || $_i271 < $_size267; ++$_i271)
            {
              if ($_size267 === null && !$input->readSetHasNext()) {
                break;
              }
              $elem272 = null;
              $xfer += $input->readI32(&$elem272);
              if ($elem272 !== null) {
                $_val266->add($elem272);
              }
            }
            $xfer += $input->readSetEnd();
            $this->set_of_i32_with_default_value = $_val266;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 86:
          if ($ftype == \TType::MAP) {
            $_size274 = 0;
            $_val273 = Map {};
            $_ktype275 = 0;
            $_vtype276 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype275,
              inout $_vtype276,
              inout $_size274,
            );
            for ($_i278 = 0; $_size274 === null || $_i278 < $_size274; ++$_i278)
            {
              if ($_size274 === null && !$input->readMapHasNext()) {
                break;
              }
              $key279 = null;
              $xfer += $input->readI32(&$key279);
              $val280 = null;
              $xfer += $input->readString(&$val280);
              if ($key279 !== null && $val280 !== null) {
                $_val273[$key279] = $val280;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_i32_to_string_with_default_value = $_val273;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 87:
          if ($ftype == \TType::LST) {
            $_size282 = 0;
            $_val281 = Vector {};
            $_etype285 = 0;
            $xfer += $input->readListBegin(&$_etype285, &$_size282);
            for ($_i286 = 0; $_size282 === null || $_i286 < $_size282; ++$_i286)
            {
              if ($_size282 === null && !$input->readListHasNext()) {
                break;
              }
              $elem287 = null;
              $xfer += $input->readString(&$elem287);
              if ($elem287 !== null) {
                $_val281 []= $elem287;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_string_with_default_value = $_val281;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 88:
          if ($ftype == \TType::MAP) {
            $_size289 = 0;
            $_val288 = Map {};
            $_ktype290 = 0;
            $_vtype291 = 0;
            $xfer += $input->readMapBegin(
              inout $_ktype290,
              inout $_vtype291,
              inout $_size289,
            );
            for ($_i293 = 0; $_size289 === null || $_i293 < $_size289; ++$_i293)
            {
              if ($_size289 === null && !$input->readMapHasNext()) {
                break;
              }
              $key294 = null;
              $xfer += $input->readString(&$key294);
              $_size297 = 0;
              $_val296 = Vector {};
              $_etype300 = 0;
              $xfer += $input->readListBegin(&$_etype300, &$_size297);
              for ($_i301 = 0; $_size297 === null || $_i301 < $_size297; ++$_i301)
              {
                if ($_size297 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem302 = null;
                $xfer += $input->readI32(&$elem302);
                if ($elem302 !== null) {
                  $_val296 []= $elem302;
                }
              }
              $xfer += $input->readListEnd();
              $val295 = $_val296;
              if ($key294 !== null && $val295 !== null) {
                $_val288[$key294] = $val295;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_list_of_i32_with_default_value = $_val288;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    if (!$required_enum_with_default__isset) {
      throw new \TProtocolException("Required field 'required_enum_with_default' was not found in serialized data! Struct: B", \TProtocolException::MISSING_REQUIRED_FIELD);
    }
    return $xfer;
  }

  public function write(\TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('B');
    if ($this->just_an_A !== null) {
      $_val0 = $this->just_an_A;
      if (!($_val0 instanceof \test\fixtures\A)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('just_an_A', \TType::STRUCT, 1);
      $xfer += $_val0->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->set_of_i32 !== null) {
      $_val1 = $this->set_of_i32;
      if (!($_val1 is Set<_>)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('set_of_i32', \TType::SET, 2);
      $output->writeSetBegin(\TType::I32, C\count($_val1));
      if ($_val1 !== null)
      {
        foreach ($_val1 as $iter2)
        {
          $xfer += $output->writeI32($iter2);
        }
      }
      $output->writeSetEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_i32 !== null) {
      $_val3 = $this->list_of_i32;
      if (!($_val3 is KeyedContainer<_, _>) && !(($_val3 is Iterator<_> || $_val3 is \IteratorAggregate<_>) && $_val3 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_i32', \TType::LST, 3);
      $output->writeListBegin(\TType::I32, C\count($_val3));
      if ($_val3 !== null)
      {
        foreach ($_val3 as $iter4)
        {
          $xfer += $output->writeI32($iter4);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_string !== null) {
      $_val5 = $this->list_of_string;
      if (!($_val5 is KeyedContainer<_, _>) && !(($_val5 is Iterator<_> || $_val5 is \IteratorAggregate<_>) && $_val5 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_string', \TType::LST, 4);
      $output->writeListBegin(\TType::STRING, C\count($_val5));
      if ($_val5 !== null)
      {
        foreach ($_val5 as $iter6)
        {
          $xfer += $output->writeString($iter6);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_i32 !== null) {
      $_val7 = $this->map_of_string_to_i32;
      if (!($_val7 is KeyedContainer<_, _>) && !(($_val7 is Iterator<_> || $_val7 is \IteratorAggregate<_>) && $_val7 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_i32', \TType::MAP, 5);
      $output->writeMapBegin(\TType::STRING, \TType::I32, C\count($_val7));
      if ($_val7 !== null)
      {
        foreach ($_val7 as $kiter8 => $viter9)
        {
          $xfer += $output->writeString($kiter8);
          $xfer += $output->writeI32($viter9);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_A !== null) {
      $_val10 = $this->map_of_string_to_A;
      if (!($_val10 is KeyedContainer<_, _>) && !(($_val10 is Iterator<_> || $_val10 is \IteratorAggregate<_>) && $_val10 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_A', \TType::MAP, 6);
      $output->writeMapBegin(\TType::STRING, \TType::STRUCT, C\count($_val10));
      if ($_val10 !== null)
      {
        foreach ($_val10 as $kiter11 => $viter12)
        {
          $xfer += $output->writeString($kiter11);
          $xfer += $viter12->write($output);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_list_of_i32 !== null) {
      $_val13 = $this->map_of_string_to_list_of_i32;
      if (!($_val13 is KeyedContainer<_, _>) && !(($_val13 is Iterator<_> || $_val13 is \IteratorAggregate<_>) && $_val13 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_list_of_i32', \TType::MAP, 7);
      $output->writeMapBegin(\TType::STRING, \TType::LST, C\count($_val13));
      if ($_val13 !== null)
      {
        foreach ($_val13 as $kiter14 => $viter15)
        {
          $xfer += $output->writeString($kiter14);
          $output->writeListBegin(\TType::I32, C\count($viter15));
          if ($viter15 !== null)
          {
            foreach ($viter15 as $iter16)
            {
              $xfer += $output->writeI32($iter16);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_list_of_A !== null) {
      $_val17 = $this->map_of_string_to_list_of_A;
      if (!($_val17 is KeyedContainer<_, _>) && !(($_val17 is Iterator<_> || $_val17 is \IteratorAggregate<_>) && $_val17 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_list_of_A', \TType::MAP, 8);
      $output->writeMapBegin(\TType::STRING, \TType::LST, C\count($_val17));
      if ($_val17 !== null)
      {
        foreach ($_val17 as $kiter18 => $viter19)
        {
          $xfer += $output->writeString($kiter18);
          $output->writeListBegin(\TType::STRUCT, C\count($viter19));
          if ($viter19 !== null)
          {
            foreach ($viter19 as $iter20)
            {
              $xfer += $iter20->write($output);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_set_of_i32 !== null) {
      $_val21 = $this->map_of_string_to_set_of_i32;
      if (!($_val21 is KeyedContainer<_, _>) && !(($_val21 is Iterator<_> || $_val21 is \IteratorAggregate<_>) && $_val21 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_set_of_i32', \TType::MAP, 9);
      $output->writeMapBegin(\TType::STRING, \TType::SET, C\count($_val21));
      if ($_val21 !== null)
      {
        foreach ($_val21 as $kiter22 => $viter23)
        {
          $xfer += $output->writeString($kiter22);
          $output->writeSetBegin(\TType::I32, C\count($viter23));
          if ($viter23 !== null)
          {
            foreach ($viter23 as $iter24)
            {
              $xfer += $output->writeI32($iter24);
            }
          }
          $output->writeSetEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_map_of_string_to_i32 !== null) {
      $_val25 = $this->map_of_string_to_map_of_string_to_i32;
      if (!($_val25 is KeyedContainer<_, _>) && !(($_val25 is Iterator<_> || $_val25 is \IteratorAggregate<_>) && $_val25 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_map_of_string_to_i32', \TType::MAP, 10);
      $output->writeMapBegin(\TType::STRING, \TType::MAP, C\count($_val25));
      if ($_val25 !== null)
      {
        foreach ($_val25 as $kiter26 => $viter27)
        {
          $xfer += $output->writeString($kiter26);
          $output->writeMapBegin(\TType::STRING, \TType::I32, C\count($viter27));
          if ($viter27 !== null)
          {
            foreach ($viter27 as $kiter28 => $viter29)
            {
              $xfer += $output->writeString($kiter28);
              $xfer += $output->writeI32($viter29);
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_map_of_string_to_A !== null) {
      $_val30 = $this->map_of_string_to_map_of_string_to_A;
      if (!($_val30 is KeyedContainer<_, _>) && !(($_val30 is Iterator<_> || $_val30 is \IteratorAggregate<_>) && $_val30 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_map_of_string_to_A', \TType::MAP, 11);
      $output->writeMapBegin(\TType::STRING, \TType::MAP, C\count($_val30));
      if ($_val30 !== null)
      {
        foreach ($_val30 as $kiter31 => $viter32)
        {
          $xfer += $output->writeString($kiter31);
          $output->writeMapBegin(\TType::STRING, \TType::STRUCT, C\count($viter32));
          if ($viter32 !== null)
          {
            foreach ($viter32 as $kiter33 => $viter34)
            {
              $xfer += $output->writeString($kiter33);
              $xfer += $viter34->write($output);
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_set_of_i32 !== null) {
      $_val35 = $this->list_of_set_of_i32;
      if (!($_val35 is KeyedContainer<_, _>) && !(($_val35 is Iterator<_> || $_val35 is \IteratorAggregate<_>) && $_val35 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_set_of_i32', \TType::LST, 12);
      $output->writeListBegin(\TType::SET, C\count($_val35));
      if ($_val35 !== null)
      {
        foreach ($_val35 as $iter36)
        {
          $output->writeSetBegin(\TType::I32, C\count($iter36));
          if ($iter36 !== null)
          {
            foreach ($iter36 as $iter37)
            {
              $xfer += $output->writeI32($iter37);
            }
          }
          $output->writeSetEnd();
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_map_of_string_to_list_of_A !== null) {
      $_val38 = $this->list_of_map_of_string_to_list_of_A;
      if (!($_val38 is KeyedContainer<_, _>) && !(($_val38 is Iterator<_> || $_val38 is \IteratorAggregate<_>) && $_val38 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_map_of_string_to_list_of_A', \TType::LST, 13);
      $output->writeListBegin(\TType::MAP, C\count($_val38));
      if ($_val38 !== null)
      {
        foreach ($_val38 as $iter39)
        {
          $output->writeMapBegin(\TType::STRING, \TType::LST, C\count($iter39));
          if ($iter39 !== null)
          {
            foreach ($iter39 as $kiter40 => $viter41)
            {
              $xfer += $output->writeString($kiter40);
              $output->writeListBegin(\TType::STRUCT, C\count($viter41));
              if ($viter41 !== null)
              {
                foreach ($viter41 as $iter42)
                {
                  $xfer += $iter42->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_map_of_string_to_A !== null) {
      $_val43 = $this->list_of_map_of_string_to_A;
      if (!($_val43 is KeyedContainer<_, _>) && !(($_val43 is Iterator<_> || $_val43 is \IteratorAggregate<_>) && $_val43 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_map_of_string_to_A', \TType::LST, 14);
      $output->writeListBegin(\TType::MAP, C\count($_val43));
      if ($_val43 !== null)
      {
        foreach ($_val43 as $iter44)
        {
          $output->writeMapBegin(\TType::STRING, \TType::STRUCT, C\count($iter44));
          if ($iter44 !== null)
          {
            foreach ($iter44 as $kiter45 => $viter46)
            {
              $xfer += $output->writeString($kiter45);
              $xfer += $viter46->write($output);
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_self !== null) {
      $_val47 = $this->list_of_self;
      if (!($_val47 is KeyedContainer<_, _>) && !(($_val47 is Iterator<_> || $_val47 is \IteratorAggregate<_>) && $_val47 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_self', \TType::LST, 15);
      $output->writeListBegin(\TType::STRUCT, C\count($_val47));
      if ($_val47 !== null)
      {
        foreach ($_val47 as $iter48)
        {
          $xfer += $iter48->write($output);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_self !== null) {
      $_val49 = $this->map_of_string_to_self;
      if (!($_val49 is KeyedContainer<_, _>) && !(($_val49 is Iterator<_> || $_val49 is \IteratorAggregate<_>) && $_val49 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_self', \TType::MAP, 16);
      $output->writeMapBegin(\TType::STRING, \TType::STRUCT, C\count($_val49));
      if ($_val49 !== null)
      {
        foreach ($_val49 as $kiter50 => $viter51)
        {
          $xfer += $output->writeString($kiter50);
          $xfer += $viter51->write($output);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->just_an_enum !== null) {
      $_val52 = \test\fixtures\Enum::assert($this->just_an_enum);
      $xfer += $output->writeFieldBegin('just_an_enum', \TType::I32, 17);
      $xfer += $output->writeI32($_val52);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->just_a_union !== null) {
      $_val53 = $this->just_a_union;
      if (!($_val53 instanceof \test\fixtures\Union)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('just_a_union', \TType::STRUCT, 18);
      $xfer += $_val53->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_just_an_A !== null) {
      $_val54 = $this->optional_just_an_A;
      if (!($_val54 instanceof \test\fixtures\A)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_just_an_A', \TType::STRUCT, 51);
      $xfer += $_val54->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_set_of_i32 !== null) {
      $_val55 = $this->optional_set_of_i32;
      if (!($_val55 is Set<_>)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_set_of_i32', \TType::SET, 52);
      $output->writeSetBegin(\TType::I32, C\count($_val55));
      if ($_val55 !== null)
      {
        foreach ($_val55 as $iter56)
        {
          $xfer += $output->writeI32($iter56);
        }
      }
      $output->writeSetEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_list_of_i32 !== null) {
      $_val57 = $this->optional_list_of_i32;
      if (!($_val57 is KeyedContainer<_, _>) && !(($_val57 is Iterator<_> || $_val57 is \IteratorAggregate<_>) && $_val57 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_list_of_i32', \TType::LST, 53);
      $output->writeListBegin(\TType::I32, C\count($_val57));
      if ($_val57 !== null)
      {
        foreach ($_val57 as $iter58)
        {
          $xfer += $output->writeI32($iter58);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_list_of_string !== null) {
      $_val59 = $this->optional_list_of_string;
      if (!($_val59 is KeyedContainer<_, _>) && !(($_val59 is Iterator<_> || $_val59 is \IteratorAggregate<_>) && $_val59 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_list_of_string', \TType::LST, 54);
      $output->writeListBegin(\TType::STRING, C\count($_val59));
      if ($_val59 !== null)
      {
        foreach ($_val59 as $iter60)
        {
          $xfer += $output->writeString($iter60);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_i32 !== null) {
      $_val61 = $this->optional_map_of_string_to_i32;
      if (!($_val61 is KeyedContainer<_, _>) && !(($_val61 is Iterator<_> || $_val61 is \IteratorAggregate<_>) && $_val61 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_i32', \TType::MAP, 55);
      $output->writeMapBegin(\TType::STRING, \TType::I32, C\count($_val61));
      if ($_val61 !== null)
      {
        foreach ($_val61 as $kiter62 => $viter63)
        {
          $xfer += $output->writeString($kiter62);
          $xfer += $output->writeI32($viter63);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_A !== null) {
      $_val64 = $this->optional_map_of_string_to_A;
      if (!($_val64 is KeyedContainer<_, _>) && !(($_val64 is Iterator<_> || $_val64 is \IteratorAggregate<_>) && $_val64 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_A', \TType::MAP, 56);
      $output->writeMapBegin(\TType::STRING, \TType::STRUCT, C\count($_val64));
      if ($_val64 !== null)
      {
        foreach ($_val64 as $kiter65 => $viter66)
        {
          $xfer += $output->writeString($kiter65);
          $xfer += $viter66->write($output);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_list_of_i32 !== null) {
      $_val67 = $this->optional_map_of_string_to_list_of_i32;
      if (!($_val67 is KeyedContainer<_, _>) && !(($_val67 is Iterator<_> || $_val67 is \IteratorAggregate<_>) && $_val67 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_list_of_i32', \TType::MAP, 57);
      $output->writeMapBegin(\TType::STRING, \TType::LST, C\count($_val67));
      if ($_val67 !== null)
      {
        foreach ($_val67 as $kiter68 => $viter69)
        {
          $xfer += $output->writeString($kiter68);
          $output->writeListBegin(\TType::I32, C\count($viter69));
          if ($viter69 !== null)
          {
            foreach ($viter69 as $iter70)
            {
              $xfer += $output->writeI32($iter70);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_list_of_A !== null) {
      $_val71 = $this->optional_map_of_string_to_list_of_A;
      if (!($_val71 is KeyedContainer<_, _>) && !(($_val71 is Iterator<_> || $_val71 is \IteratorAggregate<_>) && $_val71 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_list_of_A', \TType::MAP, 58);
      $output->writeMapBegin(\TType::STRING, \TType::LST, C\count($_val71));
      if ($_val71 !== null)
      {
        foreach ($_val71 as $kiter72 => $viter73)
        {
          $xfer += $output->writeString($kiter72);
          $output->writeListBegin(\TType::STRUCT, C\count($viter73));
          if ($viter73 !== null)
          {
            foreach ($viter73 as $iter74)
            {
              $xfer += $iter74->write($output);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_set_of_i32 !== null) {
      $_val75 = $this->optional_map_of_string_to_set_of_i32;
      if (!($_val75 is KeyedContainer<_, _>) && !(($_val75 is Iterator<_> || $_val75 is \IteratorAggregate<_>) && $_val75 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_set_of_i32', \TType::MAP, 59);
      $output->writeMapBegin(\TType::STRING, \TType::SET, C\count($_val75));
      if ($_val75 !== null)
      {
        foreach ($_val75 as $kiter76 => $viter77)
        {
          $xfer += $output->writeString($kiter76);
          $output->writeSetBegin(\TType::I32, C\count($viter77));
          if ($viter77 !== null)
          {
            foreach ($viter77 as $iter78)
            {
              $xfer += $output->writeI32($iter78);
            }
          }
          $output->writeSetEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_enum !== null) {
      $_val79 = \test\fixtures\Enum::assert($this->optional_enum);
      $xfer += $output->writeFieldBegin('optional_enum', \TType::I32, 60);
      $xfer += $output->writeI32($_val79);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->required_enum_with_default !== null) {
      $_val80 = \test\fixtures\Enum::assert($this->required_enum_with_default);
      $xfer += $output->writeFieldBegin('required_enum_with_default', \TType::I32, 70);
      $xfer += $output->writeI32($_val80);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->string_with_default_value !== null) {
      $_val81 = $this->string_with_default_value;
      $xfer += $output->writeFieldBegin('string_with_default_value', \TType::STRING, 80);
      $xfer += $output->writeString($_val81);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_with_default_value !== null) {
      $_val82 = $this->i32_with_default_value;
      $xfer += $output->writeFieldBegin('i32_with_default_value', \TType::I32, 81);
      $xfer += $output->writeI32($_val82);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->double_with_default_value !== null) {
      $_val83 = $this->double_with_default_value;
      $xfer += $output->writeFieldBegin('double_with_default_value', \TType::DOUBLE, 82);
      $xfer += $output->writeDouble($_val83);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->enum_with_default_value !== null) {
      $_val84 = \test\fixtures\Enum::assert($this->enum_with_default_value);
      $xfer += $output->writeFieldBegin('enum_with_default_value', \TType::I32, 83);
      $xfer += $output->writeI32($_val84);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->A_with_default_value !== null) {
      $_val85 = $this->A_with_default_value;
      if (!($_val85 instanceof \test\fixtures\A)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('A_with_default_value', \TType::STRUCT, 84);
      $xfer += $_val85->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->set_of_i32_with_default_value !== null) {
      $_val86 = $this->set_of_i32_with_default_value;
      if (!($_val86 is Set<_>)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('set_of_i32_with_default_value', \TType::SET, 85);
      $output->writeSetBegin(\TType::I32, C\count($_val86));
      if ($_val86 !== null)
      {
        foreach ($_val86 as $iter87)
        {
          $xfer += $output->writeI32($iter87);
        }
      }
      $output->writeSetEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_i32_to_string_with_default_value !== null) {
      $_val88 = $this->map_of_i32_to_string_with_default_value;
      if (!($_val88 is KeyedContainer<_, _>) && !(($_val88 is Iterator<_> || $_val88 is \IteratorAggregate<_>) && $_val88 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_i32_to_string_with_default_value', \TType::MAP, 86);
      $output->writeMapBegin(\TType::I32, \TType::STRING, C\count($_val88));
      if ($_val88 !== null)
      {
        foreach ($_val88 as $kiter89 => $viter90)
        {
          $xfer += $output->writeI32($kiter89);
          $xfer += $output->writeString($viter90);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_string_with_default_value !== null) {
      $_val91 = $this->list_of_string_with_default_value;
      if (!($_val91 is KeyedContainer<_, _>) && !(($_val91 is Iterator<_> || $_val91 is \IteratorAggregate<_>) && $_val91 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_string_with_default_value', \TType::LST, 87);
      $output->writeListBegin(\TType::STRING, C\count($_val91));
      if ($_val91 !== null)
      {
        foreach ($_val91 as $iter92)
        {
          $xfer += $output->writeString($iter92);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_list_of_i32_with_default_value !== null) {
      $_val93 = $this->map_of_string_to_list_of_i32_with_default_value;
      if (!($_val93 is KeyedContainer<_, _>) && !(($_val93 is Iterator<_> || $_val93 is \IteratorAggregate<_>) && $_val93 is \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_list_of_i32_with_default_value', \TType::MAP, 88);
      $output->writeMapBegin(\TType::STRING, \TType::LST, C\count($_val93));
      if ($_val93 !== null)
      {
        foreach ($_val93 as $kiter94 => $viter95)
        {
          $xfer += $output->writeString($kiter94);
          $output->writeListBegin(\TType::I32, C\count($viter95));
          if ($viter95 !== null)
          {
            foreach ($viter95 as $iter96)
            {
              $xfer += $output->writeI32($iter96);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

